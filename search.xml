<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Why do I have to learn English</title>
    <url>//2022/09/19/why-do-i-have-to-learn-english.html</url>
    <content><![CDATA[<!-- 以下所有内容均系本人愚见，万勿见怪 -->
<p>All the following content is my own foolish opinion, no offense please.</p>
<p>My native language is Chinese, but I have to use English to express myself from now on in future. My English is very poor, and think of this I feel sad.</p>
<p>Why? Why I have to learn English? Why I have to write English?</p>
<p>Well, just because Chinese may only have two characters in the future. One is 「口」, another is 「￿」.</p>
<p>On the other hand, maybe I’m not a Chinese. I don’t have ¥500,000 in cash, so I’m not qualified to be Chinese.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>**点灯</title>
    <url>//2022/10/07/%E7%82%B9%E7%81%AF.html</url>
    <content><![CDATA[<h2 id="点灯–原唱：郑-化"><a href="#点灯–原唱：郑-化" class="headerlink" title="**点灯–原唱：郑　化"></a><center>**点灯–原唱：郑　化<!-- 把歌词改成这样子的我，确实是无智啊 --></center></h2><center>抬头的一片天　是**的一片天</center>
<center>曾经在满天的*光下**的少年</center>
<center>*知道天多高　*知道海多远</center>
<center>却发誓要带着你远走到海角天边</center>
<center>****的誓言　年少**的我</center>
<center>在**中**才发现自己的**</center>
<center>看着你**的眼睛　想着**的家门</center>
<center>满天的**请为我点盏希望的灯火</center>
<center>**点灯　照亮我的家门</center>
<center>让**的孩子　找到来时的路</center>
<center>**点灯　照亮我的前程</center>
<center>用一点光　温暖孩子的心</center>
<br>
<center>现在的一片天　是**的一片天</center>
<center>**在文明的天空里<b>总是看得见</b></center>
<center>天其实并不高　海其实也不远</center>
<center>人心其实比天高比海更遥远</center>
<center>学会**的**　追逐**的我</center>
<center>在现实中**　才发现自己的**</center>
<center>看着你**的**　想着**的前程</center>
<center>远方的**请为我　点盏希望的灯火</center>
<center>**点灯　照亮我的家门</center>
<center>让**的孩子　找到来时的路</center>
<center>**点灯　照亮我的前程</center>
<center>用一点光　温暖孩子的心</center>
<br>
<center>多年以后　一场大雨*醒**的我</center>
<center>自古以来　都市的霓虹<b>一直在闪烁</b></center>
<center>天边有颗**的*光**探出了头</center>
<center>是你的眼神依旧在远方为我在等候</center>
<center>**点灯　照亮我的家门</center>
<center>让**的孩子　找到来时的路</center>
<center>**点灯　照亮我的前程</center>
<center>用一点光　温暖孩子的心</center>

<h2 id="一点不敢有的想法"><a href="#一点不敢有的想法" class="headerlink" title="一点不敢有的想法"></a>一点不敢有的想法</h2><p>听说前阵子在某节目中，有人演唱郑智化的 <em>星星点灯</em> 时，修改了多处歌词，其中☐☐☐☐<!-- 消极负面 -->类的词汇均被删改成了积极正向的词汇。<br>嗯，看时间，已经过去3个月了，我确实知道的太慢了。</p>
<p>郑智化是我很喜欢的一个歌手，星星点灯也是我很喜欢的一首歌曲，其他还有诸如：水手、你的生日、麻花辫子、大☐☐<!-- 国民 -->等等，很多歌曲我都很喜欢。<br>所以看到这样的事情，我感觉很是☐☐<!-- 愤慨 -->。</p>
<p>但是转念一想，他们之所以要修改，应该也是自我审核，避免出现☐☐<!-- 意外 -->吧。当然，即使如此，也是需要跟原作者协商，征得同意才是。</p>
<p>不过我这里更关注的其实还是自我审核。忘记了在哪里看到或听到的话，大致意思是 “因为审查机制的模糊，平台只能加大力度去自我审查，把所有可能会出现问题的内容，全部☐☐<!-- 屏蔽 -->掉”。<br>比如游戏、影视作品中，把红色的☐<!-- 血 -->改成绿色或黑色或者其他颜色，反正绝对不能是红色。因为☐<!-- 血 -->确实是红色的，你出现了红色的☐<!-- 血 -->，就<strong>有可能</strong>会不通过，虽然也有可能不会出现问题，但绿色的☐<!-- 血 -->，<strong>一定不会</strong>有问题。既然如此，为何不从一开始就改掉红色呢？<br>同样地，☐☐<!-- 屏蔽 -->掉那些<strong>可能</strong>会被审查的词汇，除了底层的——如我这般低下的——动物，会时不时的发出一点声音外，不会有任何影响。而这些动物的声音，没人会在乎。</p>
<p>一年前，官媒发声说，“伞兵”是精锐中的精锐，不容☐☐<!-- 污名 -->化。<br>嗯，我敬重他们，我不会去使用“伞兵”来表示☐☐<!-- 傻逼 -->，但是当我看到“伞兵”二字的时候，我还是会忍不住思考，它究竟是在表达“伞兵”的意思，还是“☐☐<!-- 傻逼 -->”的意思呢？当一个人说另一个人“睿智”的时候，究竟是夸赞对方聪慧？还是☐☐<!-- 辱骂 -->对方☐☐<!-- 弱智 -->呢？<br>与此同时，是不是“手表”、“水杯”、“鼠标”等等这些拼音首字母为第19位英文字母和第2位英文字母的词语也不应该☐☐<!-- 污名 -->化呢？说到底，如果人们能正常地说出本来的那个词语的话，还有必要用“伞兵”这样一个词来代替吗？</p>
<p>是的，我们自诩文明。但是即使是文明的国度，也并非所有人都没有一点☐☐<!-- 负面 -->情绪的。这些情绪需要☐☐<!-- 发泄 -->，☐<!-- 骂 -->人的话就是人们☐☐<!-- 发泄 -->的渠道，当所有的这些词汇全部消失了，那么我们只能使用美好的词汇来表达☐☐<!-- 愤怒 -->、☐☐<!-- 悲伤 -->、☐☐<!-- 鄙夷 -->等情绪了。<br>在网上看到了这样一句话，“☐☐<!--厕所-->是用来☐☐<!--排泄-->的。可如果，我们把☐☐<!--厕所-->堵上了，那么遍地都会成为☐☐<!--厕所-->”。那样的话，以后应该可以随地☐☐☐<!-- 大小便 -->了吧。</p>
<p>但是也不一定啊，也许会像《寂静之城》里那样也说不定呢？☐☐<!-- 屏蔽 -->改为白名单，我们只能说白名单内规定的字词，而后白名单内的列表长度越来越短，直到最后，白名单会成为名副其实的“白”名单——一张纯粹的白纸。<br>那个时候，寂静的城市，一定会让人“安心”下来吧。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHV4aXUuY29tL2FydGljbGUvNjAwMzc0Lmh0bWw=">《星星点灯》歌词被☐改，郑智化☐了<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubXVsYW5jaS5vcmcvbHlyaWMvc2w4MjkwLw==">星星点灯歌词<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5jaGluYXdyaXRlci5jb20uY24vbjEvMjAyMS8xMDI3L2M0MDQwNzItMzIyNjU2ODIuaHRtbA==">童诗被篡改，来自大人的“☐☐”？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuMTIzNzEuY24vMjAyMS8wOS8wNi9BUlRJMTYzMDkxNjcxMDMwMjgyMC5zaHRtbA==">“伞兵”是精锐中的精锐，不容☐☐化！<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>世界上最优美的语言</category>
      </categories>
      <tags>
        <tag>**点灯</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上最优美的语言</title>
    <url>//2022/09/19/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E4%BC%98%E7%BE%8E%E7%9A%84%E8%AF%AD%E8%A8%80.html</url>
    <content><![CDATA[<p>快一个月的时间了，终于决定写下来，如此「美好」的中文，怎么能不让人想记录呢。</p>
<h2 id="梦之一"><a href="#梦之一" class="headerlink" title="梦之一"></a>梦之一</h2><p>那是一个梦境，一个「美好」的梦境，让人「陶醉」的梦境。</p>
<p>张三在「目的明确」地行走在街上，周围的路人全都「洋溢」着「幸福」的「笑容」。偶然间，张三看到一个角落，几个人围成一圈，中间还蹲着一个人，地上浅浅的一层「黑色石油」流出。</p>
<p>显然，这些人正在「帮」中间那人解决能源不足的问题，不停地给他「按摩」，让他能产出更多的「黑色石油」。</p>
<p>张三掏出手机，决定录下如此「美好」的画面，然后拨打了一个「表扬」电话，对这几人的行为「赞不绝口」。</p>
<p>虽然非常「羡慕」，想要「大力支持」他们的行为，张三还是「开开心心」地停下了步伐，他很「希望」自己也能流出「黑色石油」增加能源产量。</p>
<p>「柔软」的床板上，张三「舒缓」地起身，回想起刚刚那「绝美」的梦境，「开心」地流出满身「幸福」的汗水。</p>
]]></content>
      <categories>
        <category>世界上最优美的语言</category>
      </categories>
      <tags>
        <tag>世界上最优美的语言</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 10.15+安装MongoDB的方法</title>
    <url>//2021/07/01/macos-10-15-%E5%AE%89%E8%A3%85mongodb%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>方法来源于<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tb3MteC10YXJiYWxsLw==">MongoDB官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>主要是MacOS Catalina之后，无法操作根目录，也就无法创建MongoDB的默认存储目录<code>/data/db</code>，因此需要创建一个其他的目录来存放。</p>
<ol>
<li><p>下载 MongoDB Community tgz压缩文件: <span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vdHJ5L2Rvd25sb2FkL2NvbW11bml0eQ==">官方下载地址<i class="fa fa-external-link-alt"></i></span>；然后解压到合适的位置</p>
</li>
<li><p>软链或复制其中的 <code>bin</code> 目录下的内容到 <code>/usr/local/bin</code> 之下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制</span></span><br><span class="line">sudo cp /path/to/the/mongodb-directory/bin/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment"># 软链</span></span><br><span class="line">sudo ln -s /path/to/the/mongodb-directory/bin/* /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></li>
<li><p>创建目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># data目录</span></span><br><span class="line">sudo mkdir -p /usr/<span class="built_in">local</span>/var/mongodb</span><br><span class="line"><span class="comment"># log目录</span></span><br><span class="line">sudo mkdir -p /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/mongodb</span><br><span class="line"><span class="comment"># 如果不是当前管理员用户，还需要给对应用户添加读写权限</span></span><br><span class="line">sudo chown my_mongodb_user /usr/<span class="built_in">local</span>/var/mongodb</span><br><span class="line">sudo chown my_mongodb_user /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/mongodb</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动MongoDB</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过命令行</span></span><br><span class="line">mongod --dbpath /usr/<span class="built_in">local</span>/var/mongodb --logpath /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/mongodb/mongo.log --fork</span><br><span class="line"><span class="comment"># 通过配置文件，默认没有该文件，需要自己创建或者从别处下载或复制</span></span><br><span class="line">mongod --config /usr/<span class="built_in">local</span>/etc/mongod.conf</span><br><span class="line"><span class="comment"># 检查是否启动成功</span></span><br><span class="line">ps aux | grep -v grep | grep mongod</span><br><span class="line"><span class="comment"># 启动成功之后即可开始使用了</span></span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>创建用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use admin;</span><br><span class="line"><span class="comment"># 创建不受限的超级用户</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">&#x27;root&#x27;</span>, <span class="built_in">pwd</span>: <span class="string">&#x27;123456&#x27;</span>, roles: [<span class="string">&#x27;root&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 创建所有库的管理员</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">&#x27;admin&#x27;</span>, <span class="built_in">pwd</span>: <span class="string">&#x27;123456&#x27;</span>, roles: [<span class="string">&#x27;dbAdminAnyDatabase&#x27;</span>]&#125;);</span><br><span class="line"><span class="comment"># 创建某个库的管理员</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">&#x27;admin&#x27;</span>, <span class="built_in">pwd</span>: <span class="string">&#x27;123456&#x27;</span>, roles: [&#123;role: <span class="string">&#x27;dbAdmin&#x27;</span>, db: <span class="string">&#x27;my_db&#x27;</span>&#125;]&#125;);</span><br><span class="line"><span class="comment"># 查看已有用户列表</span></span><br><span class="line">db.system.users.find().pretty();</span><br><span class="line"><span class="comment"># 删除某个用户</span></span><br><span class="line">db.dropUser(<span class="string">&#x27;user&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac中好用的工具</title>
    <url>//2020/12/10/mac%E4%B8%AD%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<ul>
<li>管理工具: Alfred</li>
<li>日历📅工具: Itsycal</li>
<li>截图工具: Xnip</li>
<li>命令行终端: oh-my-zsh</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL中npm命令错误</title>
    <url>//2021/07/03/wsl%E4%B8%ADnpm%E5%91%BD%E4%BB%A4%E9%94%99%E8%AF%AF.html</url>
    <content><![CDATA[<p>在 Windows 的 WSL 终端下，运行 npm 命令提示错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">: not foundram Files/nodejs/npm: 3: /mnt/c/Program Files/nodejs/npm:</span><br><span class="line">: not foundram Files/nodejs/npm: 5: /mnt/c/Program Files/nodejs/npm:</span><br><span class="line">/mnt/c/Program Files/nodejs/npm: 6: /mnt/c/Program Files/nodejs/npm: Syntax error: word unexpected (expecting <span class="string">&quot;in&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>原因是回车符号，使用 <code>vim -b npm</code> 打开 npm 文件，可以看到每行后面多了个 <code>^M</code> 的符号；这个符号代表的是 Windows 系统下的回车符 <code>\r</code>。<br>一般地，Unix 类系统的换行采用的是 <code>LF</code>，即 <code>\n</code>；<br>而 Windows 系统的换行则是 <code>CRLF</code>，即 <code>\r\n</code>；<br>这多出来的 <code>\r</code> 就是上述错误的罪魁祸首。</p>
<p>通过命令 <code>dos2unix npm</code> 把文件转换为 Unix 系的文件格式即可解决这个问题。</p>
<p>但是转换之后再次运行，又出现了错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">module.js:472</span><br><span class="line">    throw err;</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">Error: Cannot find module <span class="string">&#x27;C:\mnt\c\Program Files\nodejs\node_modules\npm\bin\npm-cli.js&#x27;</span></span><br><span class="line">    at Function.Module._resolveFilename (module.js:470:15)</span><br><span class="line">    at Function.Module._load (module.js:418:25)</span><br><span class="line">    at Module.runMain (module.js:605:10)</span><br><span class="line">    at run (bootstrap_node.js:420:7)</span><br><span class="line">    at startup (bootstrap_node.js:139:9)</span><br><span class="line">    at bootstrap_node.js:535:3</span><br></pre></td></tr></table></figure>

<p>具体原因不清楚，猜测大概是在 Windows 系统中 <code>/mnt/c/...</code> 不被认为是绝对路径，然后在前面加了个盘符，结果导致路径查找错误。</p>
<p>最后使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9XU0wvaXNzdWVzLzE1MTIjaXNzdWVjb21tZW50LTMwNTk0NDQ3Ni1wZXJtYWxpbms=">WSL issues/1512 felipemanga 提供的方法<i class="fa fa-external-link-alt"></i></span> 解决了这个问题。</p>
<p>思路就是修改 npm 文件中的 NODE_EXE 文件路径，然后新建一个 node 文件，并在其中把路径改为 Windows 路径。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># npm 文件</span><br><span class="line"># 修改 NODE_EXE 文件路径</span><br><span class="line"><span class="deletion">- NODE_EXE=&quot;$basedir/node.exe&quot;</span></span><br><span class="line"><span class="addition">+ NODE_EXE=&quot;$basedir/node&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的文件 node，写入内容</span></span><br><span class="line">vim node</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 遍历参数</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 如果参数是一个存在的文件路径</span></span><br><span class="line">  <span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$var</span>&quot;</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 修改文件路径 /mnt/c/path/to/file =&gt; c:\path\to\file</span></span><br><span class="line">    var=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span> | sed -e <span class="string">&#x27;s,^/mnt/\([a-z]\)/,\1:/,&#x27;</span> | sed -e <span class="string">&#x27;s,/,\\,g&#x27;</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 收集参数</span></span><br><span class="line">  Args=(<span class="string">&quot;<span class="variable">$&#123;Args[@]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把收集的修改过的路径参数传递给 node.exe</span></span><br><span class="line">node.exe <span class="string">&quot;<span class="variable">$&#123;Args[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为我之前用惯了 Cmder 的 bash，而上面这种方式修改之后的路径在 Cmder 中运行反而会出现错误，因此我在此基础上进行了些微修改，使其仅在 WSL 终端生效。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># node 文件</span><br><span class="line"><span class="addition">+ # 是否在 WSL 中运行</span></span><br><span class="line"><span class="addition">+ inWSL=&quot;$(uname -a | grep Linux | grep Microsoft)&quot;</span></span><br><span class="line">  for var in &quot;$@&quot;</span><br><span class="line">  do</span><br><span class="line"><span class="deletion">-   if [ -e &quot;$var&quot; ]</span></span><br><span class="line">    # 仅在 WSL 中时，修改文件路径格式</span><br><span class="line"><span class="addition">+   if [[ $inWSL &amp;&amp; -e &quot;$var&quot; ]]</span></span><br><span class="line">    then</span><br><span class="line">      var=$(echo &quot;$var&quot; | sed -e &#x27;s,^/mnt/\([a-z]\)/,\1:/,&#x27; | sed -e &#x27;s,/,\\,g&#x27;)</span><br></pre></td></tr></table></figure>

<p>对 npm 文件的操作，再对 npx 文件来一遍，也可以使用 npx 了。</p>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9XU0wvaXNzdWVzLzE1MTI=">Issue running npm command · Issue #1512 · microsoft/WSL<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hc2svMjcxMTA3">告诉我们是否在WSL中运行linux吗？-问答-阿里云开发者社区-阿里云<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1zaGVsbC1iYXNpYy1vcGVyYXRvcnMuaHRtbA==">Shell 基本运算符 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年5月11日</title>
    <url>//2021/05/10/2021%E5%B9%B45%E6%9C%8811%E6%97%A5.html</url>
    <content><![CDATA[<p>{Ph\tF$eUI|Xvi\tpIat:){^FV^F^ydB%xtprx^B%xtF_v@c{v[Uav<code>AzdZc~vXY&#125;asAzdcc&#123;v[Yxv[Exv[E&#123;v[U|x[Yx]&#123;|~E&#125;a~&#123;&#123;v[Yxv[Exv[E&#125;Z&#123;|x[Y&#125;ccs|~E|XU&#125;zX&zdXU&#125;aZggXk||X&&#125;aZ&#125;b]Y&#125;x]U|x[Y&#125;&#123;$E&#125;ccsay%k~g%wggXk|&#125;'aap"zdXc~c&Ezd%UzdH&#123;~a~Y~esUzd~sggXk|xHUzd'I&#123;v[UzdX"zg[c&#125;y~"v'szgpUzd'kzd~s&#123;v[Y&#123;vXXZ$~xC$ppX$H:X$$Bw$cRD$]`V&&h\$Ht'$]`V$H'~$sV]$Hxf'ZF>']'$$sRA$H'W$K#@$]x]&&h\$%db'Xt`$$Bw$cRD$K^e$c^&#123;%%RRRdpXztFddFr`^trx:B%&#123;tB%x:F^d::)&#123;^FfbtF^d:p[gdF&#125;dtt@ydxddd:)&#123;^pXzttwat|Sz:pvdtprc^t@ydxdddB%&#123;t|P|dtpy^:)&#123;^pXztpf&#125;^:)&#123;^FW`^Fded|uzdF&#123;cd|UgtFYddF^d:B'yd:)&#123;^FcvdFez^F):F|dtB$:|UgtFYddF^d:B'yd:)&#123;^Fded|Y&#123;^|Ka^B'ydpXztFs~^B%ddt|d:xS&#123;^Fr`^Fded:)&#123;^FfbtpHc:pXztF|x^F%adFs|:B%`dFf&#123;:Fe`tFez^:)&#123;^pg&#123;:Fz`tF>|tpuatF>|tF^d::)&#123;^^Pz^|R~:B%`dxPvtF&#125;b:B'dd^PztB%&#123;tF&#125;gtF&#125;gtFgdtpXztF|x^Ffbttd&#125;:B'yd:)&#123;^pg&#123;:Fz`tx>|^pCydtuv^B%v^F[c:xYctxTd^:)&#123;^pUb:F$bdB&v^B$x^:)fc|x[Y|~E~~Hkzd]cvcy%Azd~s|x[Y&#125;a~&#123;|~E|v[]|b[EggXk&#125;x`U&#125;xpwzd~s&#125;z~k&#123;v[Uav`AzdZc~vXY&#125;asAzdcc&#123;v[Y|~Ezd~&#125;z]IggXk|x[Y|v&A&#125;xa"|x[Y&#125;a~&#123;aKzdXg&#125;g%AggXk&#125;as~d`gzgKAzdX"&#125;as"ggXk~a~Y&#125;b[Y&#125;x`&#123;|b[EggXkzgHs|x[Y|b`Y&#125;vKc&#125;x]U&#123;vXXZ$~xC'HRU'HV>$]`V&&h\$~xC']Ff$Ht'$]`V$p'#'Kt~&&h\$~xC$p:$$pF$$]db$pB$KR)&&h\%~Rr$~xCFW&#123;&#125;y&c&#125;&#123;cgzd~sxv["&#123;vXYxv[kzgpUzd'k&#125;z]I&#125;zZwxv["&#123;vXYxv[k&#125;aZwzdX"zd~s|x[WHFW&#123;&#125;&#123;cg|csgxv["&#123;vXXZ$~xC$Ht'$a#&#125;$KR^&amp;&amp;h\$$h]$Hxf%%R@&#39;HZ&#123;$]x</code>‘XRS$pFk$]<code>&#39;%%RC$]|w&#39;p</code>R’p<code>R$KZ$KZ$$</code>T’]Ff$]<code>V$Ht&#39;$H&#39;&amp;%%RRRdpXztFYddB&#39;ydFf&#123;:F&quot;e::)&#123;^ttatFXbYCys:FaedFr</code>^F}dtFded|I<code>^FA~:|Y&#123;^F@ztpXztx&gt;|tx:dttrx:B&#39;ydtrx::)&#123;^B)g^B$&#123;dx&gt;|^Ff&#123;:F&#123;b^|IcdB&#39;ydFAat:)&#123;^FAzttD:FGatB&#39;x:B&#39;yd^Pvvc|x[Y|yp]|yp]&#125;]U&#125;g~U&#125;&#123;[w~gc&#125;]c&#125;]U~esUHUggXk&#125;y%a~%&amp;&#125;z]~g%wggXk~y[Y&#125;cKU|yp]|yp]&#125;ycw&#125;&#123;sEggXkag]g&#125;a]E|Xvc&#125;~]I&#125;~K&amp;ggXk|x[Y&#125;z[Uzd~s&#125;&#123;&#39;A&#125;&#125;]&amp;|b</code>gggXk}{sE}{$Y{cUay%kap]}dZsHUd<code>]~xs]&#123;vXXZ$H:g&#39;X^($axg$]|]$H|_$pB$KR)$$</code>T$Htv$H:}$p:)‘Xt!$KtE$p#@’Z^R$H:{$cFS’ZVP$]<code>V$KR&amp;&amp;h\$~xC$~^k$$#P%%RRRdpXztB$b^tpy^pHckTk$H:&quot;$$</code>T’]#|$’F<del>&amp;&amp;h$KR^$pBa$H’&amp;$]xZ$cF”$Hp_$</del>|:$st}$]#r&amp;&amp;h$]#V$axg$%’f$Kh<del>$</del>xC$<del>^k$s:c$%Z$’]Ff&amp;&amp;h$</del>xC$<del>^k’HRU’HV&gt;$]xP$HxY&amp;&amp;h$sRi$H^A$]d}$H|_$HVp’]:Y$s’X$pBp$<code>hy$$</code>T’HZ{$<code>R&quot;&amp;&amp;h\&#39;HRU$&#39;p&amp;&#39;]:K$]x</code>$p’#%%RRRdFV{tpP{dB$x^pve:B$:x&gt;|^pHc:F:}:FsdFdedtpy^:){^xTztFez^F”bdt&amp;{:FVe:B%x:puatB’yd:){^FVbdFZ<code>^F&quot;bdt&amp;&#123;:xx</code>:t@ydpKddF^x:FXedB’yd:){^pXztxgatFsdFdedB’yd^PvvczgHs}Z{zdHg}xH”</del>y[Y}cKUay%k|<del>E|v&amp;A|b$I}{sE<del>Z]</del>Z]|c]]}x`{ggXk|x[Y|v&amp;A}y&amp;c</del>esUggXk}y<del>“zdK&gt;zdX”}|$&amp;</del>g$ay%kzd<del>sggXk|XU}as”}Z{</del>esUzdHg}xH”ggXk}c&amp;HU{v[Uav<code>AzdZc~vXY&#125;asAzdcc&#123;v[Y&#125;&#125;~c&#125;y&#39;U&#125;&#123;&#39;IggXkxv[kzgpU&#125;&#125;pI|&#125;&amp;s&#125;v[|csgggXk|x[Y&#125;&#125;pI|&#125;&amp;s&#125;v[&#125;y~&quot;&#125;|$&amp;|pIggXYxv[!Z$~xC$$:&#125;&#39;HVE&amp;&amp;h\&#39;]:K$]</code>s$$B&amp;’K#x$ahP$&amp;dX$H:<code>$]hp$HVr$$FK$Kh~$~xC$$</code>T’XBC$cF”‘Ht&amp;&amp;h$H:<code>&#39;ZpS$~xC$%x%$ppX&#39;]:H$Kh~&#39;]:K&#39;Ht\&amp;&amp;h\$~xC$pt]$&amp;dX$axg&#39;ZpS$Kdt$a#&#125;$$</code>T%%RRRdx b^FsdFded|Y{^:){^FXb^B’ydF_a:Fda^:){^p[x:prddt<code>vttTedFE&#123;tB&#39;yd:)&#123;^pXztF@v:|&#125;cttpy^pIedFP|tpZxdp[x:prddpDgdFr</code>^x&gt;|t|Y{^FWyttDet:){^B$x:F[{tFYddpuatph<del>tprxtF%adB%xdFdv:^PvvcXg}{&amp;w</del>XY}daE<del>c’I||Z&gt;|x[Yx]{|xKA</del>g%w|pI|<del>EggXk|{`I}zZkzdHg}zX&amp;ggXkzd$sa}’&amp;|x[Y}Z{}z’cay%kggXk|x[Y</del>c&amp;E}Z{}ccszdHg}zX&amp;ggXkzd$s}{sE}aY|v$Y|<del>E</del>c&amp;EggXkzgpU}a<del>{zdX”||Z&gt;</del>c&amp;EzgpU}y&amp;c|pIzd<del>sgg[&gt;}as{cU}Z{}Z{}a[sap]|xs&amp;zgpU}zp]{vXXZ$</del>xC$$:}’HVE$]<code>V&amp;&amp;h\$~xC$ppX$H:g&#39;X^($axg$~RG$~xC$HVp$HZ&amp;$]</code>]$KR&amp;&amp;h$<del>xF’XRW$axg$]xP$H’&amp;$]x_’]:D$]dP$]|X$$`T&amp;&amp;h$%B#$KR^$Ht’$H’&amp;$</del>|:$<del>xC$]<code>V%%RRRdpXztx edt!a:x&quot;:pXzttXd^xge^B)|dp[z:tDetxgtFCxdxgxtpXztF|x^:)&#123;^tTedF@&#123;dp\vdpFcttDetxgtt&amp;|tpXztF|x^p[z:B&#39;ydx&gt;y:F^d::)&#123;^F$edFCxdxgxtF&#125;dtpXztFsdFdedB&#39;yd:)&#123;^xd</code>tF}dtB$:FsdFdedF@a:^Pvv</del>Z$<del>xC$$h)$$#s$pF(‘HF%$KFZ&amp;&amp;h$Kp[$KZK$]|w$pR $s’I$</del>F&amp;&amp;h$$h)’ZtB’HZ{$axg$]dP$]|X$]xr’ZF&gt;$KFZ&amp;&amp;h$&amp;dK$<del>xC$cdp$KFZ&amp;&amp;h$]x’$]dP$]|X’H^(‘Z:!%</del>Rr$]x_’ZpS$Hph$H<code>~%~Ru%%RS%~Rr&#39;ZpS$$RV$a|&#39;$$h]$s&#39;W$</code>:A$]xP$]d#$]<code>]%~Ru&amp;&amp;h\$]x&#39;$]dP$]|X$~xC$]x_&#39;X^($~Bw$~^W$$B~$]</code>]&amp;&amp;h$]x’$]dP$]|X$<del>xC$</del>R&amp;$axg$<del>^k$]x_$Hxf$pF($$<code>T&#39;Zt&#123;$Hpk$H</code>t$c^G&amp;&amp;h$]x’$]dP$]|X$</del>xC$<del>R&amp;$axg’HR[$</del>da’HRU’HV&gt;&amp;&amp;h$]x’$]dP$]|X&amp;&amp;h$]x’$]dP$]|X$KFZ&amp;&amp;hS&amp;&amp;hS&amp;&amp;hS</p>
]]></content>
      <categories>
        <category>树洞</category>
      </categories>
  </entry>
  <entry>
    <title>记一些英文简写</title>
    <url>//2019/01/08/%E8%AE%B0%E4%B8%80%E4%BA%9B%E8%8B%B1%E6%96%87%E7%AE%80%E5%86%99.html</url>
    <content><![CDATA[<p>abbr: abbreviation [noun], 缩写，缩写词。下面记录一些英文缩写及其对应的全拼和含义。</p>
<p>老实说真的挺烦别人用英文缩写的，除了一些特定的缩写——如HR(<em>human resource</em>)——能让大部分人一看就懂外，绝大多数英文缩写都需要沟通双方有一些相互之间的共识，且还必须有一定的英语水平才行。而即使是HR，对一些完全没听过的人来说，也是如听天书一般。更甚至一些人嘴里说着各种英文缩写，一问全拼是什么，它是什么意思，却又全然不知。</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="BE"><a href="#BE" class="headerlink" title="BE"></a>BE</h3><ul>
<li>Back-End: 后端工程师</li>
<li>Bad Ending: 【游戏】坏结局，与 <a href="#HE">HE</a> 相对立</li>
</ul>
<h3 id="BGM"><a href="#BGM" class="headerlink" title="BGM"></a>BGM</h3><ul>
<li>Background Music: 背景音乐</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><ul>
<li>Database Administrator: 数据库管理员</li>
</ul>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="ED"><a href="#ED" class="headerlink" title="ED"></a>ED</h3><ul>
<li>Ending Theme/Song: 动画片尾曲</li>
</ul>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="FE"><a href="#FE" class="headerlink" title="FE"></a>FE</h3><ul>
<li>Front-End: 前端开发</li>
</ul>
<h3 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h3><ul>
<li>Facility Management: 设备管理</li>
</ul>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h3><ul>
<li>Game Manager/Master: 游戏管理员<br>  角色扮演游戏(<a href="#RPG">RPG</a>)或网络游戏中主持游戏或监管玩家行为并维护游戏环境的负责人。 除了GM外，不同的系统可能还有 DM, storyteller, keeper, director 等称呼，功能与 GM 大致相同。</li>
</ul>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="HE"><a href="#HE" class="headerlink" title="HE"></a>HE</h3><ul>
<li>Happy Ending: 【游戏】好结局，圆满的结局。</li>
</ul>
<h3 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h3><ul>
<li>human resource: 人力资源，全称人力资源管理，又称人事。</li>
</ul>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h3><ul>
<li>internationalization: 国际化，分别取单词的首末字符i和n，18为中间的字符数。</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul>
<li><p>Internet Control Message Protocol: 互联网控制消息协议，是互联网协议族的核心协议之一。</p>
<p>  它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p>
</li>
</ul>
<h3 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h3><ul>
<li><p>Internet Engineering Task Force: 互联网工程任务组，是一个开放的标准组织，负责开发和推广自愿互联网标准（Internet Standard，简称 STD），特别是 TCP/IP 协议族的标准。</p>
<p>  它没有正式的会员资格或会员资格要求。所有参与者和经理都是志愿者，尽管他们的工作通常由雇主或赞助商资助。</p>
</li>
</ul>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><ul>
<li>internet protocol: 网际协议，也称互联网协议，是用于分组交换数据网络的一种协议。</li>
<li>intellectual property: 知识产权</li>
</ul>
<h3 id="ISOC"><a href="#ISOC" class="headerlink" title="ISOC"></a>ISOC</h3><ul>
<li>Internet Society: 互联网协会，是一个非营利的国际性组织，成立于1992年，以促进使用互联网使用为目的。</li>
</ul>
<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><ul>
<li>Movie: 剧场版动画/电影</li>
</ul>
<h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><h3 id="NE"><a href="#NE" class="headerlink" title="NE"></a>NE</h3><ul>
<li>Normal Ending: 【游戏】普通结局，正常结局</li>
</ul>
<h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><h3 id="OA"><a href="#OA" class="headerlink" title="OA"></a>OA</h3><ul>
<li>Office Automation (System): 办公自动化（系统）</li>
</ul>
<h3 id="OP"><a href="#OP" class="headerlink" title="OP"></a>OP</h3><ul>
<li>Operation: 运维工程师</li>
<li>Opening Theme/Song: 动画主题曲/片头曲</li>
</ul>
<h3 id="OST"><a href="#OST" class="headerlink" title="OST"></a>OST</h3><ul>
<li>Original Sound Track: 原声带，收录与某动画有关的音乐</li>
</ul>
<h3 id="OVA"><a href="#OVA" class="headerlink" title="OVA"></a>OVA</h3><ul>
<li>Original Video Anime: 原创动画录音带，指未在电视或电影播放过的动画</li>
</ul>
<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><h3 id="PM"><a href="#PM" class="headerlink" title="PM"></a>PM</h3><ul>
<li>Product Manager: 产品经理</li>
<li>Project Manager: 项目主管、项目经理</li>
</ul>
<h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><ul>
<li>Page View: 页面浏览量</li>
</ul>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ul>
<li>Quality Assurance: 品质保证，测试工程师</li>
</ul>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul>
<li>Questions and Answers: 问与答</li>
</ul>
<h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><ul>
<li>Query Per Second: 每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</li>
</ul>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h3 id="RD"><a href="#RD" class="headerlink" title="RD"></a>RD</h3><ul>
<li>Research and Development engineer: 研发工程师</li>
</ul>
<h3 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h3><ul>
<li><p>Request for Comments: 请求意见稿，是由互联网工程任务组（<a href="#IETF">IETF</a>）发布的一系列备忘录。</p>
<p>  文件收集了有关互联网相关信息，以及UNIX和互联网社群的软件文件，以编号排定。当前RFC文件是由互联网协会（<a href="#ISOC">ISOC</a>）赞助发行。</p>
</li>
</ul>
<h3 id="RPG"><a href="#RPG" class="headerlink" title="RPG"></a>RPG</h3><ul>
<li>Role-Playing Game: 角色扮演游戏</li>
</ul>
<h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><ul>
<li>Requests Per Second: 每秒请求数</li>
</ul>
<h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><h3 id="SCM"><a href="#SCM" class="headerlink" title="SCM"></a>SCM</h3><ul>
<li>Software Configuration Management: 软件配置管理</li>
</ul>
<h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><ul>
<li>Software Development Kit: 软件开发工具包</li>
</ul>
<h3 id="SP"><a href="#SP" class="headerlink" title="SP"></a>SP</h3><ul>
<li>Special: 动画的特别篇</li>
</ul>
<h3 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h3><ul>
<li>Internet Standard: 互联网标准，是指关于互联网相关的技术与方法论的技术规范，由互联网工程任务组（<a href="#IETF">IETF</a>）创建与发布。</li>
</ul>
<h3 id="SYS"><a href="#SYS" class="headerlink" title="SYS"></a>SYS</h3><ul>
<li>System: 系统</li>
</ul>
<h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>Transmission Control Protocol: 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由<a href="#IETF">IETF</a>的<a href="#RFC">RFC</a> 793定义。</li>
</ul>
<h3 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h3><ul>
<li>True Ending: 【游戏】真结局。可以说是作者心目中最应该达成的结局。TE 不一定就是 <a href="#HE">HE</a></li>
</ul>
<h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><ul>
<li><p>Transaction Per Second: 每秒事务处理量，通常由数据库管理系统供应商和用户社区用于描述每秒钟的数据库操作数。</p>
<p>  最近，这个术语被用来描述加密货币的交易速率，例如运行比特币区块链的分布式网络。</p>
</li>
</ul>
<h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><ul>
<li>Technology Support: 技术支持</li>
</ul>
<h3 id="TVA"><a href="#TVA" class="headerlink" title="TVA"></a>TVA</h3><ul>
<li>Television Anime: 电视上播送的动画节目</li>
</ul>
<h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>User Datagram Protocol: 用户数据报(包)协议，是一个简单的面向数据报的通信协议，位于OSI模型的传输层。</li>
</ul>
<h3 id="UE-UX"><a href="#UE-UX" class="headerlink" title="UE(UX)"></a>UE(UX)</h3><ul>
<li>User Experience: 用户体验设计师</li>
</ul>
<h3 id="UER"><a href="#UER" class="headerlink" title="UER"></a>UER</h3><ul>
<li>User Experience Research: 用户研究</li>
</ul>
<h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><ul>
<li>User Interface: 用户界面设计师</li>
</ul>
<h3 id="UT"><a href="#UT" class="headerlink" title="UT"></a>UT</h3><ul>
<li>Unit Test: 单元测试</li>
</ul>
<h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><ul>
<li>Unique Visitor: 独立访客</li>
</ul>
<h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><h2 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h2><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><hr>
<p>参考资料:</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9RUFM=">百度百科 - QPS<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5NzQyOTUxL2Fuc3dlci8xMjgyMjcyMA==">知乎 - 互联网行业的RD是什么职位<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzEyNzI2MzM1Mi5odG1s">百度知道 - PM是什么职位<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzkxNTgxNTgyLmh0bWw/cWJsPXJlbGF0ZV9xdWVzdGlvbl81">百度知道 - OVA OP ED SP这些的英文全称及意思是什么？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzU0ODc5NjcwMS5odG1sP3FibD1yZWxhdGVfcXVlc3Rpb25fNA==">百度知道 - 我想问一下op与ed的全称叫啥？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9PQSVFNyVCMyVCQiVFNyVCQiU5Rg==">百度知道 - OA系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgxJThBJUU2JTg4JUIyJUU0JUI4JUJCJUU2JThDJTgxJUU4JTgwJTg1">维基百科 - 游戏主持者<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE3JTkyJUU4JTg5JUIyJUU2JTg5JUFFJUU2JUJDJTk0JUU2JUI4JUI4JUU2JTg4JThG">维基百科 - 角色扮演游戏<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUkZD">维基百科 - RFC<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTkyJUU4JTgxJTk0JUU3JUJEJTkxJUU1JUI3JUE1JUU3JUE4JThCJUU0JUJCJUJCJUU1JThBJUExJUU3JUJCJTg0">维基百科 - 互联网工程任务组<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTkyJUU4JTgxJTk0JUU3JUJEJTkxJUU1JThEJThGJUU0JUJDJTlB">维基百科 - 互联网协会<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>abbr</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我被开除中国籍以及中文已口两件事</title>
    <url>//2022/08/21/%E5%85%B3%E4%BA%8E%E6%88%91%E8%A2%AB%E5%BC%80%E9%99%A4%E4%B8%AD%E5%9B%BD%E7%B1%8D%E4%BB%A5%E5%8F%8A%E4%B8%AD%E6%96%87%E5%B7%B2%E5%8F%A3%E4%B8%A4%E4%BB%B6%E4%BA%8B.html</url>
    <content><![CDATA[<h2 id="关于我被开除中国籍"><a href="#关于我被开除中国籍" class="headerlink" title="关于我被开除中国籍"></a>关于我被开除中国籍</h2><p>周末在家，躺在床上刷着视频的我，看到了一个标题为“<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXRXNHkxMjd0Uw==">三句话，我被专家开除了国籍…<i class="fa fa-external-link-alt"></i></span>”的视频。看完之后，我居然没有很震惊，对此【指没有感到震惊这件事】，我觉得我应该震惊一下。【无奈一笑】</p>
<p>视频里就是在说，视频UP主在抖音刷到一条视频【嗯，这应该不算是套娃吧】，一个“经济专家”讲，<q>中国人谁家没个50万呢？我们没那么穷。国内家庭平均总资产300万很正常，现在谁家没个50万现金呢？</q></p>
<p>由此我在浏览器的搜索栏里输入了“中国人 50万现金”，而后按下了回车键。嚯，好些个新闻啊。</p>
<p><img data-src="/images/posts/%E4%B8%AD%E5%9B%BD%E4%BA%BA50%E4%B8%87%E7%8E%B0%E9%87%91%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.png" alt="中国人50万现金搜索结果截图"></p>
<p>我试着从这个“专家”的话分析了一下：中国人谁家没个50万现金呢？ ⇒ 中国人每家都有50万现金 ⇒ 没有50万现金的不是中国人 ⇒ 我没有50万现金 ⇒ 我不是中国人。</p>
<p>我不禁陷入了疑惑，我不是中国人吗？我什么时候不是中国人了？我怎么突然就不是中国人了？</p>
<p>不过习惯了各种莫名其妙言论的我，已经是烂咸鱼一条躺平等死的我，完全不敢在网络发言害怕被网络警察审判的我，也只能无可奈何的静静接受这样一个事实：我，一个在中国出生、在中国长大、也将会在中国老去的默默无闻的人，已经不再是中国人了！</p>
<p>我告诫自己：作为一个无国籍的人，以后更要谨小慎微的活着，你已经没有国家了，到了任何地方你都是一个外国人了，甚至连“外国人”都不是，因为你根本就没有任何国籍。那要不想下办法，加入其它国籍吧？可是我不想啊。那以后余生就只能这么卑微的活下去了呢。</p>
<p>突然想到，这个“经济专家”好像并不能代表国家啊，国家好像并没有真的把我轰走开除中国籍诶。呼~吓我一跳，哦，应该说是自己吓自己才对。</p>
<p><del>☐☐☐☐☐☐？</del></p>
<!-- ~~真的是这样吗？~~ -->

<h2 id="关于中文已口"><a href="#关于中文已口" class="headerlink" title="关于中文已口"></a>关于中文已口</h2><p>☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐，“<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTllNHkxZjdWZw==">☐☐【☐☐vs☐☐】☐☐☐☐☐☐☐☐<i class="fa fa-external-link-alt"></i></span>”，☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐【<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNjYyNjA5MDQ1">☐☐<i class="fa fa-external-link-alt"></i></span>】，☐☐☐☐☐“<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUFCNHkxRDdGdA==">【☐☐vs☐☐】☐☐☐☐☐☐☐☐☐？<i class="fa fa-external-link-alt"></i></span>”，☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐。☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐“☐☐”☐☐☐，☐☐☐☐☐☐，☐☐☐☐☐☐☐☐。</p>
<!-- 除了看到被开除国籍的视频外，我还刷到了另一个视频，“[补档【鲁迅vs罗翔】口个人到底判几年](https://www.bilibili.com/video/BV19e4y1f7Vg)”，看标题看封面，应该是我之前看过的一个，原作者是【[云社](https://space.bilibili.com/662609045)】，原视频入口“[【鲁迅vs罗翔】口个人到底该怎么判？](https://www.bilibili.com/video/BV1AB4y1D7Ft)”，以鲁迅先生和罗翔老师的形象讲了一段相声，一段有关敏感词引起的口口文学的相声。不过标题比我当时看的时候，前面多了“补档”两个字，有点好奇之下，我准备点进去看看。 -->

<p>☐☐☐☐☐☐☐☐☐，UP☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐？☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐。</p>
<!-- 刚点开就发现不对劲，UP主账号不是原作者啊，难道是盗用视频？我直接翻到了评论区，看下来才知道原因。 -->

<p>☐☐☐☐☐☐☐☐☐【☐☐】☐☐☐☐☐☐，☐☐☐☐☐☐☐？☐☐☐☐☐☐☐☐☐☐☐☐☐。☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐。☐☐☐☐UP☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐。</p>
<!-- 以前看过的视频因为【某些】原因被下架了，或者说被隐藏了？我不清楚该用什么词汇来描述。具体来说就是，之前看过并收藏了的人依然可以看原视频，但是其他人却无法在看到那个视频了。所以这个UP主把他之前缓存下载下来的视频重新上传上来了。 -->

<p><img data-src="/images/posts/%E5%8F%A3%E4%B8%AA%E4%BA%BA%E5%88%B0%E5%BA%95%E8%AF%A5%E6%80%8E%E4%B9%88%E5%88%A4.png" alt="我收藏了还可以看到"></p>
<p><img data-src="/images/posts/%E8%A7%86%E9%A2%91%E4%B8%8D%E8%A7%81%E4%BA%86.png" alt="使用无痕模式浏览就看不到了"></p>
<p>☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐，☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐，☐☐☐☐☐☐☐？☐☐☐☐☐☐☐☐☐。</p>
<!-- 我是一个喜欢看网络小说的人，所以对于字词被和谐我是深有体会地，虽然如此，但大环境就是这样，看了视频觉得说得挺好的，也收藏了，可那又能如何呢？反正也没指望能改了。 -->

<p>☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐？☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐【☐☐☐☐☐☐☐】，☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐“<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMURnNDExNjdkbQ==">☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐<i class="fa fa-external-link-alt"></i></span>”。</p>
<!-- 可我万万没想到的是，就是这样一个视频，居然被举报下架了？胸中的一口气就这么蹭蹭地往上涨，而更令我感到气愤的是，仅仅过了一天【也许还不到一天】，补档的视频也被下架了，又有另一个人重新上传了视频，标题是“[口口文学（正义是杀不完的，因为真理永远存在）](https://www.bilibili.com/video/BV1Dg41167dm)”。 -->

<p>☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐，☐☐☐☐？</p>
<!-- 我不清楚明天是否还能看到这个视频，或许会有另一位勇士，再次上传？ -->

<p>☐☐☐☐☐☐☐☐☐☐☐☐，☐，☐☐☐☐☐？☐☐☐☐☐☐☐☐☐，☐☐：“☐☐☐☐☐☐，☐☐☐☐☐☐☐☐☐”。</p>
<!-- 我不明白这究竟是什么情况，不，也许我明白？不是有那么一句话么，叫做：“解决不了问题，就解决发现问题的人”。 -->

<p>☐☐☐☐☐☐☐☐☐，☐☐☐☐☐☐☐☐？☐☐☐☐？</p>
<!-- 那么我把这些发出来，会不会也遭遇毒手？被解决掉？ -->

<p>☐☐☐☐☐☐☐，☐☐☐☐☐☐？</p>
<!-- 我这人很胆小的，还是不要了吧？ -->
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>善心是如何被剁碎的</title>
    <url>//2021/05/17/%E5%96%84%E5%BF%83%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%89%81%E7%A2%8E%E7%9A%84.html</url>
    <content><![CDATA[<p>2021年5月13日晚我从老家坐火车，于14日早上回到了上海。之后刚出地铁站口，一个女人从我旁边走过，然后又快速折返，拦住我向我借钱，说要坐车去苏州但身上钱不够了，想问我能不能给他转账一些钱。我担心是骗子，本不想搭理，但是看到她抱着一个小孩子，结果还是没有一走了之，心想总不能因为有人骗钱而拒绝所有人吧。</p>
<p>因为没在这边坐过客车，不清楚能否微信或者支付宝付款，就问了她一句，得到了“可以”的回答。问她缺多少，19块，我通过支付宝扫码给她转了19块钱就走了。结果刚走两步，她又追上来，说是49块，她也不是乞讨的，要加我好友。我不清楚是之前就说的49块，我听错了，还是看我转账之后，想骗更多又改的口。我拿过她的手机，看了下她支付宝的金额，23块多，确实没钱，然后再次给她转了30块钱，并添加她为好友。</p>
<p><img data-src="/images/posts/0001.png" alt="支付宝转账记录"></p>
<p>如果她去了苏州之后，再把钱还给我，这事情应该会就这么结束了。可惜的是，两天时间我完全没有收到她的任何消息，16日下午，我给她发了一条消息，“49块钱？”，想要看下她是否是忘记了，虽然我内心其实已经认为我被骗了。结果也很符合我的猜测，消息如石沉大海，到17日下午也没有得到任何回应。理所当然地，我知道自己被骗了。就像是几年前，张新辉两次共借走我一千多块钱，而后也不还钱一样的，被骗了。</p>
<p><img data-src="/images/posts/0002.png" alt="询问一天无消息，确认是骗子"></p>
<p><img data-src="/images/posts/0003.png" alt="骗子的支付宝信息"></p>
<p>顺便也贴一下张新辉的微信与照片，加深一下自己的印象。</p>
<p><img data-src="/images/posts/0004.png" alt="张新辉的微信"></p>
<p><img data-src="/images/posts/0005.png" alt="张新辉，骗子记录与长相"></p>
<p>“一朝被蛇咬，十年怕井绳”，我确实的想要拒绝帮助任何人了。人们都在歌颂那些即使一次次被骗，依然愿意对陌生人伸出援手的人；这样的人确实值得人们赞赏。可放到自己身上时，又有多少人会去这么做呢？我不想这么做。小时候接触的教育是：诚实、守信……各种各样的美德。可社会却明晃晃地告诉我，那些教育是在放屁，这个社会只有一个目标：<strong>利益</strong>。</p>
<p>就这样吧，因为这么一个被骗的经历，我写下这篇记录，提醒自己，“我不会再借钱给任何陌生人了，哪怕他确实需要金钱的帮助”。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>flex子元素的flex-shrink与min-width属性</title>
    <url>//2021/08/26/flex%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84flex-shrink%E4%B8%8Emin-width%E5%B1%9E%E6%80%A7.html</url>
    <content><![CDATA[<p>工作中遇到的一个问题，在伸缩容器内，设置的文本溢出省略的样式失效了。经过精简后的代码示例如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无法溢出省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:150px;display:flex;background:skyblue;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;flex:1;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;&quot;</span>&gt;</span></span><br><span class="line">      这是一段很长又不让换行的文字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加了min-width后，可以溢出省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:150px;display:flex;background:skyblue;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;flex:1;min-width:0;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;&quot;</span>&gt;</span></span><br><span class="line">      这是一段很长又不让换行的文字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="width:150px;display:flex;background:skyblue;">
  <div style="flex:1;">
    <p style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
      这是一段很长又不让换行的文字
    </p>
  </div>
</div>

<div style="width:150px;display:flex;background:skyblue;">
  <div style="flex:1;min-width:0;">
    <p style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
      这是一段很长又不让换行的文字
    </p>
  </div>
</div>

<p>遇到问题后，在项目中找到了一处类似的且没问题的代码，发现那里有一个 <code>min-width:0;</code> 的设置，添加上去后即可解决该问题。但始终不清楚为什么，只能隐约感觉和 <code>flex-shrink</code> 有关系。</p>
<p>后面在网上查找了下，还真找到了这个情况，在 CSS 规范内有提到：</p>
<blockquote><p>By default, flex items won’t shrink below their minimum content size (the length of the longest word or fixed-size element). To change this, set the min-width or min-height property.</p>
<footer><strong>CSS Flexible Box Layout Module Level 1</strong><cite><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1mbGV4Ym94LTEvI2ZsZXgtY29tbW9u">7.1.1 Basic Values of flex<i class="fa fa-external-link-alt"></i></span></cite></footer></blockquote>

<blockquote>
<p>默认情况下，flex 子元素收缩时，不会低于它们的最小内容的尺寸，这个最小内容尺寸是指文本内容中最长的单词长度或固定尺寸元素。如果要更改这种情况，需要设置 <code>min-width</code> 或 <code>min-height</code> 属性。</p>
</blockquote>
<p>上面的那个问题就是试图通过 <code>flex:1</code> 来收缩元素的宽度，然后内容设置溢出省略。<br>而 <code>flex:1</code> 是 <code>flex: 1 1 0</code> 的简写，即 <code>flex-grow:1;flex-shrink:1;flex-basic:0;</code>。<br>通过上面的规范，我们就知道了，<code>flex-shrink:1</code> 默认情况下不会把元素收缩到低于元素内容的最小宽度，而元素的最小宽度是多少呢？因为 <code>white-space:nowrap</code> 的关系，文本不会换行，它的最小宽度就是全部文本占据的宽度，因此文本内容也就不存在<strong>溢出</strong>，自然也就没有<strong>溢出省略</strong>了。</p>
<p>而设置了 <code>min-width:0;</code> 之后，改变了 <code>flex-shrink:1</code> 的默认行为，说明可以通过 <code>flex-shrink</code> 收缩最小宽度到 <code>0</code>。这时候 <code>flex-shrink:1</code> 就可以把元素收缩到与父元素同宽度了，内容也就出现了溢出省略的情况。</p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>除了 <code>min-width</code> 外，根据上面引用的 CSS 规范描述来看，其实还有一种方式可以解决上面示例的问题——<em>固定尺寸</em>。给 flex 子元素添加宽度设置 <code>width:100%;</code>，如此它就有了一个与父容器相同宽度的<em>固定尺寸</em>了，这个尺寸还比强制文字不换行之后的文本内容要小，所以此时它的最小尺寸就是这个固定尺寸，同时还符合了文本溢出的条件【内容比尺寸大】。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:150px;display:flex;background:skyblue;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;flex:1;width:100%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;&quot;</span>&gt;</span></span><br><span class="line">      这是一段很长又不让换行的文字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="width:150px;display:flex;background:skyblue;">
  <div style="flex:1;width:100%">
    <p style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
      这是一段很长又不让换行的文字
    </p>
  </div>
</div>

<p>具体要采用哪种方式可以根据实际情况来。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZm1jcGhlZS5jb20vZmxleC1pdGVtcy1hbmQtbWluLXdpZHRoLTAv">Flex items and min-width:0<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1mbGV4Ym94LTEvI2ZsZXgtY29tbW9u">CSS Flexible Box Layout Module Level 1<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>《CSS世界》学习笔记——margin合并</title>
    <url>//2021/08/18/%E3%80%8Acss%E4%B8%96%E7%95%8C%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94margin%E5%90%88%E5%B9%B6.html</url>
    <content><![CDATA[<blockquote>
<p>以下内容为读《<a href="https://item.jd.com/12262251.html"><em>CSS世界</em></a>》4.3章 激进的margin属性 的记录<br>《<a href="https://item.jd.com/12262251.html"><em>CSS世界</em></a>》——作者：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20v">张鑫旭<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="出现margin合并的几种情况"><a href="#出现margin合并的几种情况" class="headerlink" title="出现margin合并的几种情况"></a>出现margin合并的几种情况</h2><ol>
<li>相邻兄弟元素 <span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL2Nzcy13b3JsZC9tYXJnaW4tY29tYmluZS0xLmh0bWw=">示例<i class="fa fa-external-link-alt"></i></span></li>
<li>父级元素和第一个/最后一个子元素 <span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL2Nzcy13b3JsZC9tYXJnaW4tY29tYmluZS0yLmh0bWw=">示例<i class="fa fa-external-link-alt"></i></span></li>
<li>空块级元素 <span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL2Nzcy13b3JsZC9tYXJnaW4tY29tYmluZS0zLmh0bWw=">示例<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>第1种情况是大部分人所熟知也最常见的情况，甚至被很多人称为 <em>bug</em>。我曾经也是这么理解的人之一。<br>不过看了<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20v">张鑫旭<i class="fa fa-external-link-alt"></i></span>的《<a href="https://item.jd.com/12262251.html"><em>CSS世界</em></a>》中的讲述后，虽然从其说明中并未提到<strong>规范</strong>、<strong>标准</strong>之类的字眼，但我依然愿意相信他的说法更加贴近实际情况。</p>
<blockquote>
<p>CSS世界的CSS属性是为了更好地进行图文信息展示而设计的，博客文章或新闻信息是图文信息的典型代表，基本上离不开下面这些HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文章段落1…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文章段落2…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>……<br>对于兄弟元素的margin合并其作用和em类似，都是让图文信息的排版更加舒服自然。假如说没有margin合并这种说法，那么连续段落或列表之类首尾项间距会和其他兄弟标签成1:2关系；文章标题距离顶部会很紧，而和下面的文章详情内容距离又会很开，就会造成内容上下间距不一致的情况。这些都是糟糕的排版体验。而合并机制可以保证元素上下间距一致，无论是<code>&lt;h2&gt;</code>标题这种margin偏大的元素，还是中规中矩的<code>&lt;p&gt;</code>元素</p>
</blockquote>
<h3 id="空块级元素解释"><a href="#空块级元素解释" class="headerlink" title="空块级元素解释"></a>空块级元素解释</h3><p>这里所谓空块级元素，并非是指 empty 的那种完全没有内容的空元素，而是指没有空白符以外的文本（包含字符实体如 <code>&amp;nbsp;</code>）。<br>示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 下面这些情况都没问题 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 空白符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 制表符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 空的子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 但是下面这种情况就不行了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="symbol">&amp;zwj;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="margin合并的计算规则"><a href="#margin合并的计算规则" class="headerlink" title="margin合并的计算规则"></a>margin合并的计算规则</h2><p>说明：这里的计算规则是<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20v">张鑫旭<i class="fa fa-external-link-alt"></i></span>的个人总结，而非是明确的规范定义。</p>
<ol>
<li><strong>正正取大值</strong>：如果合并的两个margin都是正数，则结果是其中的大值 <span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL2Nzcy13b3JsZC9tYXJnaW4tY29tYmluZS1ydWxlLTEuaHRtbA==">示例<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>正负值相加</strong>：如果合并的两个margin一个为正，另一个为负，则结果是两数相加 <span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL2Nzcy13b3JsZC9tYXJnaW4tY29tYmluZS1ydWxlLTIuaHRtbA==">示例<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>负负最负值</strong>（或者<strong>负负取小值</strong>）：如果合并的两个margin都是负值，则结果取其中的小值（绝对值大的那个数） <span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL2Nzcy13b3JsZC9tYXJnaW4tY29tYmluZS1ydWxlLTMuaHRtbA==">示例<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3 属性 transform 对其他元素的一些渲染影响</title>
    <url>//2019/03/05/css3-%E5%B1%9E%E6%80%A7-transform-%E5%AF%B9%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B8%B2%E6%9F%93%E5%BD%B1%E5%93%8D.html</url>
    <content><![CDATA[<p>一个偶然的情况下，发现了这样一个问题：</p>
<blockquote>
<p>给一个设置了 <em>transform</em> 属性的元素的子元素设置 <code>position: fixed</code>，实际表现却并非 <em>fixed</em> 定位的效果。</p>
</blockquote>
<p class="codepen" data-height="300" data-theme-id="36319" data-default-tab="css,result" data-user="moesuiga" data-slug-hash="PLbMza" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="PLbMza">
  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdhL3Blbi9QTGJNemEv">
  PLbMza<i class="fa fa-external-link-alt"></i></span> by 王由伟(wangyouwei) (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdh">@moesuiga<i class="fa fa-external-link-alt"></i></span>)
  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv">CodePen<i class="fa fa-external-link-alt"></i></span>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>之后在搜资料的时候看到了这样一篇文章 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTUvMDUvY3NzMy10cmFuc2Zvcm0tYWZmZWN0Lw==">CSS3 transform对普通元素的N多渲染影响 «  张鑫旭-鑫空间-鑫生活<i class="fa fa-external-link-alt"></i></span></p>
<p>里面介绍了 <em>transform</em> 属性的多种影响，然后才知道，原来 <em>transform</em> 属性有这么多值得注意的地方。</p>
<ol>
<li><p>transform 提升元素的垂直地位，类似添加了 <code>position: relative;</code> 的效果。</p>
<p> 两个元素如果有 <em>margin</em> 负值，然后出现部分重叠的时候，在没有 <em>static</em> 以外的定位时，都是后面的元素覆盖前面的元素，这样后来居上的渲染。</p>
<p> 可是如果这时候，给前面的元素添加了 <em>transform</em> 属性，就会发现，原本应该被覆盖的前面的元素，反而覆盖了后面的元素。</p>
<p> 这就是 <em>transform</em> 带来的垂直提升效果。</p>
</li>
<li><p>transform 限制 <code>position: fixed;</code> 的跟随效果，也就是我最初发现的问题点。</p>
</li>
<li><p>transform 改变 <em>overflow</em> 对 <em>absolute</em> 定位元素的限制。</p>
<p> <code>position: absolute;</code> 绝对定位的元素，如果有一个 <em>overflow</em> 不为 <em>visible</em> 的祖先元素，并且这个祖先元素一直到定位的元素之间的所有嵌套元素都没有设置了非 <em>static</em> 的 <em>position</em> 属性，那么祖先元素的 <em>overflow</em> 属性对该定位元素不起作用。</p>
<p> 这一点是我们的一贯认知，但是加了 <em>transform</em> 的话，就会改变这一点，致使 <em>absolute</em> 定位的元素也会被 <em>overflow</em> 影响。</p>
</li>
<li><p>transform 限制 <em>absolute</em> 定位元素的 <em>100%</em> 宽度大小。</p>
<p> 我们都知道 <em>absolute</em> 定位元素的宽度百分比是基于该元素最近的带有非 <em>static</em> 定位属性的祖先元素的宽度。</p>
<p> 可是如果在这两个元素之间插入一个带有 <em>transform</em> 属性的元素，就会改变这一状况，使得 <em>absolute</em> 定位元素的宽度百分比基于 <em>transform</em> 元素，而非外部带有定位属性的祖先元素。</p>
</li>
</ol>
<p>上面四点就是张鑫旭大神的文章中提到的几点影响。</p>
<p>然后我在实践过程中，发现了第5点影响：</p>
<blockquote>
<p>5、transform 会限制 <em>absolute</em> 定位元素的定位基准。</p>
</blockquote>
<p>我们知道有那么几个方位属性是跟定位紧密结合的: <em>top</em>、<em>right</em>、<em>bottom</em> 以及 <em>left</em>。</p>
<p><em>absolute</em> 定位元素的方位属性就是基于其 <em>包含块</em> 的边界来处理的。</p>
<p>一般来说，<em>absolute</em> 定位的元素，其包含块就是距离该元素最近的带有非 <em>static</em> 定位的祖先元素。<br>然而 <em>transform</em> 就可以改变这一点，使得 <em>absolute</em> 的方位属性以 <em>transform</em> 元素的边界来处理。<br>当然，前提条件是带有 <em>transform</em> 属性的元素和带有 <em>absolute</em> 定位的元素之间没有其他带有非 <em>static</em> 定位属性的元素。</p>
<p>啰嗦这一堆好像有点绕，还是直接上效果看的方便。</p>
<p class="codepen" data-height="300" data-theme-id="36319" data-default-tab="css,result" data-user="moesuiga" data-slug-hash="ZPLEJm" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="ZPLEJm">
  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdhL3Blbi9aUExFSm0v">
  ZPLEJm<i class="fa fa-external-link-alt"></i></span> by 王由伟(wangyouwei) (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdh">@moesuiga<i class="fa fa-external-link-alt"></i></span>)
  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv">CodePen<i class="fa fa-external-link-alt"></i></span>.</span>
</p>

<p>可以看到，在示例中，最里面的 <em>absolute</em> 定位元素是定位在了右上角，而中间的 <code>.transform</code> 并没有定位属性。</p>
<p>按照常理来想，黑色方块部分应该是定位在红色边框盒子的右上角的，可实际上其却被 <em>transform</em> 属性限制在了蓝色边框的盒子里，定位在了蓝色边框的盒子右上角。</p>
<p>结合上面第 4 点，<em>transform</em> 属性其实就是截断了 <em>absolute</em> 寻找其包含块的正常路径，使其本身成为了 <em>absolute</em> 定位元素的包含块。</p>
<hr>
<p>参考链接：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTUvMDUvY3NzMy10cmFuc2Zvcm0tYWZmZWN0Lw==">CSS3 transform对普通元素的N多渲染影响 «  张鑫旭-鑫空间-鑫生活<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 属性 `writing-mode` 的妙用</title>
    <url>//2019/12/11/css-%E5%B1%9E%E6%80%A7-writing-mode-%E7%9A%84%E5%A6%99%E7%94%A8.html</url>
    <content><![CDATA[<p>纵向的滚动写多了，来看看横向的滚动吧。而且不是普通的一行同级元素，而是多行同级元素自上而下排列的横向滚动。</p>
<h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><p>可以通过结合 <code>flex-direction: column</code> 和 <code>flex-wrap: wrap</code> 来达成。</p>
<p>就像下面这样:</p>
<p class="codepen" data-height="383" data-theme-id="36319" data-default-tab="css,result" data-user="moesuiga" data-slug-hash="ZEYyeQO" style="height: 383px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="[CSS] flex 实现多行纵向排列并横向滚动">
  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdhL3Blbi9aRVl5ZVFP">
  [CSS] flex 实现多行纵向排列并横向滚动<i class="fa fa-external-link-alt"></i></span> by 王由伟(wangyouwei) (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdh">@moesuiga<i class="fa fa-external-link-alt"></i></span>)
  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv">CodePen<i class="fa fa-external-link-alt"></i></span>.</span>
</p>

<p>但是这里有一点需要注意的地方：**<code>display: flex</code> 的容器盒子必须要给定一个宽度**。<br>如果没有设置宽度的话，容器是不会被容器给撑开的。</p>
<p>这对于静态内容来说也无所谓，不就是要个宽度吗，给设置一个就是了。<br>可是当内容是动态改变的呢？比如内容列表是由接口返回的，数量不定？比如来一个触底加载更多？<br>这时候要怎么办呢？</p>
<p>当然，你可以通过js来计算一下，一般这种情况，子元素 item 都是定宽定高的，容器肯定也是定高的，所以每列能放几个 item 也是可以计算得出的，然后总的 item 数量你也知道，那么就能计算出总共要放多少列，然后就能得出容器的宽度应该设置为多少了。</p>
<p>但是如果可以只使用 CSS 样式来完成的话，又何必使用 js 计算的方式呢？要知道 <em>能使用 CSS 解决的问题，就不要用 js 来解决</em>。</p>
<h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>在 CSS 中有这样一个属性: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a></p>
<blockquote>
<p>它定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p>
</blockquote>
<p>一般我们会使用它来更改文字的排列，比如我们一般看的文字都是水平方向，从左到右，自上而下的顺序。<br>但是偶尔可能会需要排布一个垂直方向自上而下，从右到左的顺序，就像古时竹简上书写内容的顺序一样。</p>
<p>就像下面这样</p>
<p class="codepen" data-height="503" data-theme-id="36319" data-default-tab="result" data-user="moesuiga" data-slug-hash="ExaXEXj" style="height: 503px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="writing-mode更改文字排版">
  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdhL3Blbi9FeGFYRVhq">
  writing-mode更改文字排版<i class="fa fa-external-link-alt"></i></span> by 王由伟(wangyouwei) (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdh">@moesuiga<i class="fa fa-external-link-alt"></i></span>)
  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv">CodePen<i class="fa fa-external-link-alt"></i></span>.</span>
</p>

<blockquote>
<p>此属性指定块流动方向，即块级容器堆叠的方向，以及行内内容在块级容器中的流动方向。<br>因此，它也确定块级内容的顺序</p>
</blockquote>
<p>也就是说，<code>writing-mode</code> 属性除了上面那种更改文字排版的用法以外，我们还可以用它来更改块级内容的排版。</p>
<p>因此，我们就可以这样做。</p>
<h2 id="flex-结合-writing-mode"><a href="#flex-结合-writing-mode" class="headerlink" title="flex 结合 writing-mode"></a>flex 结合 writing-mode</h2><p>flex 元素定高不定宽，由子元素来撑开宽度。</p>
<p class="codepen" data-height="358" data-theme-id="36319" data-default-tab="css,result" data-user="moesuiga" data-slug-hash="LYELxbR" style="height: 358px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="[CSS] flex 结合 writing-mode 实现多行纵向排列并横向滚动">
  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdhL3Blbi9MWUVMeGJS">
  [CSS] flex 结合 writing-mode 实现多行纵向排列并横向滚动<i class="fa fa-external-link-alt"></i></span> by 王由伟(wangyouwei) (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL21vZXN1aWdh">@moesuiga<i class="fa fa-external-link-alt"></i></span>)
  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv">CodePen<i class="fa fa-external-link-alt"></i></span>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>z-index与堆叠上下文</title>
    <url>//2020/07/07/z-index%E4%B8%8E%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87.html</url>
    <content><![CDATA[<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><blockquote>
<p>说明：以下说到“定位元素”时，均指 <code>position</code> 属性不为 <code>static</code> 的元素。</p>
</blockquote>
<p><code>z-index</code> 属性用于设置一个定位元素及其后代元素在Z轴（垂直屏幕的轴，指向屏幕外的方向为正）上的顺序（或层级）。<br>当元素与元素之间的位置有重叠时，<code>z-index</code> 较大的元素会覆盖较小的元素。</p>
<blockquote>
<p><strong>注意</strong>：<code>z-index</code> 的比较只在同一个堆叠上下文中有意义，在不同的堆叠上下文内比较 <code>z-index</code> 的大小来判断层级顺序的排布是毫无意义的。</p>
</blockquote>
<blockquote>
<p>值得一提的是在<span class="exturl" data-url="TUROOnotaW5kZXg=">MDN文档<i class="fa fa-external-link-alt"></i></span>中有提到 <code>z-index</code> 属性还可以设定 flex 项目的 z-order。<br>但是我尚不理解是什么意思。<br>使用两个同级的定位元素和flex元素来测试，可是并没有出现更高 <code>z-index</code> 属性的flex元素覆盖更低 <code>z-index</code> 定位元素的情况。</p>
</blockquote>
<p>除了几个全局的值 <code>inherit</code>、<code>initial</code>、<code>unset</code> 之外，<code>z-index</code> 属性可以设置的值有关键字 <code>auto</code> 和整数。</p>
<a id="more"></a>

<h3 id="auto-与-0"><a href="#auto-与-0" class="headerlink" title="auto 与 0"></a>auto 与 0</h3><p>在单纯的两个分别设置了 <code>z-index: auto</code> 和 <code>z-index: 0</code> 的定位元素进行比较层级时，二者的表现是一样的。<br>可以简单的认为 <code>z-index: auto</code> 的层级表现就是 0。</p>
<p>但是既然在这里单独拿出来比较二者有什么不同了，那肯定还是有区别的。<br>它们的不同之处就在于：</p>
<blockquote>
<p><code>z-index: auto</code> 不会创建新的堆叠上下文，而 <code>z-index: 0</code> 会创建一个新的堆叠上下文。</p>
</blockquote>
<h2 id="堆叠上下文"><a href="#堆叠上下文" class="headerlink" title="堆叠上下文"></a>堆叠上下文</h2><p>什么是堆叠上下文？</p>
<p>首先我们需要简单了解一下页面中每个元素的绘制情况。</p>
<p>把页面想象成一个桌面（或者别的什么平台的一个平面），每个元素想象成一张薄纸，元素的绘制，就像是把一张张纸按顺序从顶部到底部平铺在桌面上。</p>
<p>这个桌面就是第一个堆叠上下文。</p>
<p>上面按顺序排列纸张就是HTML的一个正常的流式布局，那么定位呢？</p>
<p>定位就是把这张纸从正常的排序中拿出来，直接放在桌面上对应定位位置的地方，此时，这张纸跟其他的纸就可能会发生重叠的情况。<br>根据 <code>z-index</code> 的大小，来决定这张定位的纸是摆在正常纸张的上面还是下面（<code>z-index</code> 为负整数）。<br>如果给这张定位的纸设置的 <code>z-index</code> 不是 <code>auto</code> 的话，就会产生一个新的堆叠上下文，你可以想象，这张纸成了一个新的平台，而平台对比它所在平台（这里就是桌面）的高度就是它的 <code>z-index</code> 属性的值。<br>后续在这张定位的纸上继续添加纸张的话，新的纸都会基于新的平台来摆放，而不再是基于原本的桌面。</p>
<p>这就是<strong>堆叠上下文</strong>。</p>
<p>了解了堆叠上下文之后，大概就可以想到为什么上面提到了 <code>z-index</code> 只在同一个堆叠上下文中才有比较的意义了吧。</p>
<p>比如现在在一个堆叠上下文中有两个定位元素，第一个定位元素是 <code>z-index: 1</code>，第二个定位元素是 <code>z-index: 100</code>。<br>然后这两个定位元素中也分别有一个定位元素，第一个元素中的子定位元素是 <code>z-index: 200</code>，而第二个元素的子定位元素是 <code>z-index: 1</code>。<br>乍一看，<code>z-index: 200</code> 应该是最高的，但是它的上下文是 <code>z-index: 1</code>，不论这个子元素的层级有多高，也无法摆脱它所在的平台实在太低的事实。<br>同样的，第二个元素的子元素层级只有 1，可是它的平台高啊，所以你会看到实际情况是 第二个元素的子元素是高过第一个元素的子元素的。</p>
<p>然后当把第一个元素的 <code>z-index: 1</code> 改为 <code>z-index: auto</code> 之后，你会发现，它的子元素反过来盖住了第二个元素及其子元素，原因就是 <code>z-index: auto</code> 不会创建堆叠上下文，使得其子元素与第二个元素处于同一个堆叠上下文，而显然 <code>200 &gt; 100</code>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="TUROOnotaW5kZXg=">MDN z-index<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 border-image 实现图片的特殊拉伸</title>
    <url>//2019/03/12/%E4%BD%BF%E7%94%A8-border-image-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E7%89%B9%E6%AE%8A%E6%8B%89%E4%BC%B8.html</url>
    <content><![CDATA[<p>今天设计妹子问了我一个问题：</p>
<p><img data-src="/images/posts/0af1f1da3d377c2d4405b.png" alt="优惠券图片"></p>
<blockquote>
<p>图片里左边的部分定宽，右边的部分需要根据内容文字来加长或缩短，但是又不能致使图片变形，只能从中间部分加长。不知道要怎么配合切图。</p>
</blockquote>
<p>我的第一想法是用 <code>background</code> 来做，随你怎么切图，我直接填充进去就行了。</p>
<p>但是实际效果很明显不符合设计妹子的要求。</p>
<div style="width: 80px; height: 68px; line-height: 68px; text-align: center; background: url(/images/posts/d22ea6dd07ce2041566cc.png) no-repeat 0 0 / 100% 100%;">10元</div>

<h2 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h2><p>但是我隐约记得曾经看到过类似的效果，只是不记得具体的实现了，好像是用的 <code>background</code> 或者是 <code>border-image</code>。</p>
<p>于是在多次查找、调试 <code>background</code> 无果后，我果断转而查找了下 <code>border-image</code>。</p>
<p>于是发现了 <code>border-image-slice</code> 这样一个属性。</p>
<blockquote>
<p>通过 <code>border-image-source</code> 引用边框图片后，<code>border-image-slice</code> 属性会将图片分割为 9 个区域：四个角，四个边（edges）以及中心区域。<br>四条切片线，从它们各自的侧边设置给定距离，控制区域的大小。</p>
</blockquote>
<p>然后我就可以这样做</p>
<div style="position: relative; z-index: 0; width: 80px; height: 68px; line-height: 68px; text-align: center;"><div style="width: 100%; height: 100%;">10元</div><div style="width: 100%; height: 100%; box-sizing: border-box; position: absolute; left: 0; top: 0; z-index: -1; border-width: 34px; border-style: solid; -webkit-border-image: url(/images/posts/d22ea6dd07ce2041566cc.png) 50% 34 repeat;border-image: url(/images/posts/d22ea6dd07ce2041566cc.png) 50% 34 repeat;"></div></div>


<p>随着宽度的改变，图片也会进行拉伸，但是却不会影响到右边的圆角及内凹弧度</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>在 Safari 浏览器中，不能设置 <code>border-color: transparent;</code>，否则 <code>border-image</code> 会不显示。</li>
<li>根据 MDN 的文档，<code>border-image-slice</code> 属性有一个关键字的值 <em>fill</em>。但是在 Chrome 实际测试的时候却发现并不支持，可能是暂时并未实现。（2019年3月12日，Chrome: 72.0.3626.121）</li>
</ol>
<h3 id="CanIUse"><a href="#CanIUse" class="headerlink" title="CanIUse"></a>CanIUse</h3><p><img data-src="/images/posts/caniuse-border-image5eb44.png" alt="CanIUse-border-image"></p>
<p>时间：2019年3月12日</p>
<p>从 CanIUse 里可以看到，<code>border-image</code> 属性已经被大部分浏览器实现了，只是其中还有一些个别的问题。</p>
<p>比如:<br>不正确的覆盖 <code>border-style</code> 属性，<br>不支持 <code>border-image-repeat: space</code>，<br>只支持简写的 <code>border-image</code>， 而不支持单独的属性（<code>border-image-source</code>, <code>border-image-slice</code>, etc）<br>不支持 <code>border-image-repeat: round</code></p>
<p>另外使用时还需要加一个 <code>-webkit-</code> 前缀来兼容更多浏览器。</p>
<hr>
<p>参考链接：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL2JvcmRlci1pbWFnZQ==">border-image | MDN<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL2JvcmRlci1pbWFnZS1zbGljZQ==">border-image-slice | MDN<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWJvcmRlci1pbWFnZQ==">Can I Use<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 nth-child 和 nth-of-type 选择器</title>
    <url>//2018/05/22/%E5%85%B3%E4%BA%8E-nth-child-%E5%92%8C-nth-of-type-%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="首先是二者的区别"><a href="#首先是二者的区别" class="headerlink" title="首先是二者的区别"></a>首先是二者的区别</h2><p><code>:nth-child(n)</code> 是选择父元素的第 n 个子元素。<br><code>:nth-of-type(n)</code> 是选择父元素的第 n 个<strong>同类型</strong>的子元素</p>
<p>举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>title1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 设为红色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* nth-child */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* nth-of-type */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>结果：<br><img data-src="/images/posts/15609154508763ed306.png" alt="样式结果"></p>
<p>如果改为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br><img data-src="/images/posts/15609155282272016.png" alt="p:nth-child(2)的结果"></p>
<p><code>p:nth-child(2)</code> 选择的是第 2 个子元素，且是 p 元素。（先找第 2 个，再找是不是 p）<br><code>p:nth-of-type(2)</code> 则是选择第 2 个为 p 的子元素。（先找 p，再找第 2 个）</p>
<h2 id="使用类名的时候（重点）"><a href="#使用类名的时候（重点）" class="headerlink" title="使用类名的时候（重点）"></a>使用类名的时候（重点）</h2><p>平时写样式的时候，直接使用标签名还是比较少的，最多的还是类名。<br><code>.class:nth-child(n)</code>还是一样，选择第 n 个子元素，且含有<code>.class</code>类名的元素。（虽然结果是这样，但这个说法还是不准确的，其实就是一个交集选择器，写成<code>:nth-child(n).class</code>就容易理解了吧，大概）</p>
<p>但是<code>.class:nth-of-type(n)</code>是否也是选择第 n 个同类名的元素呢？</p>
<p><em>我之前一直是这么以为的，而且因为使用的时候没出现过差错，所以就想当然的认为是没错的。</em></p>
<p><strong>所以，是的，这是不对的。</strong></p>
<p>找了很多说明这两个选择的使用的介绍，但都没有说过与类名结合起来的使用。这里做一个踩坑的记录。</p>
<p>先说结论吧：</p>
<blockquote>
<p><code>.class:nth-of-type(n)</code> 匹配的时候，是寻找到<code>.class</code>所在的标签，然后匹配<code>element:nth-of-type(n).class</code>的即先找到有<code>.class</code>类的标签，然后匹配第 n 个该标签的子元素，然后还要求匹配到的元素类名为<code>class</code></p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>title1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>paragraph1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;test2&quot;</span>&gt;</span>paragraph2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;test test2&quot;</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="comment">&lt;!-- 设为红色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br><img data-src="/images/posts/15609156289249143e8.png" alt=".test:nth-of-type(2)的结果"></p>
<p>如果改成<code>.test2:nth-of-type(2)</code>呢？<br><img data-src="/images/posts/15609156653718e0076.png" alt=".test2:nth-of-type(2)的结果"></p>
<p>第 2 个<code>p.test2</code>也成了红色。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要总结的话，应该是说<code>:nth-child</code>和<code>:nth-of-type</code>只会对标签生效，加上类名只是普通的<strong>交集选择器</strong>。就好像<code>.a.b</code>这样的选择器一样，只不过<code>.class:nth-of-type</code>这样的写法容易引起误会罢了。（我就深受其害啊，o(╥﹏╥)o）</p>
<h3 id="补充猜想："><a href="#补充猜想：" class="headerlink" title="补充猜想："></a>补充猜想：</h3><blockquote>
<p>很可能所有的伪类选择器，甚至还有伪元素选择器都只对标签生效。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何隐藏搜索框中自带的放大镜与清除按钮</title>
    <url>//2021/11/10/%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E6%90%9C%E7%B4%A2%E6%A1%86%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E6%94%BE%E5%A4%A7%E9%95%9C%E4%B8%8E%E6%B8%85%E9%99%A4%E6%8C%89%E9%92%AE.html</url>
    <content><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在有搜索功能的页面，测试希望搜索时，键盘的确认按钮能是“搜索”，然后便有了这次记录。</p>
<h2 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h2><p><code>&lt;input&gt;</code> 输入框的 <code>type</code> 属性有一个 <code>search</code>，有对搜索相关的优化支持，其中就包括使键盘的确认按钮显示为“搜索”。</p>
<input type="search" placeholder="这是一个搜索框" />

<p>嗯，功能是解决了，但随之而来的是另一个问题，那就是搜索框自带的前面的放大镜按钮🔍和后面的清除按钮×。<br>前面的放大镜可能是Safari中才有，但后面的清除按钮大部分浏览器中都存在。对搜索框而言，这本是一个好的东西，但是在实际项目中，基本都有各自的UI样式，这些内容反而是需要去除的。<br>因此我只能在网上查找如何去除它们。</p>
<h2 id="去除搜索框自带按钮"><a href="#去除搜索框自带按钮" class="headerlink" title="去除搜索框自带按钮"></a>去除搜索框自带按钮</h2><p>然后我找到了 <span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzE4MjQ1MTczMzc5Mjk3NDAxNDguaHRtbA==">解决方案<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span><span class="selector-pseudo">::-webkit-search-decoration</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span><span class="selector-pseudo">::-webkit-search-cancel-button</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span><span class="selector-pseudo">::-webkit-search-results-button</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span><span class="selector-pseudo">::-webkit-search-results-decoration</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>.search-input::-webkit-search-decoration,.search-input::-webkit-search-cancel-button,.search-input::-webkit-search-results-button,.search-input::-webkit-search-results-decoration {display: none;}</style>
<input class="search-input" type="search" placeholder="去除自带按钮的搜索框" />

<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzE4MjQ1MTczMzc5Mjk3NDAxNDguaHRtbA==">怎么删除搜索框左边的搜索按钮<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动</title>
    <url>//2017/07/17/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html</url>
    <content><![CDATA[<p>首先需要明确的一点是：清除浮动并不是将浮动的样式清除掉，而是闭合浮动，使得添加了清除浮动样式的元素，检测其前面的浮动元素并将浮动闭合起来，让其后的元素不受影响。</p>
<a id="more"></a>

<p>很多人对这一样式有误解，一个是因为“清除浮动”这个名字；还有一个原因大概是因为大多数时候，清除浮动的样式是使用父元素的伪元素after（IE8中是伪类）来实现的，看起来就好像是父元素将内部的浮动样式清除了一样。</p>
<p>但事实上并非如此，其原理正如我声明的一样，是父元素的after伪元素（伪类）将内部子元素的浮动样式“闭合”了起来，而非“清除”。</p>
<p><code>clear: left/right/both</code> 其含义就是说，让添加了这个样式的左侧或者右侧或者两侧不能有浮动元素出现。</p>
<p>回想一下，浮动元素是不占位置的，按照流式布局，从上到下的排列，如果某个元素浮动了，那么它原本的位置就空了出来，下面的元素就会顺势顶上去。但是如果给紧挨着浮动元素的下一个元素添加了清除浮动呢？它会检测旁边有没有浮动的元素，如果有，就不会向上占据浮动元素的位置，而是继续挨着浮动元素的底部。</p>
<p>以下是个人见解，可能实际情况并非如此，如有错误，请指正。</p>
<p>那么这个清除浮动的样式添加在父元素的after伪元素（伪类）上时，达成的效果就是在父元素的最后将子元素的浮动效果闭合，加上给after伪元素（伪类）添加一系列样式如：<br><code>display: block;</code>、 <code>height: 0;</code>、 <code>visibility: none;</code>等，将其可能造成的布局影响消除掉。如此在容器中的元素浮动之后，原本没设置高度的父元素本应该因为检索不到浮动子元素的高而导致高度为0，但是因为after伪元素（伪类）占据了一个位置，虽然其高度为0，但是其位置能被父元素检索到，于是父元素的高度因为这个after而变得能将浮动的子元素给包进去了。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>盒子边距百分比计算</title>
    <url>//2017/07/12/%E7%9B%92%E5%AD%90%E8%BE%B9%E8%B7%9D%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97.html</url>
    <content><![CDATA[<p>之前一直认为 <code>margin-top</code> 和 <code>margin-bottom</code> 设置百分比以父容器的高度计算，而 <code>margin-left</code> 和 <code>margin-right</code> 设置百分比以父容器的宽度计算，直到今天群里一个群友问：</p>
<blockquote>
<p>bootstrap 中的栅格系统是如何设置 margin-top 百分比以宽度计算的?</p>
</blockquote>
<p>原因是他发现设置的 <code>margin: 10% 10%;</code> 中 <code>top</code> 和 <code>bottom</code> 值是以父容器的宽度计算得到的结果。</p>
<p>经过一番测试及网上查找，才发现：原来 <code>margin-top</code> 和 <code>margin-bottom</code> 并不是以父容器的高度计算百分比的，而是同样以父容器宽度来计算，同样的 <code>padding</code> 内边距也是一样。</p>
<p>如按照以下样式设置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10%</span> <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>得到的结果是：</p>
<p><img data-src="/images/posts/margind6856.png" alt="margind6856.png"></p>
<p>不过也不是绝对这样，如果设置了 <code>writing-mode</code> 为纵向书写，比如 <code>-webkit-writing-mode: vertical-lr;</code> 此时按百分比书写的margin就会参照容器的高度来计算了。</p>
<p>在上例中的 father 中添加 <code>-webkit-writing-mode: vertical-lr;</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">-webkit-writing-mode</span>: vertical-lr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果就是：</p>
<p><img data-src="/images/posts/margin28db32.png" alt="margin28db32.png"></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>透明渐变在Chrome与Safari中的不同</title>
    <url>//2022/10/12/%E9%80%8F%E6%98%8E%E6%B8%90%E5%8F%98%E5%9C%A8chrome%E4%B8%8Esafari%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C.html</url>
    <content><![CDATA[<p>起因是以前有几次写的透明渐变遮罩，在部分iOS手机上出现了一些样式异常，具体表现为颜色错误，本应是纯色透明的渐变，却莫名出现了一些半透明的黑色。</p>
<p>后来通过搜索查找以及测试，明了了这些问题的发生原因。</p>
<p>这是由于 Safari 浏览器对于透明色渐变的处理方式与 Chrome 浏览器不同导致的。</p>
<p>常识上，我们理解的透明色就是完全透明的、没有任何颜色的，所以比较倾向于 Chrome 浏览器中的渲染效果：从透明到某个不透明颜色的逐渐变化。</p>
<p><img data-src="/images/posts/transparent_gradient_in_chrome.png" alt="透明渐变在Chrome中的效果"></p>
<p>而 Safari 对此的处理明显是不同的。在电子屏幕中，通常使用 rgb 颜色通道来展示颜色，而在此之外，还有一个 alpha 的透明通道。透明色之所以是透明的，就在于这个 alpha 通道。<br>但同时透明色本身也是一种颜色，它也有自己的 rgb 颜色，虽然不论它的 rgb 色值是什么，都会因为 alpha 值为 0 而不可见，但不可否认的是，透明色确实存在 rgb 颜色通道。<br>而 Safari 在处理透明渐变时，除了透明度的变化外，也会根据透明色的 rgb 颜色对渐变进行过渡。<br>即 Safari 浏览器的透明渐变会同时渐变 alpha 通道和 rgb 通道。</p>
<p>然后还有一点需要了解的是，在 CSS 颜色值中，有一个 <code>transparent</code> 关键字表示透明色，而它其实相当于 <code>rgba(0,0,0,0)</code> 色值的一个别名。</p>
<p>所以，如果在渐变背景中，使用了 <code>transparent</code> 关键字，在 Safari 中的渲染就会把非透明颜色到透明颜色渐变的过程中，增加一个到 <code>rgb(0,0,0)</code> 的颜色通道的渐变。<br>而这也是我之前出现问题的原因，因为我使用了 <code>transparent</code> 作为透明色的渐变节点。</p>
<p><img data-src="/images/posts/transparent_gradient_in_safari.png" alt="透明渐变在Safari中的效果"></p>
<p>以上两个效果图，可以分别在 Chrome 和 Safari 中打开<span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL2RlbW9zL3RyYW5zcGFyZW50LWdyYWRpZW50Lmh0bWw=">此链接<i class="fa fa-external-link-alt"></i></span>实时查看。</p>
<p>通过以上结论，为了保持 Chrome 与 Safari 的一致性，以后在写渐变背景时，最好把透明色写成 rgba 的形式，并且透明色中的 rgb 色值也需要特别注意，不能随便写。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Warning IP address could not be resolved</title>
    <url>//2021/08/17/mysql-warning-ip-address-could-not-be-resolved.html</url>
    <content><![CDATA[<h2 id="警告与解决方式"><a href="#警告与解决方式" class="headerlink" title="警告与解决方式"></a>警告与解决方式</h2><p>今天在服务器上看了下 MySQL 的错误日志，发现有大量的警告信息 <code>[Warning] [MY-010055] [Server] IP address &#39;xxx.xxx.xxx.xxx&#39; could not be resolved: Name or service not known</code>，经过查找，了解到是 DNS 反解析错误。</p>
<p>因为 MySQL 数据库服务器没有配置 <code>/etc/hosts</code>，也没有 DNS 服务，导致了 mysqld 反向解析 IP 对应的域名失败。</p>
<p>解决方式可以通过添加 <code>skip_name_resolve</code> 配置到 <code>/etc/my.cnf</code> 中来跳过 DNS 反解析。<br>不过需要了解的是，这种解决方式会使得 MySQL 中的 <code>mysql.user</code> 用户表里的 <code>HOST</code> 列不能使用域名，只能使用 localhost 或者 IP 地址，否则无法登录。</p>
<p>所以在这么做之前，最好做个检查。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>,host <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> host &lt;&gt; <span class="string">&#x27;localhost&#x27;</span> <span class="keyword">AND</span> host <span class="keyword">RLIKE</span> <span class="string">&#x27;[a-z]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>确认没有问题之后，打开 <code>/etc/my.cnf</code> 文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">skip_name_resolve</span>=<span class="number">1</span></span><br><span class="line">skip_host_cache</span><br></pre></td></tr></table></figure>

<p>然后重启 mysqld 服务 <code>service mysqld restart</code> 即可。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGlnZGVlcC9wLzQ5MDY0MjMuaHRtbA==">https://www.cnblogs.com/digdeep/p/4906423.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzM5Mzg2Mi9teXNxbC13YXJuaW5nLWlwLWFkZHJlc3MtY291bGQtbm90LWJlLXJlc29sdmVk">https://serverfault.com/questions/393862/mysql-warning-ip-address-could-not-be-resolved<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGVyY29uYS5jb20vYmxvZy8yMDA4LzA1LzMxL2Rucy1hY2hpbGxlcy1oZWVsLW15c3FsLWluc3RhbGxhdGlvbi8=">https://www.percona.com/blog/2008/05/31/dns-achilles-heel-mysql-installation/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>git修改历史提交中的名称或邮箱地址</title>
    <url>//2021/03/09/git%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E4%B8%AD%E7%9A%84%E5%90%8D%E7%A7%B0%E6%88%96%E9%82%AE%E7%AE%B1%E5%9C%B0%E5%9D%80.html</url>
    <content><![CDATA[<h2 id="如果仅修改前一次的提交"><a href="#如果仅修改前一次的提交" class="headerlink" title="如果仅修改前一次的提交"></a>如果仅修改前一次的提交</h2><p>可以在修改好配置后，使用 <code>git commit --amend</code> 命令重新提交。<br>具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config user.name <span class="string">&quot;新的名称&quot;</span></span><br><span class="line">$ git config user.email <span class="string">&quot;新的邮箱&quot;</span></span><br><span class="line">$ git commit --amend -m <span class="string">&quot;提交信息&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="需要修改历史中的多个提交"><a href="#需要修改历史中的多个提交" class="headerlink" title="需要修改历史中的多个提交"></a>需要修改历史中的多个提交</h2><p>将以下内容复制到一个文件中，如 change-committer.sh。<br>将文件放到要修改的git仓库中，运行 <code>bash change-committer.sh</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git filter-branch --commit-filter <span class="string">&#x27;</span></span><br><span class="line"><span class="string">OLD_EMAIL=&quot;将要被替换的邮箱地址&quot;</span></span><br><span class="line"><span class="string">CORRECT_NAME=&quot;新的名称&quot;</span></span><br><span class="line"><span class="string">CORRECT_EMAIL=&quot;新的邮箱地址&quot;</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">  GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span></span><br><span class="line"><span class="string">  GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span></span><br><span class="line"><span class="string">  GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span></span><br><span class="line"><span class="string">  GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span></span><br><span class="line"><span class="string">  git commit-tree &quot;$@&quot;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">  git commit-tree &quot;$@&quot;</span></span><br><span class="line"><span class="string">fi&#x27;</span> HEAD</span><br></pre></td></tr></table></figure>

<p>根据情况也可以用提交人名称来检索替换，比如用 <code>OLD_NAME=&quot;要替换的名称&quot;</code> 替换 <code>OLD_EMAIL=&quot;将要被替换的邮箱地址&quot;</code> 再用 <code>if [ &quot;$GIT_COMMITTER_NAME&quot; = &quot;$OLD_NAME&quot; ]</code> 替换 <code>if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</code>。</p>
<p>而具体要替换 提交人(committer) 或 作者(author) 或两者都要替换，根据情况来保留下面这部分内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交人</span></span><br><span class="line">GIT_COMMITTER_NAME=<span class="string">&quot;<span class="variable">$CORRECT_NAME</span>&quot;</span></span><br><span class="line">GIT_COMMITTER_EMAIL=<span class="string">&quot;<span class="variable">$CORRECT_EMAIL</span>&quot;</span></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line">GIT_AUTHOR_NAME=<span class="string">&quot;<span class="variable">$CORRECT_NAME</span>&quot;</span></span><br><span class="line">GIT_AUTHOR_EMAIL=<span class="string">&quot;<span class="variable">$CORRECT_EMAIL</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>git历史记录的修改是一个较为危险的操作，尤其是多人协作，还要修改已提交到远程仓库的历史时。<br>重写历史会导致与远程的历史提交冲突，无法再正常提交到远程仓库，只能通过强制覆盖提交。<br>一旦出现问题，他人无法再撤销找回历史。<br>所以一定要慎重再慎重。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab-ci 中的 token</title>
    <url>//2021/01/21/gitlab-ci-%E4%B8%AD%E7%9A%84-token.html</url>
    <content><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>在 <em>个人</em> -&gt; <em>设置</em> -&gt; <em>access token</em> 中创建 <em>CI_TAG_UPLOAD_TOKEN</em>。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建后，再到项目中的 <em>设置</em> -&gt; <em>CI/CD</em> -&gt; <em>secret values</em> 中创建 <em>CI_TAG_UPLOAD_TOKEN</em>，并把值设置为前面生成的值。</p>
<p>在 <em>gitlab-ci.yml</em> 文件的脚本中设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">url_host=`git</span> <span class="string">remote</span> <span class="string">get-url</span> <span class="string">origin</span> <span class="string">|</span> <span class="string">sed</span> <span class="string">-e</span> <span class="string">&quot;s/https:\/\/gitlab-ci-token:.*@//g&quot;</span><span class="string">`</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">origin</span> <span class="string">&quot;https://gitlab-ci-token:$&#123;CI_TAG_UPLOAD_TOKEN&#125;@$&#123;url_host&#125;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + github 快速创建个人博客</title>
    <url>//2017/07/04/hexo-github-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content><![CDATA[<p>使用 hexo + github 快速创建个人博客方法记录。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>安装 Node</li>
<li>安装 Git</li>
<li>申请 GitHub 帐号</li>
</ul>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>
<p>执行如下命令安装 Hexo :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>完成 hexo 的安装后，在创建的文件夹下执行如下命令初始化:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>执行下面的命令，生成静态页面:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate (或者简写成 hexo g)</span><br></pre></td></tr></table></figure>

<p>这样会在 blog 根目录下生成一个 public 的目录，里面就存放着结构目录及静态页面。</p>
<h3 id="本地预览调试"><a href="#本地预览调试" class="headerlink" title="本地预览调试"></a>本地预览调试</h3><p>做完了上面的操作后，一个博客站点基本上就算是完成了，可以启动本地服务，进行预览调试，命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server (或者简写成 hexo s)</span><br></pre></td></tr></table></figure>

<p>如果命令窗口有下面的输出就说明成功了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>这时你可以打开浏览器，在地址栏输入 localhost:4000 查看原始的博客了。</p>
<h2 id="配置-GitHub"><a href="#配置-GitHub" class="headerlink" title="配置 GitHub"></a>配置 GitHub</h2><p>但是这样也只是本地能够查看，换一台电脑就看不到了，如何才能在任意的电脑上都可以通过网络访问呢？这时就需要 GitHub 来配合了。</p>
<p>登录 github ，建立一个仓库，仓库名必须是 <code>&lt;your_username&gt;.github.io</code></p>
<blockquote>
<p>这里建议用户名最好是全部由字母与数字构成，不要使用连字符或下划线等非字母、数字的字符，那样可能会导致浏览 Linux 的用户在访问该站点时将收到服务器错误。 <span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvdXNlci1vcmdhbml6YXRpb24tYW5kLXByb2plY3QtcGFnZXMvI3Byb2plY3QtcGFnZXM=">Git Help 用户,组织和项目页面 Warning<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>打开 blog 根目录下的 _config.yml 文件，翻到最下面更改配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:moesuiga/moesuiga.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>更改的 repo 属性是你建立的 github 仓库的地址，<br>可以是 HTTPS 地址，如:<br><code>https://github.com/moesuiga/moesuiga.github.io.git</code></p>
<p>或者是 SSH 地址，如:<br><code>git@github.com:moesuiga/moesuiga.github.io.git</code></p>
<p>执行命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行部署命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>将本地代码部署到 github 仓库中。</p>
<p>现在你可以在浏览器中输入 <code>https://moesuiga.github.io</code> 进行访问了，记得把 <code>moesuiga</code> 修改为你的 github 用户名。</p>
<h2 id="部署步骤及常用命令"><a href="#部署步骤及常用命令" class="headerlink" title="部署步骤及常用命令"></a>部署步骤及常用命令</h2><p>每次部署，可以按以下三步进行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean (清除缓存，会清除掉本地的 public 目录)</span><br><span class="line">$ hexo generate (生成静态页面)</span><br><span class="line">$ hexo deploy (部署代码到 github 仓库)</span><br></pre></td></tr></table></figure>

<p>以下是一些 hexo 的常用命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;postName&quot;</span> (新建文章)</span><br><span class="line">$ hexo new page <span class="string">&quot;pageName&quot;</span> (新建页面)</span><br><span class="line">$ hexo generate (生成静态页面至 public 目录)</span><br><span class="line">$ hexo server (开启预览访问端口，默认端口号4000，<span class="string">&#x27;ctrl + c&#x27;</span> 关闭 server)</span><br><span class="line">$ hexo deploy (将 .deploy 目录部署到 github)</span><br><span class="line">$ hexo <span class="built_in">help</span> (查看帮助)</span><br><span class="line">$ hexo version (查看 hexo 的版本)</span><br></pre></td></tr></table></figure>

<h2 id="报错总结"><a href="#报错总结" class="headerlink" title="报错总结"></a>报错总结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git 或者 ERROR Deployer not found: github</span><br></pre></td></tr></table></figure>

<p>解决方法： <code>npm install hexo-deployer-git --save</code></p>
<p>如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm-rf.DS_Store</span><br><span class="line">ERROR Plugin load failed: hexo-server</span><br></pre></td></tr></table></figure>

<p>如果运行<code>hexo server</code>后提示可以在4000端口访问，但是访问<code>http://localhost:4000</code>却无法正常打开，有可能是端口被占用或其他什么情况，可以通过添加<code>-p</code>参数更换端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server -p 8888</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客中不蒜子与live2D冲突的解决及其根因查找</title>
    <url>//2022/07/28/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%B8%8D%E8%92%9C%E5%AD%90%E4%B8%8Elive2d%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8F%8A%E5%85%B6%E6%A0%B9%E5%9B%A0%E6%9F%A5%E6%89%BE.html</url>
    <content><![CDATA[<!-- 时隔大半年，再次打开博客，颇有一番感慨。看看曾经写下的一些记录，还能回忆起当时的场景，突然有种记录的冲动，不是作为纯粹的技术博客，而是类似日记的存在，记录生活。 -->

<h2 id="不蒜子统计数据不展示"><a href="#不蒜子统计数据不展示" class="headerlink" title="不蒜子统计数据不展示"></a>不蒜子统计数据不展示</h2><p>很久以前——至少是一年前——我就知道了博客中的「不蒜子」统计功能有些问题，具体原因不记得了，仅仅是记得在哪里看到过，说是和博客主题中使用的另一个什么功能有关。嗯，现在我知道了，是启用了「live2D」导致的。<br>网络上有很多解决方案，我也不想再一个个写出来了，如果你想的话，可以直接滑到最下面的参考链接，去看看别人写的具体修复方法。</p>
<p>如果你除了直接解决之外，还想大概了解一下原因的话，那么不妨继续往下看。</p>
<p>在博客的模板源代码中，不蒜子的统计信息所在的DOM，默认是 <code>display: none</code> 隐藏的，等待不蒜子获取到数据之后，分别查找对应的DOM并填充数据之后，会修改样式为 <code>display: inline</code> 进而展示出来。<br>这就是正常情况下的步骤。<br>那么不正常的情况呢？看一下不蒜子的这段代码吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a(b),</span><br><span class="line">        scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">        bszTag.hides()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的 <code>a(b)</code> 函数调用，其中的参数 <code>b</code> 就是统计数据对象，而函数 <code>a</code> 做的事情就是前面说的填充数据而后展示元素。这一步是没问题的，有问题的是下一段代码 <code>scriptTag.parentElement.removeChild(scriptTag)</code>。在未启用「live2D」时，这段代码正常运行；而启用了「live2D」后，这段代码出现了错误，所以程序进入了错误捕获的代码块 <code>bszTag.hides()</code>，这个方法就是隐藏统计数据所在元素的方法。</p>
<p><img data-src="/images/posts/busuanzi_tag_methods.png" alt="不蒜子的对象方法"></p>
<p>如此看来，你应该也就明白可以如何来修复它了吧。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我查到的修复方式不止一种，但说到底，最终针对的也都是上面提到的错误之处。</p>
<p>有人添加一步判断 <code>scriptTag.parentElement &amp;&amp; scriptTag.parentElement.removeChild(scriptTag)</code>，来确保代码不会出错；<br>另一部分则是去掉统计数据所在元素的容器元素，以 NexT 主题为例，找到 <code>layout/_partials/footer.njk</code> 文件，在文件中找到 <code>&lt;div class=&quot;busuanzi-count&quot;&gt;</code> 标签，把这个标签下的<strong>直接子元素</strong>的 ID <code>busuanzi_container_xxxx</code> 删除，以及 <code>layout/_partials/post/post-meta.njk</code> 文件中 ID 为 <code>busuanzi_container_page_pv</code> 的元素删除该 ID 属性。这一种方案的本质其实就是让 <code>bszTag.hides()</code> 失去效果；从上面的截图可以看到， <code>hides()</code> 方法是通过容器元素的ID来找到DOM并设置隐藏的，找不到对应的容器元素，自然也就无法再将其隐藏了。<br><img data-src="/images/posts/busuanzi_container_id.png" alt="不蒜子容器ID"></p>
<p>那么到这里就结束了……吗？</p>
<h2 id="探究根因"><a href="#探究根因" class="headerlink" title="探究根因"></a>探究根因</h2><p>很显然并没有。刚刚讲了为什么不蒜子统计会被隐藏掉，但是深究一下，上面的那段代码为什么会出现错误？为什么在启用 live2D 之前没有问题，启用了 live2D 之后就出错了呢？</p>
<p>如果仅仅只看不蒜子的代码，完全不会想到它有什么问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bszCaller = &#123;</span><br><span class="line">    fetch: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">&quot;BusuanziCallback_&quot;</span> + <span class="built_in">Math</span>.floor(<span class="number">1099511627776</span> * <span class="built_in">Math</span>.random());</span><br><span class="line">        <span class="built_in">window</span>[c] = <span class="built_in">this</span>.evalCall(b),</span><br><span class="line">        a = a.replace(<span class="string">&quot;=BusuanziCallback&quot;</span>, <span class="string">&quot;=&quot;</span> + c),</span><br><span class="line">        scriptTag = <span class="built_in">document</span>.createElement(<span class="string">&quot;SCRIPT&quot;</span>),</span><br><span class="line">        scriptTag.type = <span class="string">&quot;text/javascript&quot;</span>,</span><br><span class="line">        scriptTag.defer = !<span class="number">0</span>,</span><br><span class="line">        scriptTag.src = a,</span><br><span class="line">        scriptTag.referrerPolicy = <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;HEAD&quot;</span>)[<span class="number">0</span>].appendChild(scriptTag)</span><br><span class="line">    &#125;,</span><br><span class="line">    evalCall: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">            ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    a(b),</span><br><span class="line">                    scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">                    bszTag.hides()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">bszCaller.fetch(<span class="comment">/* busuanzi jsonp fetch url */</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    bszTag.texts(a),</span><br><span class="line">    bszTag.shows()</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>不蒜子创建了一个 <code>&lt;script&gt;</code> 标签，然后添加了请求地址，通过 JSONP 的方式获取到统计数据，在设置完数据后，把添加的这个标签移出DOM。这么看下来，是不是完全没有问题？</p>
<p>既然不蒜子的代码看起来没有问题，而且只有启用「live2D」才出现错误，那么自然也需要查看一下「live2D」的源码了。不过我其实是先找到了可能的原因，而后再从 live2D 的代码中搜索关键词查找出来的，毕竟 live2D 的代码都是压缩后的，我也没有一点点分析的耐心。</p>
<p>我是这么想的，不蒜子出现问题时，错误的源头是 <code>scriptTag.parentElement</code> 为空，也就是说 <code>scriptTag</code> 元素不存在父元素。这一点其实很可疑，甚至一度让我怀疑人生：明明前面刚把它添加到 <code>&lt;head&gt;</code> 元素里面，现在你告诉我说，它没有父元素了？</p>
<p>经过了一段时间的自我怀疑、代码检查、debug之后，我终于发现了问题所在：在代码执行到 <code>scriptTag.parentElement.removeChild(scriptTag)</code> 这一句时，<code>scriptTag</code> 与 <code>&lt;head&gt;</code> 里面那个之前创建的 <code>&lt;script&gt;</code> 标签已经不是同一个 DOM 对象了！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scriptTag = <span class="built_in">document</span>.createElement(<span class="string">&quot;SCRIPT&quot;</span>),</span><br><span class="line"><span class="comment">// 创建时增加 ID 属性</span></span><br><span class="line">scriptTag.id = <span class="string">&#x27;BusuanziScriptTag&#x27;</span>,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除代码之前，检查一下是不是同一个 DOM</span></span><br><span class="line"><span class="built_in">console</span>.debug(scriptTag === <span class="built_in">document</span>.head.getElementById(<span class="string">&#x27;BusuanziScriptTag&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line">scriptTag.parentElement.removeChild(scriptTag)</span><br></pre></td></tr></table></figure>

<p>是不是很不可思议？但是结果就是这样，明明应该是同一个元素的，为什么会不一样呢？是什么原因改变了它？<br>我能想到的答案就是，<code>&lt;head&gt;</code> 元素的内容被重写了。被谁、如何重写的？答案是 <code>innerHTML</code> 属性。<br>是的，就是它，<code>innerHTML</code>，这个属性返回 DOM 元素内的 HTML 标签字符串文本，也可以把一段 HTML 字符串添加到 DOM 元素中解析为它的子元素。</p>
<p>而现在，我知道了它的另一个特性，被 <code>innerHTML</code> 重写过的内容，其子元素会产生一个新的 DOM 对象。</p>
<p>于是，找到了问题可能的答案，我就在 live2d-widget 这个包的代码中搜索了 <code>innerHTML</code> 这个关键词，然后找到了一段代码：<br><img data-src="/images/posts/live2d_head_innerHTML.png" alt="live2d使用innerHTML在head中添加样式"></p>
<p>于是疑惑终于解除了，我们也都学习到了新的知识点，<code>innerHTML</code> 属性的修改会产生新的 DOM 对象，并导致原本的 DOM 对象被移除无效化。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJkL2lzc3Vlcy8xNjE=">关于和不蒜子计数冲突的问题<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tb2d1YW5ncGVuZzk5OC5naXRodWIuaW8vMjAyMC8wNi8xMy9IZXhvJUU1JThEJTlBJUU1JUFFJUEyJUU0JUI4JThEJUU4JTkyJTlDJUU1JUFEJTkwJUU1JTkyJThDbGl2ZTJkJUU3JTlDJThCJUU2JTlEJUJGJUU1JUE4JTk4JUU1JTg2JUIyJUU3JUFBJTgxJUU5JTk3JUFFJUU5JUEyJTk4JUU4JUE3JUEzJUU1JTg2JUIzJUU2JTk2JUI5JUU2JUExJTg4Lw==">Hexo博客不蒜子和live2d看板娘冲突问题解决方案<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hcnRpY2xlcy5veW91bmcuY2MvMjAxOS8xMC8zMC9idXN1YW56aS8=">解决不蒜子(busuanzi)不显示数字问题记录<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tdXl1dXV1LmdpdGh1Yi5pby8yMDE5LzExLzIyL2J1c3VhbnppLW5vdGRpc3BsYXkv">修补hexo-next不蒜子不显示问题<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qb3NoLWdhby50b3AvcG9zdHMvZTk2YzliMjYuaHRtbA==">Hexo NexT 主题不蒜子相关问题汇总<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的常见错误</title>
    <url>//2020/12/07/javascript%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>鉴于一部分新人不懂得如何根据 JavaScript 中的报错信息来查找错误，本文列举了一些在 JavaScript 中比较常见的错误信息模式，并附上讲解。</p>
<p>希望能帮助新人在 JavaScript 查错方面的能力上有所提升。</p>
<blockquote>
<p><strong>提示：</strong><br>编程并不要求英语能力必须要达到四级、六级甚至更高，但是语言中的关键字以及一些特殊的名称等还是要掌握的。<br>即使真的英语能力完全不行，但是现在有很多工具可以帮助你。<br>比如：网易词典、百度/谷歌翻译……<br>希望大家能善用此类工具，帮助自己。</p>
</blockquote>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="错误的分类"><a href="#错误的分类" class="headerlink" title="错误的分类"></a>错误的分类</h3><p>在 JavaScript 中，常见的错误类型有： <code>SyntaxError</code>（语法错误）, <code>TypeError</code>（类型错误）, <code>ReferenceError</code>（引用错误）, <code>RangeError</code>（范围错误） 等。</p>
<p>每个错误信息的提示，开头都是一个未捕获的错误类型，先给出了这是一个什么类型的错误，后续才是这个错误的具体信息。</p>
<p>比如：<code>Uncaught ReferenceError: a is not defined</code>，这就是一个引用错误，说明在使用变量 a 的时候，发现并没有任何声明为 a 的变量。</p>
<p>有时你也会看到没有特别标明错误类型的错误信息，比如: <code>Uncaught Error: this is a test error.</code>。</p>
<p>这种错误通常是由开发者自身的代码抛出的未标明具体类型的错误。具体错误原因就需要通过后面的错误信息来分析了。</p>
<h3 id="错误的位置"><a href="#错误的位置" class="headerlink" title="错误的位置"></a>错误的位置</h3><p>每个未捕获的错误还会有一个错误的执行堆栈顺序以及代码位置信息。</p>
<p>这些信息会在错误信息的下一行出现，以 <em>at</em> 开头，表明所处位置在哪里。</p>
<p>比如上面提到的错误，实际的完整提示如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">ReferenceError</span>: a is not defined</span><br><span class="line">at &lt;anonymouse&gt;:<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>说明该引用错误是在一个匿名【无法追踪到具体环境名称/或者就是一个匿名函数】执行的代码第一行第一列处。</p>
<p>实际上，我就是在浏览器的控制台中直接输出的。</p>
<h3 id="语法错误-SyntaxError"><a href="#语法错误-SyntaxError" class="headerlink" title="语法错误 SyntaxError"></a>语法错误 SyntaxError</h3><p>首先明确一下，什么是语法错误？</p>
<p>每一种编程语言都有它的特定语法要求，这是一种规定，必须强制的按照语言的语法来书写代码，否则语言的编译器是会无法识别的；</p>
<p>这种违反了语言的语法来书写出的代码，就属于 语法错误 。</p>
<p>在 JavaScript 中，语法错误会直接导致整个环境的代码完全不执行；</p>
<p>是最重大的错误，同时也是最容易检查出来的错误，只需要随便有一个静态语法检测工具即可检测出来。</p>
<p>错误示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">lett a = <span class="number">1</span>; <span class="comment">// Uncaught SyntaxError: unexpected identifier</span></span><br><span class="line"><span class="comment">// 本来是想声明一个变量 a 并赋值为 1</span></span><br><span class="line"><span class="comment">// 但是因为错误的书写了 let 关键字，出现了语法错误</span></span><br></pre></td></tr></table></figure>

<h3 id="类型错误-TypeError"><a href="#类型错误-TypeError" class="headerlink" title="类型错误 TypeError"></a>类型错误 TypeError</h3><p>这个错误应该是大多数人经常会看到的，尤其是某个特定的错误信息。</p>
<p><code>Uncaught TypeError: cannot read property &#39;XXX&#39; of undefined</code>（或者是 <code>null</code>）</p>
<p>怎么样？这个格式的错误信息，是不是很熟悉？<br>如果你还不懂它到底是什么意思，那么请牢记以下内容。<br>TypeError 通常用于错误的使用一个 JavaScript 的数据类型。<br>比如一个变量原本是数字，却被开发者误以为是字符串，并调用了一个字符串的方法【比如 split】，<br>因为数字是没有这个方法的，所以调用就会出现一个类型错误 TypeError。</p>
<p>那么上面的这个错误信息的解释就是：<br>在读取属性 <code>XXX</code> 时，发现读取该属性的那个数据是 <code>undefined</code> （或者是 <code>null</code>）。</p>
<p>我们都知道，在 JavaScript 中，<code>undefined</code> 和 <code>null</code> 都是没有任何属性与方法的，那么把它们认为是一个对象去读取属性时，自然就是错误的。</p>
<p>像这样的类型错误，<br>要么是开发者没有做好数据的类型判断、空值判断，导致了意外类型数据的异常调用；<br>要么就是开发者马虎，使用了错误的数据去读取属性或调用方法。</p>
<p>类似的错误信息还有很多种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span>: <span class="literal">null</span> is not an object. <span class="comment">// 这个跟上面那个属于同一种情况，只是在一些不同的环境下的不同错误信息</span></span><br><span class="line"></span><br><span class="line">Uncaught <span class="built_in">TypeError</span>: obj.fn is not a <span class="keyword">function</span>. <span class="comment">// 这个通常是调用了一个不存在的方法出现的错误。可能是忘记了添加方法，也可能是 obj 本身就不是开发者期望中的那个数据</span></span><br><span class="line"></span><br><span class="line">Uncaught <span class="built_in">TypeError</span>: fn is not a <span class="keyword">function</span>. <span class="comment">// 这个类似于上一条 obj.fn，不同的地方在于这里是单独调用 fn，但 fn 实际上并不是一个函数。</span></span><br></pre></td></tr></table></figure>

<p>要防止这种错误的发生，要怎么做呢？</p>
<p>在使用一个变量、调用一个函数或者访问对象属性时，多考虑考虑它是否可能是其他类型的值，或者是否有可能为空。<br>多做几个类型判断或者非空判断来尽量避免。</p>
<h4 id="非空判断引申"><a href="#非空判断引申" class="headerlink" title="非空判断引申"></a>非空判断引申</h4><p>在做空值判断时，一定要考虑清楚几个特殊的值在实际场景下要归于哪一种情况。<br>这几个特殊的值分别是：布尔值的 <code>false</code>，空字符 <code>&#39;&#39;</code>，数字 <code>0</code> 和 <code>NaN</code>。<br>因为大多数时候，我们去除空值判断时，是采用的取反操作或直接判断是否为真，而上述几个值虽然并非 null 和 undefined，但本身直接转为布尔值都是假值；取反之后，都是真值。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;n有值&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;n没有值&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子可能会有超出预期的情况，如果数字为 <em>0</em> 需要被认为有值的话，应该再加上一个判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n || n === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;n有值&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;n没有值&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用错误-ReferenceError"><a href="#引用错误-ReferenceError" class="headerlink" title="引用错误 ReferenceError"></a>引用错误 ReferenceError</h3><p>就像最开始解释错误分类时提出的错误示例那样， <code>ReferenceError</code> 就是变量的错误引用所抛出的错误类型。<br>这通常发生在变量未声明时就被使用的情况下。</p>
<p>比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道 ES6 中引入的 <code>let</code> 关键字并不会像 <code>var</code> 那样有变量的声明提升。<br>在 <code>let</code> 声明之前就使用 a，会造成一个暂时性死区的问题，具体关于暂时性死区的情况这里不做详谈，这里要讲的是引用错误 ReferenceError。<br>因为在 <code>let</code> 声明之前，还没有变量 a，所以在访问变量 a 时，编译器就无法找到这个变量对应的引用值，如此导致的就是一个 ReferenceError，即引用错误。</p>
<p>要避免这种错误，就需要注意，每个变量的使用，都要放在声明的后面。</p>
<p>可以通过把变量的声明都放在代码块的一开始来规避。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 TextEncoder 获取字符串的字节数</title>
    <url>//2020/05/12/%E4%BD%BF%E7%94%A8-textencoder-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0.html</url>
    <content><![CDATA[<p>之前有同事因为一段文本超出规定字节数，询问过我，怎么知道一段文字有多少个字节。<br>当时只是简单的回他一般英文与数字每个字符占一个字节，而中文字符占多少个字节需要根据字符编码来判断。比如中国的GBK/GB2312/GB18030等，一个中文字符就是两个字节；而现在主流的编码方式UTF-8中，一个中文字符则是三个字节。</p>
<a id="more"></a>

<h2 id="TextEncoder"><a href="#TextEncoder" class="headerlink" title="TextEncoder"></a>TextEncoder</h2><p>后来无意中在 MDN 里看到这么一个方法，可以将一段文本字符生成采用UTF-8编码的字节流（它还有一个作用相反的配套方法 TextDecoder）。如此很简单的一个查询字符串字节数的方法就出来了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"><span class="keyword">const</span> view = encoder.encode(<span class="string">&#x27;一&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view); <span class="comment">// Uint8Array(3) [228, 184, 128]</span></span><br><span class="line"><span class="built_in">console</span>.log(view.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原本 TextEncoder 还应该有一个参数 encoding，可以指定编码，但是因为标准规定 encoding 始终返回 “utf-8”，所以只能获取到UTF-8编码下的字符串的字节数。<br>不过 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2luZXhvcmFibGV0YXNoL3RleHQtZW5jb2Rpbmc=">GitHub<i class="fa fa-external-link-alt"></i></span> 上倒是有一个polyfill支持非utf-8的编码。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enc = <span class="keyword">new</span> TextEncoder(<span class="string">&#x27;gbk&#x27;</span>);</span><br><span class="line">enc.encoding; <span class="comment">// utf-8</span></span><br><span class="line">enc.encoding = <span class="string">&#x27;gbk&#x27;</span>;</span><br><span class="line">enc.encoding; <span class="comment">// utf-8</span></span><br></pre></td></tr></table></figure>

<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><h3 id="String-property-codePointAt-String-fromCodePoint"><a href="#String-property-codePointAt-String-fromCodePoint" class="headerlink" title="String.property.codePointAt/String.fromCodePoint"></a>String.property.codePointAt/String.fromCodePoint</h3><p>随着查询字符编码，还让我了解了一个字符串的方法 <code>String.property.codePointAt</code>。</p>
<p>这个方法的作用类似于 <code>String.property.charCodeAt</code>，都是返回字符串某一位置的字符代码点的值，用法也和 <code>String.property.charCodeAt</code> 一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;笑一笑😀&#x27;</span>;</span><br><span class="line">str.charCodeAt(<span class="number">0</span>);  <span class="comment">// 31505</span></span><br><span class="line">str.codePointAt(<span class="number">0</span>); <span class="comment">// 31505</span></span><br></pre></td></tr></table></figure>

<p>那么它们的区别是什么？这里就要说到<em>四字节</em>的字符了。</p>
<p>我们平时使用的Unicode编码字符，都是 U+0000 - U+FFFF 来标识的。而 U+FFFF 则是三字节能表示的最大字符数了，那么四字节要怎么标识呢？答案是用两个Unicode字符来标识，比如上面的笑脸emoji😀，它的Unicode编码其实是 <code>\ud83d\ude00</code>，而且其长度为2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;😀&#x27;</span>.length === <span class="number">2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>像这样用两个Unicode字符来标识的四字节字符，是无法使用 <code>String.property.charCodeAt</code> 来获取其完整代码点的，该方法只能获取到一个Unicode代码单元的代码点，即<code>String.property.charCodeAt</code>只能获取一个长度的Unicode的字符代码点。<br>而要获取这种四字节字符的完整代码点，则要使用 <code>String.property.codePointAt</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;笑一笑😀&#x27;</span>;</span><br><span class="line">str.charCodeAt(<span class="number">3</span>);  <span class="comment">// 55357 =&gt; 其实就是 &#x27;\ud83d&#x27; 的代码点</span></span><br><span class="line">str.codePointAt(<span class="number">3</span>); <span class="comment">// 128512</span></span><br></pre></td></tr></table></figure>

<p>就如同 <code>String.property.charCodeAt</code> 有一个对应的方法 <code>String.fromCharCode</code>，<code>String.property.codePointAt</code> 也有一个对应的从代码点得到对应字符的方法 <code>String.fromCodePoint</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">128512</span>); <span class="comment">// 😀</span></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRFbmNvZGVy">TextEncoder<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHREZWNvZGVy">TextDecoder<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0">String.property.codePointAt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NoYXJDb2RlQXQ=">String.property.charCodeAt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb21pbmd5YW5nL2FydGljbGUvZGV0YWlscy83OTM3NDIwOQ==">中文汉字占二个字节还是三个字节长度<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>console in web</title>
    <url>//2018/01/07/console-in-web.html</url>
    <content><![CDATA[<p>一般我们要在控制台输出一些信息的时候，大多数情况都只是使用 <code>console.log</code> 来输出。但是，你知道吗？其实 <code>console</code> 还有很多其他的方法。</p>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>在控制台打印内容，一般的用法——也是我们常用的用法——就是<code>console.log(info[,info,...])</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;c.c.&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;I like &#x27;</span>, name);</span><br><span class="line"><span class="comment">// =&gt; I like c.c.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="debug-info"><a href="#debug-info" class="headerlink" title="debug/info"></a>debug/info</h2><p><code>info</code> 是 <code>log</code> 的别名，在某些地方见有人说过 <code>console.info</code> 会在输出的文本前加上一个小三角标示，但我在浏览器控制台实测并没有小三角标示。</p>
<p><code>debug</code> 也类似 <code>log</code>，不同的是在分级上 <code>debug</code> 属于调试信息，一般在控制台会被过滤掉，需要在控制台选中 <code>Verbose</code> 来查看。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&#x27;Without a date&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.debug(<span class="string">&#x27;debug: %s&#x27;</span>, text);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">&#x27;info: %s&#x27;</span>, text);</span><br></pre></td></tr></table></figure>

<h2 id="warn-error"><a href="#warn-error" class="headerlink" title="warn/error"></a>warn/error</h2><p><code>warn</code> 在控制台输出一条带有 “警告” 图标的消息和一个指向该代码调用的追溯引用信息，文字与背景颜色为黄色。<br><code>error</code> 在控制台输出一条带有“错误”图标的消息和一个指向该代码调用的追溯引用信息，文字与背景颜色为红色。</p>
<p><code>warn</code>, <code>error</code> 除了上面的说明外，还有一个输出级别的区分，我们可以通过不同的条件来过滤，只查看 <code>warn</code> 级别或者 <code>error</code> 级别的输出信息。这在一些具有较多输出日志的情况下，能更快速的找到自己需要的一些信息。</p>
<h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>在控制台输出该代码调用的追溯引用信息。</p>
<p>实际项目中，一个函数可能在多个地方有调用，还有多个函数嵌套。<br>有时候想要知道这个函数在某时刻具体是在哪个函数调用的，就可以通过追溯找到嵌套的调用函数路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace(<span class="string">&#x27;追溯调用位置&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<h2 id="time-timeLog-timeEnd"><a href="#time-timeLog-timeEnd" class="headerlink" title="time/timeLog/timeEnd"></a>time/timeLog/timeEnd</h2><p>想知道某段代码的运行时间？你还在用下面这种方式吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="comment">// ... codes</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;cost: &#x27;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start);</span><br></pre></td></tr></table></figure>

<p>快来试试 <code>console.time/console.timeEnd</code> 组合吧。</p>
<p><code>console.time(label)</code> 创建一个索引为 <code>label</code> 的计时器，<br><code>console.timeLog(label)</code> 输出索引为 <code>label</code> 的计时器经历的时间，<br><code>console.timeEnd(label)</code> 停止索引为 <code>label</code> 的计时器，并输出从创建到停止所耗的时间（毫秒）。常用来查看代码运行的效率性能。</p>
<blockquote>
<p>使用 <code>timeLog/timeEnd</code> 时，必须有一个通过 <code>time</code> 创建了的定时器。<br>如果没有创建或 label 参数错误无法找到创建的定时器，会输出一个警告 <code>Timer &#39;default(or input label)&#39; does not exist</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;Sum&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> end = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">  <span class="keyword">if</span> (i === end / <span class="number">2</span>) <span class="built_in">console</span>.timeLog(<span class="string">&#x27;Sum&#x27;</span>); <span class="comment">// =&gt; Sum: 0.06396484375ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1~1000之和: &#x27;</span>, sum); <span class="comment">// =&gt; 1~1000之和:  499500</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;Sum&#x27;</span>); <span class="comment">// =&gt; Sum: 0.26708984375ms</span></span><br></pre></td></tr></table></figure>

<h2 id="group-groupEnd-groupCollapsed"><a href="#group-groupEnd-groupCollapsed" class="headerlink" title="group/groupEnd/groupCollapsed"></a>group/groupEnd/groupCollapsed</h2><p><code>group</code>方法输出一条消息，并打开一个分组的嵌套块，块中的内容都会缩进，调用<code>console.groupEnd()</code>关闭嵌套块。<br><code>groupCollapsed</code> 方法与 <code>group</code> 方法一样，唯一的区别是该组的内容，在第一次显示时是收起而非展开的。</p>
<p>通过这个方法，我们可以很清楚的了解到代码的运行顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">&#x27;group demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;program start ...&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.groupCollapsed(<span class="string">&#x27;loop&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.groupEnd();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;program end ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>

<h2 id="profile-profileEnd"><a href="#profile-profileEnd" class="headerlink" title="profile/profileEnd"></a>profile/profileEnd</h2><p><code>console.profile([title])</code> 打开JavaScript性能测试开关，可选参数title会在打印性能测试报告时在报告的开头输出。这两个 API 尚未标准化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doTaskA(<span class="number">1000</span>);</span><br><span class="line">  doTaskA(<span class="number">100000</span>);</span><br><span class="line">  doTaskB(<span class="number">10000</span>);</span><br><span class="line">  doTaskC(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTaskA</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; count; i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTaskB</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; count; i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTaskC</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; count; i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.profile(<span class="string">&#x27;testTitle&#x27;</span>);</span><br><span class="line">doTask();</span><br><span class="line"><span class="built_in">console</span>.profileEnd(<span class="string">&#x27;testTitle&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>对于某些复合类型的数据，<code>console.table(object)</code>方法可以将其转为表格显示。条件是必须拥有主键。<br>对于数组来说，主键就是数字键；对于对象来说，主键就是它的最外层键。</p>
<p>表格可以用于数据统计，如果要查看一个结构相同或类似的列表时，就可以使用 <code>console.table</code> 。另外 <code>console.table</code> 还可以根据第二个参数，来过滤要展示的属性列表，在 Chrome 浏览器中还能够点击第一行的索引来重新排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123;</span><br><span class="line">  name: <span class="string">&#x27;RWBY&#x27;</span>,</span><br><span class="line">  year: <span class="number">2013</span>,</span><br><span class="line">  series: <span class="number">6</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: <span class="string">&#x27;OVERLORD&#x27;</span>,</span><br><span class="line">  year: <span class="number">2015</span>,</span><br><span class="line">  series: <span class="number">3</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: <span class="string">&#x27;狐妖小红娘&#x27;</span>,</span><br><span class="line">  year: <span class="number">2015</span>,</span><br><span class="line">  series: <span class="number">5</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: <span class="string">&#x27;JOJO&#x27;</span>,</span><br><span class="line">  year: <span class="number">2012</span>,</span><br><span class="line">  series: <span class="number">6</span>,</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">console</span>.table(arr);</span><br><span class="line"><span class="built_in">console</span>.table(arr, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;year&#x27;</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -----------------------------------------</span></span><br><span class="line"><span class="comment">    | (index) | name       | year | series  |</span></span><br><span class="line"><span class="comment">    |---------------------------------------|</span></span><br><span class="line"><span class="comment">    | 0      | &quot;RWBY&quot;      | 2013 | 6       |</span></span><br><span class="line"><span class="comment">    | 1      | &quot;OVERLORD&quot;  | 2015 | 3       |</span></span><br><span class="line"><span class="comment">    | 2      | &quot;狐妖小红娘&quot; | 2015 | 5       |</span></span><br><span class="line"><span class="comment">    | 3      | &quot;JOJO&quot;      | 2012 | 6       |</span></span><br><span class="line"><span class="comment">    ----------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="count-countReset"><a href="#count-countReset" class="headerlink" title="count/countReset"></a>count/countReset</h2><p><code>count</code> 计数器，输出它被调用了多少次，有一个可选参数，会在显示计数时在开头输出，并用于区分不同的计数器。</p>
<p><code>countReset</code> 重置 <code>count</code> 计数器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">&#x27;odd&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">&#x27;even&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.countReset(<span class="string">&#x27;odd&#x27;</span>); <span class="comment">// in FireFox =&gt; odd: 0  in Chrome: no output</span></span><br><span class="line"><span class="built_in">console</span>.countReset(<span class="string">&#x27;even&#x27;</span>); <span class="comment">// in FireFox =&gt; even: 0  in Chrome: no output</span></span><br></pre></td></tr></table></figure>

<h2 id="dir-dirxml"><a href="#dir-dirxml" class="headerlink" title="dir/dirxml"></a>dir/dirxml</h2><p><code>dir</code> 方法用于显示指定对象的属性，并以易于阅读的格式——类似文件树样式的交互列表——显示，该方法对于输出DOM对象非常有用。(在 FireFox 中会直接展开)<br><code>dirxml</code> 方法主要用于显示一个明确的 XML/HTML 元素的 DOM 节点对象，可以让你看到该节点的所有子节点内容。如果参数不是 DOM 节点，而是普通的JavaScript对象，<code>console.dirxml</code> 等同于 <code>console.dir</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;header&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.dirxml(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;header&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p><code>assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序的执行。这样就相当于提示用户，内部状态不正确。</p>
<p>它接收两个参数，第一个是表达式，第二个是字符串。只有当第一个参数为<code>false</code>时，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> &gt; <span class="number">2</span>, <span class="string">&#x27;判断错误&#x27;</span>);</span><br><span class="line"><span class="comment">//=&gt; Assertion failed: 判断错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;判断错误&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>console.assert()</code>方法在 Node.js 中的实现和浏览器中可用的 <code>console.assert()</code> 方法实现是不同的。<br>在<strong>浏览器</strong>中当 <code>console.assert()</code> 方法接受到一个值为假断言（assertion）的时候，会向控制台输出传入的内容，但是<strong>并不会中断代码的执行</strong>，而在 <strong>Node.js v10.0.0</strong> 之前，一个值为假的断言也将<strong>会导致一个AssertionError被抛出，使得代码执行被打断</strong>。<br>v10.0.0修复了此差异，所以现在console.assert()在node和浏览器中执行行为相同。<br>引自: <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NvbnNvbGUvYXNzZXJ0">MDN-Console.assert<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>一个可以查看 JS 堆栈内存使用情况的对象，Chrome 浏览器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.momery;</span><br><span class="line"><span class="comment">// MemoryInfo&#123;totalJSHeapSize: 35100000, usedJSHeapSize: 29400000, jsHeapSizeLimit: 1136000000&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>clear方法用于清除当前控制台的所有输出，将光标回置到第一行。</p>
<h2 id="console-的其他小知识"><a href="#console-的其他小知识" class="headerlink" title="console 的其他小知识"></a>console 的其他小知识</h2><h3 id="打印对象"><a href="#打印对象" class="headerlink" title="打印对象"></a>打印对象</h3><p>以前遇到过好些人问，用 <code>console.log</code> 去调试的时候，打印一个对象，查看发现某个属性明明是有值的，可是代码运行却是按照无值来运行的。这是怎么回事？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yakumo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Yukari&#x27;</span>,</span><br><span class="line">  age: <span class="literal">Infinity</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(yakumo); <span class="comment">// You think: &#123; name: &#x27;Yukari&#x27;, age: Infinity &#125;, in fact: ??</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (yakumo.age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;before changed&#x27;</span>); <span class="comment">// this will be output</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after changed&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 👁👁 Spell Card: 年长与年轻的境界 😏</span></span><br><span class="line">yakumo.age = <span class="number">17</span>;</span><br></pre></td></tr></table></figure>

<p>把上面的代码复制，放到浏览器的控制台中运行一遍，你可能会说：我这边输出的是 <code>&#123; name: &#39;Yukari&#39;, age: Infinity &#125;</code> 啊。<br>但是接下来，点击一下对象左侧的三角，展开对象，你会发现该对象 <code>age</code> 的值成了 <code>17</code>。</p>
<p>其实 <code>console.log</code> 打印出来的对象并非该对象的当时值(深拷贝)，打印出来的其实是对象的一个地址引用。<br>在展开对象之前以文本形式展示出来的，是对象被打印时刻的状态转成字符串的输出。<br>当你<strong>第一次</strong>展开对象时，会获取到最新的对象属性进行查看，之后关闭再展开时，则固定成了第一次的属性了（排除使用 getter 或类似的属性）。<br>我们都知道代码运行时很快的，所以当你在控制台上看到这个被打印出来的对象时，这个对象内的一些属性也许早已在某些地方被改变了。</p>
<h3 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h3><p><code>console.log</code> 第一个参数中还支持 <code>printf</code> 的占位符哦，后续参数根据位置对应填入占位符的位置输出。</p>
<p>支持的格式化占位符列表：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%d, %i</td>
<td>整型（暂不支持数字型字符串）</td>
</tr>
<tr>
<td>%f</td>
<td>浮点型（暂不支持数字型字符串）</td>
</tr>
<tr>
<td>%o, %O</td>
<td>链接对象</td>
</tr>
<tr>
<td>%c</td>
<td>CSS格式字符串</td>
</tr>
</tbody></table>
<p><code>%s</code> 是字符串的占位符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%s placeholder&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>); <span class="comment">// =&gt; hello placeholder</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%s&#x27;</span>, &#123;&#125;); <span class="comment">// Chrome =&gt; Object</span></span><br><span class="line"><span class="comment">// FireFox =&gt; [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%s&#x27;</span>, []); <span class="comment">// Chrome =&gt; Array(0)</span></span><br><span class="line"><span class="comment">// FireFox =&gt; &lt;null character&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>%d</code>、<code>%i</code>、<code>%f</code>, 虽然在 JS 中不区分整型与浮点型，只有 <code>Number</code>。但是在占位符中，<code>%d</code> 与 <code>%i</code> 只会输出整数部分，而 <code>%f</code> 则能输出浮点数。如果对应占位符的参数不是 <code>Number</code> 类型，则会输出 <code>NaN</code>。</p>
<blockquote>
<p>在 Chrome 中的表现：<code>%d</code>,<code>%i</code>,<code>%f</code> 只能作为 <code>Number</code> 的占位符，即使是数字型的字符串(e.g. “123”) 也会输出成 NaN<br>在 FireFox 中可以输出 numeric 的字符串，如果是不能转成数字的字符串，则会输出 0，另 <code>%f</code> 固定会输出一个 6 位小数位的浮点数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2 = %d&#x27;</span>, <span class="number">1</span> + <span class="number">2</span>); <span class="comment">// =&gt; 1 + 2 = 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2 = %f&#x27;</span>, <span class="number">1</span> + <span class="number">2</span>); <span class="comment">// Chrome =&gt; 1 + 2 = 3</span></span><br><span class="line"><span class="comment">// FireFox =&gt; 1 + 2 = 3.000000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.1 + 0.2 = %f&#x27;</span>, <span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// Chrome =&gt; 0.1 + 0.2 = 0.30000000000000004</span></span><br><span class="line"><span class="comment">// FireFox =&gt; 0.1 + 0.2 =  0.300000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1.2 + 1.3 &gt; %i&#x27;</span>, <span class="number">1.2</span> + <span class="number">1.3</span>); <span class="comment">// =&gt; 1.2 + 1.3 &gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;numeric will be %d&#x27;</span>, <span class="string">&#x27;123&#x27;</span>); <span class="comment">// Chrome =&gt; numeric will be NaN</span></span><br><span class="line"><span class="comment">// FireFox =&gt; numeric will be 123</span></span><br></pre></td></tr></table></figure>

<p><code>%o</code>, <code>%O</code> 都是对象的占位符。</p>
<p>在 FireFox 浏览器中表现相同，在 Chrome 浏览器中的表现则不同。</p>
<p>Chrome 中的不同之处在于：<code>%o</code> 是对象引用，会直接将对象内的属性展示出来，对于 DOM 节点对象则是展示类似 Element 的节点；而 <code>%O</code> 则是折叠起来的对象，在不点击展开的情况下，无法看到对象内的属性，对于 DOM 节点对象也是如此。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in Chrome</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%o&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>&#125;); <span class="comment">// =&gt; &#123;name: &#x27;obj&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%O&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>&#125;); <span class="comment">// =&gt; Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%o&#x27;</span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;header&#x27;</span>)); <span class="comment">// =&gt; &lt;header id=&quot;header&quot;&gt;...&lt;/header&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%O&#x27;</span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;header&#x27;</span>)); <span class="comment">// =&gt; header#header&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的情况不清楚是怎么回事，有兴趣的可以深入研究一下</span></span><br><span class="line"><span class="comment">// 后面的圆括号备注的类型，是根据 Chrome 的输出颜色得出的判断，也不一定准确</span></span><br><span class="line"><span class="comment">// 欢迎有了解的人解惑</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%d&#x27;</span>, <span class="number">123</span>); <span class="comment">// =&gt; 123 (string)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%o&#x27;</span>, <span class="number">123</span>); <span class="comment">// =&gt; 123 (number)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%O&#x27;</span>, <span class="number">123</span>); <span class="comment">// =&gt; 123 (string)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%s&#x27;</span>, <span class="string">&#x27;string&#x27;</span>); <span class="comment">// =&gt; string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%o&#x27;</span>, <span class="string">&#x27;string&#x27;</span>); <span class="comment">// =&gt; &quot;string&quot; (注意这里的双引号是输出的)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%O&#x27;</span>, <span class="string">&#x27;string&#x27;</span>); <span class="comment">// =&gt; string</span></span><br></pre></td></tr></table></figure>

<p><code>%c</code> 是 CSS 格式字符串的占位符。可以通过 <code>%c</code> 占位符给输出的文本添加一些样式，比如更大的字号、更醒目的颜色、添加背景色等，使得输出更加醒目。</p>
<p>因为每个浏览器的具体实现不同，更多的 CSS 效果可以自己动手试试看。</p>
<blockquote>
<p>每个输出默认是 <code>inline</code> 盒子，且无法使用 <code>display</code> 转换成 <code>block</code>。<br>也因此，<code>width</code>, <code>height</code> 属性无效，但可以通过 <code>line-height</code> 来撑起高度。<br><code>padding/margin</code> 的 <code>top</code>/<code>bottom</code> 在 FireFox 下没有效果，但 <code>left</code> 与 <code>right</code> 有效<br><code>-webkit-background-clip: text;</code> 在 FireFox 中有效，但在 Chrome 中无效<br>… 还有其他很多属性等你探索</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%cRainbowGirl&#x27;</span>, <span class="string">&#x27;font-size: 40px; line-height: 60px; padding: 0 10px; color: #fff; background: linear-gradient(90deg, red 0%, orange 15%, yellow 45%, green 60%, cyan 75%, blue 90%, purple 100%)&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%c3D TEXT&#x27;</span>, <span class="string">&#x27;padding: 20px; background: #fff; color: #000; font-size: 50px; font-weight: bold; text-shadow: 1px 1px #999, 3px 3px #666;&#x27;</span>);</span><br><span class="line"><span class="comment">// FireFox</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%cRainbowGirl&#x27;</span>, <span class="string">&#x27;font-size: 40px; line-height: 60px; padding: 0 10px; color: transparent; background: linear-gradient(90deg, red 0%, orange 15%, yellow 45%, green 60%, cyan 75%, blue 90%, purple 100%);-webkit-background-clip: text;text-fill-color:transparent;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="console-中的-await"><a href="#console-中的-await" class="headerlink" title="console 中的 await"></a>console 中的 await</h3><p>我们知道在 ES2017 中新增了 <code>async/await</code> 两个关键字，用于更方便的异步操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">123</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">console</span>.log(n));</span><br></pre></td></tr></table></figure>

<p><code>async/await</code> 是成对使用的。<code>await</code> 只能使用在 <code>async</code> 声明的异步函数中。</p>
<p>但是，浏览器中的 <code>console</code> 对象下的方法内其实也可以使用 <code>await</code>，不过这种用法只能用于直接在控制台中调试时。</p>
<p>如果用在 script 脚本中的话，会报语法错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in browser console</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(), <span class="number">1000</span>)).then(<span class="function">() =&gt;</span> <span class="number">123</span>)); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- in web script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(), <span class="number">1000</span>)).then(<span class="function">() =&gt;</span> <span class="number">123</span>)); <span class="comment">// Syntax Error</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<!-- console demo script -->
<script>
(function () {
  // log
  var name = 'c.c.';
  console.log('I like ', name);

  // debug info
  var text = 'Without a date';
  console.debug('debug: %s', text);
  console.info('info: %s', text);

  // warn error
  var loser = '人生的败犬';
  console.warn('I am really a ', loser);
  var error = '注孤生';
  console.error('%cMy Error: %c%s', 'color: purple;', 'color: black; font: 700 22px "方正舒体", "华文行楷", simsun;', error);

  // trace
  function fn1() {
    function fn2() {
      console.trace('追溯调用位置');
    }
    fn2();
  }
  fn1();

  // time timeEnd
  console.time('Sum');
  var sum = 0;
  var end = 1000;
  for (var i = 1; i < end; i++) {
    sum += i;
    if (i === end / 2) console.timeLog('Sum');
  }
  console.log('1~1000之和: ', sum);
  console.timeEnd('Sum');

  // group groupEnd groupCollapsed
  console.group('group demo');
    console.log('program start ...');
    console.groupCollapsed('loop');
    for (var i = 0; i < 10; i++) {
      console.log(i);
    }
    console.groupEnd();
    console.log('program end ...');
  console.groupEnd();

  // profile
  function doTask() {
    doTaskA(1000);
    doTaskA(100000);
    doTaskB(10000);
    doTaskC(1000);
  }
  function doTaskA(count) {
    for(var i = 1; i < count; i++){}
  }
  function doTaskB(count) {
    for(var i = 1; i < count; i++){}
  }
  function doTaskC(count) {
    for(var i = 1; i < count; i++){}
  }
  console.profile('testTitle');
  doTask();
  console.profileEnd('testTitle');

  // table
  var arr = [{
    name: 'RWBY',
    year: 2013,
    series: 6,
  }, {
    name: 'OVERLORD',
    year: 2015,
    series: 3,
  }, {
    name: '狐妖小红娘',
    year: 2015,
    series: 5,
  }, {
    name: 'JOJO',
    year: 2012,
    series: 6,
  }];
  console.table(arr);
  console.table(arr, ['name', 'year']);

  // count countReset
  console.log('%c%s', 'font-size: 20px; color: gold; background:  DarkSlateGrey;', '记录0~10之间的奇偶数的个数')
  for (var i = 0; i < 10; i++) {
    if (i % 2) {
      console.count('odd');
    } else {
      console.count('even');
    }
  }
  console.countReset('odd');
  console.countReset('even');

  // dir dirxml
  console.dir(document.getElementById('header'));
  console.dirxml(document.getElementById('header'));

  // assert
  console.assert(1 < 2, '正确');
  console.assert(1 > 2, '判断错误');

  // memory
  console.log('memory', console.memory);

  // console object
  console.log('%c%s', 'font-size: 17px; padding: 17px; background: #888; color: purple;', 'Yakumo Yukari')
  var yakumo = {
    name: 'Yukari',
    age: Infinity,
  };
  console.log(yakumo); // You think: { name: 'Yukari', age: Infinity }, in fact: { name: 'Yukari', age: 17 }

  if (yakumo.age > 18) {
    console.log('before changed'); // this will be output
  } else {
    console.log('after changed');
  }
  yakumo.age = 17;

  // placeholder
  console.log('%s placeholder', 'hello');
  console.log('%s', {}); // => Object
  console.log('%s', []); // => Array(0)
  console.log('1 + 2 = %d', 1 + 2);
  console.log('1 + 2 = %f', 1 + 2); // 1 + 2 = 3 (FireFox: 3.000000)
  console.log('0.1 + 0.2 = %f', 0.1 + 0.2);
  console.log('1.2 + 1.3 > %i', 1.2 + 1.3);
  console.log('numeric will be %d', '123');

  console.log('小o %o', {name: 'obj'});
  console.log('大O %O', {name: 'obj'});
  console.log('小o %o', document.getElementById('header'));
  console.log('大O %O', document.getElementById('header'));
  console.log('整型d %d', 123);
  console.log('小o %o', 123);
  console.log('大O %O', 123);
  console.log('字符串s %s', 'string');
  console.log('小o %o', 'string');
  console.log('大O %O', 'string');

  console.log('%cRainbowGirl', 'font-size: 40px; line-height: 60px; padding: 0 10px; color: #fff; background: linear-gradient(90deg, red 0%, orange 15%, yellow 45%, green 60%, cyan 75%, blue 90%, purple 100%)');

  // rainbow in Chrome
  console.log('%cRainbowGirl', 'font-size: 40px; padding: 100px 80px 50px; color: #bdbdbd; background: radial-gradient(at 50% 100%, transparent 0%, transparent 35%, #8b00ff 40%, #0000ff 45%, #00ffff 50%, #00ff00 55%, #ffff00 60%, #ff7f00 65%, #ff0000 70%); background-repeat: no-repeat;background-position: 0 0; border-radius: 200px 200px 0 0;');
  // rainbow text in FireFox
  console.log('%cRainbowGirl', 'font-size: 40px; line-height: 60px; padding: 0 10px; color: transparent; background: linear-gradient(90deg, red 0%, orange 15%, yellow 45%, green 60%, cyan 75%, blue 90%, purple 100%);-webkit-background-clip: text;text-fill-color:transparent;');

  console.log('%c3D TEXT', 'padding: 20px; background: #fff; color: #000; font-size: 50px; font-weight: bold; text-shadow: 1px 1px #999, 3px 3px #666;');
  console.log('%c%s', 'color: white; font-size: 20px;', 'you cant see me.');

})()
</script>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS端字符串转Date</title>
    <url>//2019/08/26/ios%E7%AB%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACdate.html</url>
    <content><![CDATA[<h2 id="iOS-端的-String-to-Date"><a href="#iOS-端的-String-to-Date" class="headerlink" title="iOS 端的 String to Date"></a>iOS 端的 String to Date</h2><p>在 iOS 端使用 <code>new Date()</code> 时，需要注意参数为字符串日期时，不能使用 <code>YYYY-MM-DD</code> 的形式，要把 <code>-</code> 替换为 <code>/</code>，使用 <code>YYYY/MM/DD</code> 这种形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeStr = <span class="string">&#x27;2019-8-26 10:33:43&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStr.replace(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript之变量声明</title>
    <url>//2017/08/26/javascript%E4%B9%8B%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E.html</url>
    <content><![CDATA[<p>JavaScript是一门弱类型语言，它并不像其他强类型语言那样有多种变量类型的声明形式，如：int, double, string… 等，在JavaScript中声明变量统一使用 var 关键字。</p>
<p>例如想要声明一个整数来使用，可以使用 <code>var num = 1;</code> 这样的语句，声明一串字符串也一样 <code>var str = &#39;string&#39;;</code> ,<a id="more"></a>声明一个布尔值、数组、对象都是使用 <code>var</code> 这个关键字： <code>var boo = true; var arr = [1,2,3]; var obj = &#123; x: 1, y: 2&#125;;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>; <span class="comment">// 声明一个整数</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;string&quot;</span>; <span class="comment">// 声明一串字符串</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>; <span class="comment">// 声明一个布尔值</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;; <span class="comment">// 声明一个对象</span></span><br></pre></td></tr></table></figure>

<p>在ES5标准之前，只有 <code>var</code> 这一个关键字用来声明一个可以使用的变量（函数暂不讨论）。而在ES6标准中，在此之上添加了两个新的声明变量的关键字，<code>let</code> 和 <code>const</code>。严格说起来应该是一个声明变量，一个声明常量， <code>const</code> 就是用来声明常量的关键字。</p>
<h2 id="let与var有什么不同？"><a href="#let与var有什么不同？" class="headerlink" title="let与var有什么不同？"></a>let与var有什么不同？</h2><p>这需要从变量的作用域说起。在ES5标准之前，JavaScript中只有两种作用域：全局作用域与函数作用域。全局作用域的变量可以在代码运行中的任何位置访问到，而函数作用域的变量只有在该函数内部能够访问到。而在ES6标准中新增了一个块级作用域的概念，let关键字就是对应块级作用域的概念的变量声明。通过let声明的变量只有在声明时所在的块级作用域的范围内能访问，所谓块级作用域指的是代码中被<code>&#123;&#125;</code>包裹起来的代码（对象除外），函数体也属于代码块。</p>
<p><code>let</code> 与 <code>var</code> 另一个不同的地方在于：</p>
<ul>
<li><p><code>var</code> 声明的变量可以重复声明，但只有第一次声明有效，且有声明提升；</p>
</li>
<li><p><code>let</code> 声明的变量不能再次声明，否则会报错，且let声明的变量并没有声明提升。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"><span class="comment">// let声明的变量在他所在的块级范围之外无法访问</span></span><br><span class="line"><span class="comment">/* --------------------------------------- */</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// undefined: 因为var声明有变量名提升，所以运行代码时，</span></span><br><span class="line"><span class="comment">// 系统就知道a是一个变量，只是这个变量并没有被赋值，因此是undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"><span class="comment">// 因为let声明没有变量名提升，所以运行到这句代码时，</span></span><br><span class="line"><span class="comment">// b还没有定义，不能作为一个变量使用</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* --------------------------------------- */</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>; <span class="comment">// SyntaxError: Identifier &#x27;c&#x27; has already been declared</span></span><br><span class="line"><span class="comment">// let 无法重复声明已有变量</span></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>

<h2 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h2><p>所谓常量，与变量相反。变量就是可以改变的量，而常量则是一旦声明，就无法改变的量。有些数据在使用过程中是不会改变的，甚至有些就是固定不变的值，如圆周率PI，像这样的数据，使用 <code>var</code> 声明，之后一直不做改动自然也是不算错的，但是使用 <code>const</code> 声明的话，更能够表达出符合的语义，用 <code>const PI = 3.14;</code> 代替 <code>var PI = 3.14;</code> 更能让人清楚地知道这是一个常量。</p>
<p>const声明的变量的作用域范围同let关键字，也是声明变量所在的块级作用域，用const声明的变量也不能重复声明，且没有变量声明提升，另外不能通过赋值来改变常量的值。</p>
<p>基于这几点，在声明一个常量的时候就要将这个常量的值赋给它，而不能先声明一个没有值的常量，再在之后赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> RWBY;</span><br><span class="line">RWBY = [<span class="string">&quot;ruby&quot;</span>,<span class="string">&quot;weiss&quot;</span>,<span class="string">&quot;blake&quot;</span>,<span class="string">&quot;yang&quot;</span>]; <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"><span class="comment">// 虽然错误是在重新给常量赋值时抛出的，也就是说 const RWBY; 这一步并没有错</span></span><br><span class="line"><span class="comment">// 但是很显然这样的语句毫无意义，所以通常声明一个常量时应该直接将值赋予该常量</span></span><br></pre></td></tr></table></figure>

<h2 id="关于变量声明提升"><a href="#关于变量声明提升" class="headerlink" title="关于变量声明提升"></a>关于变量声明提升</h2><p>JavaScript是解释型语言，解析一句执行一句，为了提高效率，在代码解析执行之前，有一个预解析的过程。在预解析时，代码并不会执行，系统只会检查当前作用域（函数内部的代码不会检查，只有在调用函数时，才会重复 <code>“预解析-&gt;执行”</code> 这样的步骤）的代码有没有语法上的错误和代码中的变量声明关键字 <code>var</code> 和函数声明的关键字 <code>function</code>。</p>
<p>在遇到这两种声明时，系统会在内存中预先记录下声明的变量名和函数名，也就是标识符。在预解析结束后，运行代码之前，系统就得到了有哪些标识符是可以作为变量来使用的，如果使用了系统未记录的标识符，也就是没有声明的变量，这时系统就会抛出一个引用错误 <code>ReferenceError: xxx is not defined</code> 。</p>
<p>在预解析过程中，如果遇到了同一个标识符多次声明，是不会多次记录的，只会记录第一次。如果同一个标识符既有变量声明var，又有函数声明function，最终记录下来的标识符是一个函数，遵循的原则是先有什么就记录什么，函数声明会记录两件事，一个同变量声明，记录该标识符可以使用，第二个记录该标识符指向一个函数。<br>所以有说法 <em>函数是JavaScript中的一等公民</em>。<br>但要知道该记录只保持在预解析结束，运行代码之前。<br>在运行代码过程中，需要根据实际情况判断标识符到底是一个变量还是一个函数。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 其他类型转换为数字类型的方式</title>
    <url>//2018/12/19/javascript-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<p>一般情况下，在 JavaScript 中把其他类型转换为数字类型时，遵循以下规则。</p>
<ol>
<li>如果是 <code>undefined</code>，返回 <code>NaN</code>。</li>
<li>如果是 <code>null</code>，返回 +0。</li>
<li>如果是布尔值，那么 true 转为 1，false 转为 +0。</li>
<li>如果是数字，直接返回原值</li>
<li>如果是字符串</li>
<li>如果是完全由数字组成的字符串，直接返回字面量对应的数字</li>
<li>如果是有数字+非数字组成的字符串<ol>
<li>以 <code>0x</code>、<code>0X</code>、<code>0o</code>、<code>0O</code>、<code>0b</code>、<code>0B</code>开头的数字，会尝试分别根据 16进制、8进制、2进制来转换为十进制数字。如果有超出进制范围的字符，则返回 <code>NaN</code></li>
<li>除情况1之外的，<code>Number()</code>、<code>+/-</code>、 <code>- 0</code> 、 <code>* 1</code> 等操作会返回 <code>NaN</code></li>
<li><code>parseInt/parseFloat</code> 会返回最前面作为数字的部分</li>
<li>其他情况根据实际方法返回，一般会返回 <code>NaN</code></li>
</ol>
</li>
<li>如果是Symbol类型 (ES6新增类型)，抛出类型异常 <code>TypeError: Cannot convert a Symbol value to a number</code></li>
<li>如果是对象</li>
<li>尝试调用该对象的 <code>valueOf</code> 方法转为原始值。</li>
<li>如果没有 <code>valueOf</code> 方法，或<code>valueOf</code>方法返回的不是原始值(Primitive)，则尝试调用 <code>toString</code> 方法转为原始值。</li>
<li>根据转换后的原始值类型，进入上述步骤 <code>1~6</code></li>
<li>如果无法转换为原始值，则抛出类型异常 <code>TypeError: Cannot convert object to primitive value</code></li>
</ol>
<a id="more"></a>

<h2 id="Number-方法"><a href="#Number-方法" class="headerlink" title="Number 方法"></a>Number 方法</h2><p>通过 <code>Number(data)</code> 进行强制类型转换。</p>
<p>如果要转换的类型是一个 <code>Object</code>，会优先调用对象的 <code>valueOf</code> 方法转为<strong>原始值</strong>。<br>如果找不到 <code>valueOf</code> 方法，再到原型链上找，依然没有或者 <code>valueOf</code> 方法返回的 <strong>不是原始值</strong> 的话，再找 <code>toString</code>方法。</p>
<blockquote>
<p>Tip:</p>
<p>需要注意的是，如果 <code>valueOf</code> 方法返回的不是一个 <strong>原始值</strong>，<br>那么也会转而调用 <code>toString</code> 方法来尝试转换为一个 原始值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>);      <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">123.4</span>);     <span class="comment">// 123.4</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123&#x27;</span>);     <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123abc&#x27;</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>);        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="built_in">Symbol</span>());  <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">Number</span>([]);        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">123</span>]);     <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>,<span class="number">2</span>]);     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;);        <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(&#123; <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span> &#125; &#125;); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 注意下面 返回了 123</span></span><br><span class="line"><span class="comment">// 这是因为 Object 的原型链上虽然存在 valueOf 方法，但是该方法并不返回一个原始值，而是返回该对象本身</span></span><br><span class="line"><span class="comment">// 而这里需要一个原始值，所以才会调用 toString 方法</span></span><br><span class="line"><span class="built_in">Number</span>(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span> &#125; &#125;); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Number</span>(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span> &#125;, <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span> &#125; &#125;); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<h2 id="parseInt-parseFloat-及-Math对象的方法"><a href="#parseInt-parseFloat-及-Math对象的方法" class="headerlink" title="parseInt/parseFloat 及 Math对象的方法"></a>parseInt/parseFloat 及 Math对象的方法</h2><p>通过 <code>parseInt(str)/parseFloat(str)</code> 提取出字符串开头的整数或浮点数。</p>
<p>如果 <code>argument</code> 是一个对象，会优先调用 <code>toString</code> 方法转为原始值。<br>如果找不到 <code>toString</code> 方法，再到原型链上找，依然没有或者 <code>toString</code> 方法返回的 <strong>不是原始值</strong> 的话，再找 <code>valueOf</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parseInt parseFloat</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">undefined</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>);       <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>);        <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>);      <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123.456&#x27;</span>);    <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.456&#x27;</span>);  <span class="comment">// 123.456</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123abc&#x27;</span>);     <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;abc123&#x27;</span>);   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123abc&#x27;</span>, <span class="number">16</span>); <span class="comment">// 1194684</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;abc123&#x27;</span>, <span class="number">16</span>); <span class="comment">// 11256099</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xa1&#x27;</span>);       <span class="comment">// 161</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Symbol</span>());     <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">parseInt</span>([]);           <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">123</span>]);        <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);      <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123;&#125;);           <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123abc&#x27;</span>; &#125; &#125;); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123; <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span>; &#125; &#125;);  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(obj);         <span class="comment">// TypeError</span></span><br><span class="line">obj.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span>; &#125;;</span><br><span class="line"><span class="built_in">parseInt</span>(obj);         <span class="comment">// 456</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123abc&#x27;</span>; &#125;, <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span>; &#125; &#125;); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;, <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span>; &#125; &#125;); <span class="comment">// 456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="literal">null</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">true</span>);       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="literal">false</span>);    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="string">&#x27;12.3&#x27;</span>);   <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="string">&#x27;-12.3&#x27;</span>);   <span class="comment">// -12</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="string">&#x27;12.5&#x27;</span>);   <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">&#x27;12.3&#x27;</span>);     <span class="comment">// 12.3</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">&#x27;-12.3&#x27;</span>);    <span class="comment">// 12.3</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">&#x27;12ab&#x27;</span>);     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs([]);         <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.abs([<span class="number">12</span>]);       <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Math</span>.abs([<span class="number">1</span>, <span class="number">2</span>]);     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs(&#123;&#125;);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs(&#123; <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span> &#125; &#125;);    <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.abs(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span> &#125; &#125;); <span class="comment">// 456</span></span><br><span class="line"><span class="built_in">Math</span>.abs(&#123; <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span> &#125;, <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span> &#125; &#125;);         <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip:</p>
<p>这里解释一下上面两次测试 <code>valueOf</code> 的结果不同的原因<br>第一次的参数是一个字面量的 <code>object</code>，<br>而第二次的参数是通过 <code>Object.create()</code> 方法生成的，指定原型为 <code>null</code> 的对象。</p>
<p>区别就在这里，虽然字面量的对象里只有一个 <code>valueOf</code> 方法，但是在对象的原型链上还是存在一个 <code>toString</code> 方法的。</p>
<p>所以根据 对象转字符串 的规则，会调用 <code>toString</code> 而不是 <code>valueOf</code>。<br>故第一次的测试对象转为字符串的结果其实是 <code>object.toString()</code> =&gt; <code>&quot;[object Object]&quot;</code>。<br>因此得到的是 <code>NaN</code>。</p>
<p>而第二次的对象，其原型为 null，是一个没有任何属性或方法的对象。<br>直接传入 <code>parseInt</code> 时，会由于找不到 <code>toString</code> 方法和 <code>valueOf</code> 方法而抛出一个 <code>TypeError</code>。<br>后面给它添加了一个 <code>valueOf</code> 方法后，<br>转换时找不到 <code>toString</code>，就会找到这个 <code>valueOf</code> 方法，<br>然后得到了 <code>&quot;456&quot;</code>，然后 <code>parseInt(&quot;456&quot;)</code> 就得到了结果 <code>456</code>。</p>
</blockquote>
<h3 id="parseInt-扩展"><a href="#parseInt-扩展" class="headerlink" title="parseInt 扩展"></a>parseInt 扩展</h3><p><code>parseInt</code> 函数有两个参数，第一个必须参数 <em>string</em> 和第二个可选参数 <em>radix</em>。</p>
<p>第一个参数 <em>string</em> 头部的空白符会被忽略。<br>即 <code>parseInt(&#39;123&#39;)</code> 和 <code>parseInt(&#39; \n\v\t123&#39;)</code> 其实是一样的。</p>
<p>第二个可选参数 <em>radix</em>，表示进制基数。<br>一般情况下默认为 <code>10</code>，即十进制。<br>但如果第一个参数是以 <code>0x</code> 或者 <code>0X</code> 开头的类似十六进制的字符串，那么<em>radix</em>则会被默认为 <code>16</code>。</p>
<p><em>radix</em> 范围是 <em>2~36</em>，根据进制的不同，可转换字符的范围也是不同的。<br>比如上面的例子：<code>&#39;abc123&#39;</code>，原本默认的十进制中是没有 <code>abc</code> 这样的数的，所以无法解析转换。<br>而把 <em>radix</em> 设置为 <em>16</em> 进制后，因为在16进制里，a相当于10，b相当于11，c相当于12。<br>也就是存在这样的数字，因此能够解析出来该数字，返回是一个十进制的数字。</p>
<p>另外，设置 <em>radix</em> 为 <em>2~36</em> 之外的数字的话，会返回 <code>NaN</code>，(<strong>0</strong> 除外,)<br>如果第二个可选参数 <em>radix</em> 为 <strong>0</strong>：</p>
<ul>
<li>第一个参数不是以 <code>0x</code> 或者 <code>0X</code> 开头的，则会以 <code>10</code> 来处理。</li>
<li>如果第一个参数是以 <code>0x</code> 或 <code>0X</code> 开头的，则以 <code>16</code> 来处理。</li>
</ul>
<p>ecma262 原文如下：</p>
<blockquote>
<h3 id="18-2-5-parseInt-string-radix"><a href="#18-2-5-parseInt-string-radix" class="headerlink" title="18.2.5 parseInt (string, radix)"></a>18.2.5 parseInt (<em>string</em>, <em>radix</em>)</h3><p>The <strong>parseInt</strong> function produces an integer value dictated by interpretation of the contents of the <em>string</em> argument according to the specified <em>radix</em>. Leading white space in <em>string</em> is ignored. If <em>radix</em> is <strong>undefined</strong> or 0, it is assumed 10 except when the number begins with the code unit pairs <strong>0x</strong> or <strong>0X</strong>, in which case a radix of 16 is assumed. If <em>radix</em> is 16, the number may also optionally begin with the code unit pairs <strong>0x</strong> or <strong>0X</strong>.</p>
</blockquote>
<h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p>相比较上面两种强制转换的方式，这种方式属于 <code>隐式转换</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> - <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> - <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="literal">null</span> * <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> - <span class="number">0</span>; <span class="comment">// 123</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> * <span class="number">1</span>; <span class="comment">// 123</span></span><br><span class="line"><span class="string">&#x27;123abc&#x27;</span> - <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line">[] - <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">[<span class="number">123</span>] - <span class="number">0</span>;  <span class="comment">// 123</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] - <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line">(&#123;&#125;) - <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line">(&#123; <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>; &#125; &#125;) - <span class="number">0</span>; <span class="comment">// 123</span></span><br><span class="line">(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>; &#125; &#125;) - <span class="number">0</span>; <span class="comment">// 123</span></span><br><span class="line">(&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>; &#125;, <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;456&#x27;</span>; &#125; &#125;) - <span class="number">0</span>; <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip:<br>不要用 加号(+)。<br>因为加号在遇到字符串与数字相加时，会将数字转换为字符串，而不是将字符串转换为数字。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> + (&#123; <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; &#125;); <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> + (&#123; <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; &#125;);  <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// &#x27;10&#x27;</span></span><br><span class="line"><span class="number">1</span> + []; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line"><span class="number">1</span> + [<span class="number">1</span>]; <span class="comment">// &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><p>注意下面的 <code>+</code> 是一元运算符的 <code>正号</code>，而非 <code>加号</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="string">&#x27;123&#x27;</span>;    <span class="comment">// 123</span></span><br><span class="line">-(-<span class="string">&#x27;123&#x27;</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~~<span class="string">&#x27;123&#x27;</span>;   <span class="comment">// 123</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> | <span class="number">0</span>; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXI=">ECMAScript® ToNumber<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXItYXBwbGllZC10by10aGUtc3RyaW5nLXR5cGU=">ECMAScript® ToNumber Applied to the String Type<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmU=">ECMAScript® ToPrimitive<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZQ==">ECMAScript® OrdinaryToPrimitive<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>下面贴出部分原文：</p>
<blockquote>
<h3 id="7-1-3-ToNumber"><a href="#7-1-3-ToNumber" class="headerlink" title="7.1.3 ToNumber"></a>7.1.3 ToNumber</h3><p>The abstract operation ToNumber converts <em>argument</em> to a value of type Number according to Table 10:</p>
<p>Table 10: ToNumber Conversions</p>
<table>
<thead>
<tr>
<th>Argument Type</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>Return <strong>NaN</strong>.</td>
</tr>
<tr>
<td>Null</td>
<td>Return <strong>+0</strong>.</td>
</tr>
<tr>
<td>Boolean</td>
<td>If <em>argument</em> is <strong>true</strong>, return 1. If <em>argument</em> is <strong>false</strong>, return <strong>+0</strong>.</td>
</tr>
<tr>
<td>Number</td>
<td>Return <em>argument</em> (no conversion).</td>
</tr>
<tr>
<td>String</td>
<td>See grammar and conversion algorithm below.</td>
</tr>
<tr>
<td>Object</td>
<td>Apply the following steps: 1. Let <em>primValue</em> be ? ToPrimitive (<em>argument</em>, hint Number). 2. Return ? <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXI=">ToNumber<i class="fa fa-external-link-alt"></i></span>(*primValue*)</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<h3 id="ToPrimitive-input-PreferredType"><a href="#ToPrimitive-input-PreferredType" class="headerlink" title="ToPrimitive (input[,PreferredType])"></a>ToPrimitive (<em>input</em>[,<em>PreferredType</em>])</h3><p>The abstract operation ToPrimitive takes an <em>input</em> argument and an optional argument <em>PreferredType</em>.<br>The abstract operation ToPrimitive converts its <em>input</em> argument to a non-Object type.<br>If an object is capable of converting to more than one primitive type, it may use the optional hint <em>PreferredType</em> to favour that type.<br>Conversion occurs according to the following algorithm:</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNhc3NlcnQ=">Assert<i class="fa fa-external-link-alt"></i></span>: <em>input</em> is an <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcw==">ECMAScript language value<i class="fa fa-external-link-alt"></i></span>.</li>
<li>If <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXM=">Type<i class="fa fa-external-link-alt"></i></span>(*input*) is Object, then<ol>
<li>If <em>PreferredType</em> is not present, let <em>hint</em> be <strong>“default”</strong>.</li>
<li>Else if <em>PreferredType</em> is hint String, let <em>hint</em> be <strong>“string”</strong>.</li>
<li>Else <em>PreferredType</em> is hint Number, let <em>hint</em> be <strong>“number”</strong>.</li>
<li>Let <em>exoticToPrim</em> be ? <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0bWV0aG9k">GetMethod<i class="fa fa-external-link-alt"></i></span>(*input*, @@toPrimitive).</li>
<li>If <em>exoticToPrim</em> is not <strong>undefined</strong>, then<ol>
<li>Let <em>result</em> be ? <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY2FsbA==">Call<i class="fa fa-external-link-alt"></i></span>(*exoticToPrim*, *input*, &lt;&lt;*hint*&gt;&gt;).</li>
<li>If <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXM=">Type<i class="fa fa-external-link-alt"></i></span>(*result*) is not Object, return <em>result</em>.</li>
<li>Throw a <strong>TypeError</strong> exception.</li>
</ol>
</li>
<li>If <em>hint</em> is <strong>“default”</strong>, set <em>hint</em> to <strong>“number”</strong>.</li>
<li>Return ? <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZQ==">OrdinaryToPrimitive<i class="fa fa-external-link-alt"></i></span>(*input*, *hint*).</li>
</ol>
</li>
<li>Return <em>input</em>.</li>
</ol>
<blockquote>
<p>NOTE<br>When ToPrimitive is called with no hint, then it generally behaves as if the hint were Number.<br>However, objects may over-ride this behaviour by defining a @@toPrimitive method.<br>Of the objects defined in this specification only Date objects (see <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZQ==">20.3.4.45<i class="fa fa-external-link-alt"></i></span>) and Symbol objects (see <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZl">19.4.3.4<i class="fa fa-external-link-alt"></i></span>) over-ride the default ToPrimitive behaviour.<br>Date objects treat no hint as if the hint were String.</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中undefined与null的区别</title>
    <url>//2019/07/09/javascript%E4%B8%ADundefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<p>前几天，朋友在看 JavaScript 关键字的时候，发现了这样一个小问题：</p>
<blockquote>
<p><code>undefined</code> 和 <code>null</code> 都不是关键字，但是为什么 <code>undefined</code> 可以作为变量名赋值，而 <code>null</code> 却不行？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="literal">null</span> = <span class="number">1</span>; <span class="comment">// SyntaxError: Unexpected token null</span></span><br><span class="line"><span class="literal">null</span> = <span class="number">2</span>; <span class="comment">// ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<p>基于此，我查找了一下 MDN 文档，并记在了这里。</p>
<p>在 JavaScript 中，<code>undefined</code> 与 <code>null</code> 都是用来表示空值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以上面通过 <code>==</code> 进行比较时，是相等的。可是毫无疑问的，这两者并不是完全相同的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="1-具体含义"><a href="#1-具体含义" class="headerlink" title="1. 具体含义"></a>1. 具体含义</h2><p>首先，二者在语义方面的不同。</p>
<ul>
<li><code>undefined</code> 是表示未赋值的一个状态</li>
<li><code>null</code> 则是表明该值被赋予了一个空值</li>
</ul>
<p>也就是说，一个变量 <em>x</em> 为 <code>undefined</code> 时，意为：变量 <em>x</em> 还没有被赋予某个值。<br>而变量 <em>x</em> 为 <code>null</code> 时，则意为：变量 <em>x</em> 被显式的赋予了一个空值。</p>
<h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h2><ul>
<li><p>在类型上，<code>undefined</code> 是 JavaScript 中的基础类型之一；而 <code>null</code> 则是一个值，一个常量，类似数字 1, 2, 3 …… 这样的常量。</p>
</li>
<li><p>同时，<code>undefined</code> 还是一个全局变量，其值就是 <em>undefined</em>，即 <code>window.undefined === undefined</code>。</p>
</li>
</ul>
<blockquote>
<p>自ECMAScript5标准以来undefined是一个不能被配置（non-configurable），不能被重写（non-writable）的属性。</p>
</blockquote>
<p>不过实际上你可以对 <code>undefined</code> 重新赋值，只是在<strong>全局作用域</strong>下这并不会改变 <code>undefined</code> 的值。<br>而在块级作用域及函数作用域中，是可以改变 <code>undefined</code> 的值的。<strong>但不建议这样重写 <code>undefined</code> 的值，也应当避免这种做法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="literal">undefined</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeUndefined</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeUndefined(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>而 <code>null</code>，本身作为一个值，那它就无法被赋值，即 <code>null</code> 无法作为一个变量名来使用。就像你不能写 <code>var 1 = 2</code> 这样。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0ludmFsaWRfYXNzaWdubWVudF9sZWZ0LWhhbmRfc2lkZQ==">ReferenceError: invalid assignment left-hand side - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvbnVsbA==">null - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvdW5kZWZpbmVk">undefined - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>可选链操作符与空值合并操作符</title>
    <url>//2021/01/15/%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6.html</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>因为在项目 Code Review 时发现部分新人对可选链操作符 <code>?.</code> 的理解有误，特此记录一下其含义及用法；顺带提一下与其同时出现的空值合并操作符 <code>??</code></p>
<h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><blockquote>
<p>MDN引用：<br><strong>可选链</strong>操作符( <code>?.</code> )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空(nullish ) (<code>null</code> 或者 <code>undefined</code>) 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。与函数调用一起使用时，如果给定的函数不存在，则返回 <code>undefined</code>。</p>
</blockquote>
<p>如果上面的解释你不太明白，可以先看下面的例子：</p>
<p>在一个项目中，使用一些对象属性或调用对象方法时，为了安全，我们一般都会需要先判断这个对象是否存在，以及属性是否存在等；尤其当数据是由后端接口返回的情况下，更要加上一些空值判断。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (res &amp;&amp; res.data &amp;&amp; res.data.success) &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这种判断贯穿整个项目很多地方，写的时候很是繁琐；可选链操作符就是为了解决这个问题的，上面的判断改用可选链操作符的话，可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (res?.data?.success) &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是简单清晰明了？</p>
<p>可选链的作用是判断它的前一个数据是否是 <code>undefined</code> 或者 <code>null</code>；如果是，则不再执行后续操作，直接返回 <code>undefined</code>；如果不是，就可以继续访问后续属性，以返回该属性的结果。</p>
<p>还是说上面的例子，它的实际运行情况是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  (res == <span class="literal">null</span>) ? <span class="literal">undefined</span></span><br><span class="line">    : (res.data == <span class="literal">null</span>) ? <span class="literal">undefined</span></span><br><span class="line">      : res.data.success</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>可选链操作符是一种短路运算；当左侧操作数为 <code>null</code> 或 <code>undefined</code> 时，右侧如果有表达式，是不会被执行的。<br>看了上面的解析例子，你能大概理解吗？</p>
<p>测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> res = arr?.[n++];</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>看了例子，大家应该也知道在对象属性的访问时，要如何使用可选链操作符了，但是其他如数组、函数调用该如何使用可能还不太清楚，这里也写一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象属性</span></span><br><span class="line">obj?.prop;</span><br><span class="line"><span class="comment">// 关联数组语法</span></span><br><span class="line">obj?.[expr];</span><br><span class="line"><span class="comment">// 数组索引</span></span><br><span class="line">arr?.[n];</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">fn?.();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合</span></span><br><span class="line">obj?.arrProp?.[<span class="number">3</span>]?.fn?.();</span><br></pre></td></tr></table></figure>

<p>虽然最后这个混合的例子有点儿那啥，但是也是为了让你们能更清楚的了解一下如何使用，就不要吐槽了。</p>
<h3 id="不能被赋值"><a href="#不能被赋值" class="headerlink" title="不能被赋值"></a>不能被赋值</h3><p>可选链不能用于赋值操作符的左侧，即不能给一个可选链赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="literal">null</span>;</span><br><span class="line">obj?.prop = <span class="number">1</span>; <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<h2 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符"></a>空值合并操作符</h2><blockquote>
<p>MDN引用：<br><strong>空值合并操作符</strong>（<code>??</code>）是一个逻辑操作符，当左侧的操作数为 <code>null</code> 或者 <code>undefined</code> 时，返回其右侧操作数，否则返回左侧操作数。</p>
</blockquote>
<p>提到空值合并操作符，就必须提一下逻辑或操作符 (<code>||</code>)，它们两个乍一看很相似，实际却是不同的。</p>
<p>空值合并操作符仅针对左侧操作数为 <code>null</code> 或 <code>undefined</code> 时，才返回右侧操作数；而逻辑或操作符则是针对左侧操作数为 <em>falsy</em> 时，就返回右侧操作数。<br>而在 JavaScript 中的 <em>falsy</em> 数据，不止 <code>null</code> 和 <code>undefined</code> 两种，其他还有 <code>false</code>, <code>0</code>, <code>NaN</code>, <code>&#39;&#39;</code> 这些数据。</p>
<p>具体可以看下面的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> ?? <span class="string">&#x27;default&#x27;</span>; <span class="comment">// &#x27;default&#x27;</span></span><br><span class="line"><span class="literal">null</span> || <span class="string">&#x27;default&#x27;</span>; <span class="comment">// &#x27;default&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> ?? -<span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="literal">undefined</span> || -<span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> ?? -<span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">0</span> || -<span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> ?? <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> ?? <span class="string">&#x27;default string&#x27;</span>; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;default string&#x27;</span>; <span class="comment">// &#x27;default string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>了解了吗？当左侧操作数为 <code>null</code> 和 <code>undefined</code> 时，空值合并操作符和逻辑或操作符的结果是一致的，但当左侧操作数为其他 <em>falsy</em> 值时，二者就不同了。</p>
<h3 id="短路-1"><a href="#短路-1" class="headerlink" title="短路"></a>短路</h3><p>类似逻辑操作符，空值合并操作符也是一个短路运算：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f1&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f2&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f3&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1() ?? f2() ?? f3();</span><br><span class="line"><span class="comment">// 先后打印 f1 f2 并返回 false</span></span><br><span class="line"><span class="comment">// 没有执行 f3</span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>空值合并运算符(<code>??</code>)还有一点需要注意的是，它不能和 逻辑与运算符(<code>&amp;&amp;</code>) 和 逻辑或运算符(<code>||</code>) 混合使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="number">1</span>; <span class="comment">// 抛出 SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使看上去不会被执行，这是语法错误，即不能这样书写代码</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">true</span> ?? <span class="literal">false</span>; <span class="comment">// 抛出 SyntaxError</span></span><br></pre></td></tr></table></figure>

<p>不过如果使用圆括号将它们进行分组隔开的话，则没问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="literal">null</span> || <span class="literal">undefined</span>) ?? <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">(<span class="literal">true</span> || <span class="literal">true</span>) ?? <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> || (<span class="number">0</span> ?? <span class="number">1</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtY24vZG9jcy93ZWIvamF2YXNjcmlwdC9yZWZlcmVuY2Uvb3BlcmF0b3JzLyVFNSU4RiVBRiVFOSU4MCU4OSVFOSU5MyVCRQ==">MDN-可选链操作符<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL051bGxpc2hfQ29hbGVzY2luZ19PcGVyYXRvcg==">MDN-空值合并运算符<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>模板字符串</title>
    <url>//2019/07/01/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content><![CDATA[<h2 id="什么是模板字符串"><a href="#什么是模板字符串" class="headerlink" title="什么是模板字符串"></a>什么是模板字符串</h2><p>JavaScript 中，模板字符串是在 ECMAScript2015 中加入的新语法。<br>它以反引号（<code>`</code>）替代普通字符串的单引号、双引号，允许在内部使用特定语法（<code>$&#123;...&#125;</code>）嵌入表达式，同时它还支持多行字符串。</p>
<p>以上功能基本稍有了解的应该都知道并使用过了，但是模板字符串还有一个特性：带标签的模板字符串。</p>
<p>如果一个模板字符串前面是一个表达式（通常是一个函数），该字符串就被称为 <em>带标签的模板字符串</em>。它会在模板字符串处理后被调用。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建一个字符串变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 之前的字符串</span></span><br><span class="line"><span class="keyword">var</span> single = <span class="string">&#x27;this is a single-quote string&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> double = <span class="string">&quot;this is a double-quote string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的模板字符串</span></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">`this is a template string`</span>;</span><br></pre></td></tr></table></figure>

<p>如果要插入一个变量的话</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;1 + 2 = &#x27;</span> + (<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">`1 + 2 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>如果要在字符串内换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&#x27;string line 1\n&#x27;</span> +</span><br><span class="line">           <span class="string">&#x27;string line 2&#x27;</span>;</span><br><span class="line"><span class="comment">// string line 1</span></span><br><span class="line"><span class="comment">// string line 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">`string line 1</span></span><br><span class="line"><span class="string">string line 2`</span>; <span class="comment">// 需要注意的是这里最前面不加空格，如果加上空格或 tab 缩进，会出现在字符串中</span></span><br><span class="line"><span class="comment">// string line 1</span></span><br><span class="line"><span class="comment">// string line 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果加上空格</span></span><br><span class="line"><span class="keyword">var</span> str5 = <span class="string">`string line 1</span></span><br><span class="line"><span class="string">            string line 2`</span>;</span><br><span class="line"><span class="comment">// string line 1</span></span><br><span class="line"><span class="comment">//            string line 2</span></span><br></pre></td></tr></table></figure>

<h2 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h2><p>更高级形式的模板字符串是带标签的模板字符串。标签使得你可以用函数来解析模板字符串。标签函数的第一个参数是通过占位符分割后的字符串数组，剩余参数为占位符中表达式的返回值。你可以根据需要在函数中返回处理好的字符串，或者一个完全不同的数据类型：一个新的函数、对象、其他的字符串、布尔值……所有 JavaScript 支持的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">16</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTag</span>(<span class="params">templateStrings, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str0 = templateStrings[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> ageStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    ageStr = <span class="string">&#x27;juvenile&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ageStr = <span class="string">&#x27;adult&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str0 + ageStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myTag<span class="string">`That guy is <span class="subst">$&#123;age&#125;</span>`</span>; <span class="comment">// &quot;That guy is juvenile&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签函数也可以返回其他的类型，比如返回一个新的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">strings, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dict = values[values.length - <span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> result = [strings[<span class="number">0</span>]];</span><br><span class="line">    keys.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="built_in">Number</span>.isInteger(key) ? values[key] : dict[key];</span><br><span class="line">      result.push(value, strings[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span><span class="subst">$&#123;<span class="number">1</span>&#125;</span><span class="subst">$&#123;<span class="number">0</span>&#125;</span>!`</span>;</span><br><span class="line">t1Closure(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;A&#x27;</span>);  <span class="comment">// &quot;YAY!&quot;</span></span><br><span class="line"><span class="keyword">var</span> t2Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span> <span class="subst">$&#123;<span class="string">&#x27;foo&#x27;</span>&#125;</span>!`</span>;</span><br><span class="line">t2Closure(<span class="string">&#x27;Hello&#x27;</span>, &#123;<span class="attr">foo</span>: <span class="string">&#x27;World&#x27;</span>&#125;);  <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="模板字面量及转义序列"><a href="#模板字面量及转义序列" class="headerlink" title="模板字面量及转义序列"></a>模板字面量及转义序列</h2><p>自 ES2016 开始，模板字面量遵循以下转义序列的规则：</p>
<ul>
<li>Unicode 字符以 <code>\u</code> 开头，例如：<code>\u00A9</code></li>
<li>Unicode 码位以 <code>\u&#123;&#125;</code> 表示，例如：<code>\u&#123;2F804&#125;</code></li>
<li>十六进制以 <code>\x</code> 开头，例如：<code>\xA9</code></li>
<li>八进制以 <code>\</code> 和数字开头，例如：<code>\251</code></li>
</ul>
<p>据此规则，可以得出以下表达式是有问题的，因为对于每一个 ECMAScript 语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myTag<span class="string">`\unicode`</span>;</span><br><span class="line"><span class="comment">// 在较老的ECMAScript版本中报错（ES2016及更早）</span></span><br><span class="line"><span class="comment">// SyntaxError: malformed Unicode character escape sequence</span></span><br><span class="line"><span class="comment">// 注：以上注释信息并非实测，而是在 MDN 上复制下来的</span></span><br><span class="line"><span class="comment">// 带标签的模板字面量在 ES2018 中移除了该转义序列的限制</span></span><br><span class="line"></span><br><span class="line"><span class="string">`\unicode`</span>; <span class="comment">// SyntaxError: Invalid Unicode escape sequence</span></span><br></pre></td></tr></table></figure>

<p>虽然在 ES2018 中移除了在带标签的模板字面量中对转义序列的语法限制，但是非法转义序列仍然可以在标签函数得到的参数中体现出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">cooked</span>: strings[<span class="number">0</span>], <span class="attr">raw</span>: strings.raw[<span class="number">0</span>] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latex<span class="string">`\unicode`</span>;</span><br><span class="line"><span class="comment">// &#123; cooked: undefined, raw: &quot;\\unicode&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>由此我们又引出了一个新的属性：<code>raw</code></p>
<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><p>标签函数的第一个参数中，存在着一个特殊的属性 <code>raw</code>，我们可以访问模板字符串中的原始字符串，而不经过特殊字符的替换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> two = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`string line <span class="subst">$&#123;one&#125;</span> \n string line <span class="subst">$&#123;two&#125;</span>`</span></span><br><span class="line"><span class="comment">// [&quot;string line &quot;, &quot; \n string line &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 注：这里打印出的 &quot;\n&quot; 并非是换行符，而是字符串 &quot;\\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>另外，使用 <code>String.raw()</code> 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">String</span>.raw<span class="string">`Hey\nYang`</span>;</span><br><span class="line">str.length; <span class="comment">// 9</span></span><br><span class="line">str === <span class="string">&#x27;Hey\nYang&#x27;</span>; <span class="comment">// false</span></span><br><span class="line">str === <span class="string">&#x27;Hey\\nYang&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvdGVtcGxhdGVfc3RyaW5ncw==">模板字符串 - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ANGEL WITH A SHOTGUN - THE CAB</title>
    <url>//2018/02/02/angel-with-a-shotgun-the-cab.html</url>
    <content><![CDATA[<div class="video-container"><iframe src="https://www.youtube.com/embed/pdwgRKMTcgk" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p><em>I’m an angel with a shotgun, shotgun, shotgun.<br>An angel with a shotgun, shotgun, shotgun.<br>Get out your guns, battle’s begun,<br>are you a saint or a sinner?<br>If love’s a fight, then I shall die,<br>with my heart on trigger.</em></p>
<p><em>They say before you start a war,<br>you better know what you’re fighting for.<br>Well baby, you are all that I adore,<br>if love is what you need, a soldier I will be.</em></p>
<a id="more"></a>
<p><em>I’m an angel with a shotgun,<br>fighting til’ the war’s won.<br>I don’t care if heaven won’t take me back.<br>I’ll throw away my faith, babe, just to keep you safe.</em></p>
<p><em>Don’t you know you’re everything I have?<br>and I, wanna live, not just survive, tonight.</em></p>
<p><em>Somethings to win, you’ve got to sin,<br>don’t mean I’m not a believer,<br>and Major Tom will sing along.<br>Yeah, they still say I’m a dreamer.</em></p>
<p><em>They say before you start a war,<br>you better know what you’re fighting for.<br>Well baby, you are all that I adore,<br>if love is what you need, a soldier I will be.</em></p>
<p><em>I’m an angel with a shotgun,<br>fighting til’ the war’s won.<br>I don’t care if heaven won’t take me back.<br>I’ll throw away my faith, babe, just to keep you safe.<br>Don’t you know you’re everything I have?<br>and I, wanna live, not just survive, tonight.</em></p>
<p><em>I’m an angel with a shotgun,<br>fighting til’ the war’s won<br>I don’t care if heaven won’t take me back.</em></p>
<p><em>I’m an angel with a shotgun<br>fighting til’ the war’s won.<br>I don’t care if heaven won’t take me back.<br>I’ll throw away faith, babe, just to keep you safe.<br>Don’t you know you’re everything I have?<br>(I’m an angel with a shotgun)<br>and I, want to live, not just survive, tonight.<br>(Live, not just survive)<br>and I’m gonna hide, hide, hide my wings tonight.</em></p>
<p><em>They say before you start a war,<br>you better know what you’re fighting for.<br>Well baby, you are all that I adore,<br>if love is what you need, a soldier I will be.</em></p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/QA_ONzF9Xz4" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
]]></content>
      <categories>
        <category>生活娱乐</category>
      </categories>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码笔记</title>
    <url>//2020/07/07/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>我们知道，计算机是二进制存储的，所有的内容，在计算机内存储下来的都是 <code>0</code> 和 <code>1</code> 来表示的二进制数字。<br>早期的计算机在设计时，采用 8 个二进制位 (<code>bit</code>) 作为一个字节 (<code>byte</code>)，因为每个二进制位都有 <code>0</code> 和 <code>1</code> 两种状态，所以一个字节一共可以表示 2<sup>8</sup> = 256 种状态。</p>
<h2 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h2><p>字符集，从字面上来拆解，其实就是字符的集合；就是把我们使用到的字符整合在一起，并为每一个符号指定一个唯一的编号（叫作 <code>码点</code>）。</p>
<p>因为计算机只能处理二进制数字，那么如果要处理文本内容时，就需要先把文本转换成数字；<br>将字符集中每一个字符唯一的编号，按照某种规则映射到二进制存储，这就是所谓的 <code>字符编码</code>。<br>比如最早给英文字符、数字、标点符号等制定了一套编码的 <code>ASCII</code>（<em>American Standard Code for Information Interchange</em>, <em>美国信息交换标准代码</em>）。</p>
<p>简单来说，字符集是一套被分配了唯一编号的字符的集合，而字符编码则是对字符集映射到二进制的一个实现方式。</p>
<h2 id="字符编码的历史演变"><a href="#字符编码的历史演变" class="headerlink" title="字符编码的历史演变"></a>字符编码的历史演变</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>在 20 世纪 60 年代，美国制定了一套字符编码，对英语字符和二进制之间的关系，做了统一规定，这被称为 <code>ASCII</code>，一直沿用至今。</p>
<p><code>ASCII</code> 码一共规定了128个字符的编码，比如空格 <code>SPACE</code> 是 <code>32</code>（二进制<code>00100000</code>），大写的字母<code>A</code>是<code>65</code>（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p>
<h3 id="扩展ASCII"><a href="#扩展ASCII" class="headerlink" title="扩展ASCII"></a>扩展ASCII</h3><p>对英语来说，<code>ASCII</code> 内这 128 个字符就够用了，但是对欧洲其他一些国家来说，就不够用了；比如法国、德国等。<br>然后这些国家就对 <code>ASCII</code> 码做了扩展，利用字节中闲置的最高位编入新的符号，比如法语中的<code>é</code>的编码为<code>130</code>（二进制<code>10000010</code>），如此一来，这些欧洲国家就多出了128个字符可以存储；扩展后的 <code>ASCII</code> 码最多可以表示 <code>256</code> 个字符。<br>这些扩展编码中，比较流行的编码有 <code>latin-1</code>, <code>ISO-8859-1</code> 等。</p>
<p>可这里也有一个问题：不同的国家有不同的字母，那么不同的扩展，势必会有同一个码点却代表不同的字母这样的情况出现。</p>
<h3 id="其他编码"><a href="#其他编码" class="headerlink" title="其他编码"></a>其他编码</h3><p>上面说的只是欧洲这种以字母为主的语种国家，而像我们中国、日本等东亚语系的国家，需要使用的语言符号更多，只用一个字节，根本不够，如此就需要使用多个字节来表示一个字符。比如简体中文 <code>GB2312</code> 编码，就是使用两个字节表示一个汉字，所以理论上最多可以表示出 <code>256 * 256 = 65536</code> 个汉字。</p>
<h3 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h3><p>每个国家都有一套自己的编码方式，尤其是码点在 <code>128-255</code> 之间的字符，每套编码代表的字符都不一样；<br>如果将一个以A编码方式存储的文件，以B编码方式打开，就会出现乱码的问题。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>如上所说，世界上存在很多编码方式，同一个二进制数字可以被解释成不同的字符；因此，要想正常打开一个文本文件，就必须知道它的编码方式，否则就会出现乱码。<br>可以想象，如果存在一种编码，将世界上所有的字符都纳入其中；每个字符都有一个独一无二的码点，大家都使用这同一套编码，那么乱码问题就会消失。<br>这就是 <code>Unicode</code> 字符集。</p>
<h3 id="UCS与Unicode"><a href="#UCS与Unicode" class="headerlink" title="UCS与Unicode"></a>UCS与Unicode</h3><p>人们开始迫切的需要一套统一的字符集，能够包含世界上所有的符号。<br>1988 年成立的 Unicode 团队和 1989 年成立的 UCS 团队，这两个团队就是想要搞出一套统一字符集成立的。<br>只是一开始他们并不知道彼此的存在。<br>1990 年，开发进度较快的 UCS 团队公布了第一套编码方法 <code>UCS-2</code>，使用2个字节表示已有码点的字符，同时这也是 <code>JavaScript</code> 中使用的编码方式。<br>而等到两个团队发现了对方存在之后，很快达成一致：世界上不需要两套统一字符集。在 1991 年 10 月，两个团队决定合并字符集；以后只发布一套字符集，就是 <code>Unicode</code>；并修复此前发布的字符集，使 <code>UCS</code> 的码点与 <code>Unicode</code> 完全一致。</p>
<blockquote>
<p>也由于 <code>JavaScript</code> 使用的是 <code>UCS-2</code> 编码，所以 <code>JavaScript</code> 的字符处理是有一些问题的，遇到4字节字符时，会当成两个2字节的字符来处理。<br>即使 ECMAScript6 扩展增强了 <code>Unicode</code> 的支持，基本解决了这个问题，但是为了兼容性，一些问题还是被保留了下来。<br>比如 <code>&quot;𝓂&quot;.length === 2</code>。<br>不过因为时间上的原因，<code>JavaScript</code> 也只能选择 <code>UCS-2</code>，而不是现在支持的 <code>UTF-16</code>。<br><code>JavaScript</code> 诞生于 1995年5月，<em>Brendan Eich</em> 用了 10 天设计了这套语言；同年10月，第一个解释引擎问世；<br>而 <code>UTF-16</code> 的发布时间却是在 1996年7月。</p>
</blockquote>
<h3 id="Unicode与UTF"><a href="#Unicode与UTF" class="headerlink" title="Unicode与UTF"></a>Unicode与UTF</h3><p>需要注意的是，<code>Unicode</code> 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码如何存储。<br>也就是说有许多中不同的二进制格式，可以用来表示 <code>Unicode</code>。<br>直到互联网普及，出现了几种使用较为广泛的编码方式，其中就有我们现在常用的 <code>UTF-8</code>，其他还有 <code>UTF-16</code> 和 <code>UTF-32</code>。<br><code>UTF</code> 的全称是 <em>Unicode/UCS Transformation Format</em>，亦即把 <code>Unicode</code> 字符转换为某种格式。</p>
<h4 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h4><p><code>Unicode</code> 的编码空间从 <code>U+0000</code> 到 <code>U+10FFFF</code>，一共有 1,112,064 个码点可以用来映射字符。<br>这么多字符，<code>Unicode</code> 也并不是一次性定义的，而是分区定义的。<br>每个区可以存放 65536 个字符（16位，2<sup>16</sup>），这样一个分区称为一个“平面”。<br>而目前一共有 17 个平面，也就是说，整个 <code>Unicode</code> 字符集的大小是 2<sup>21</sup>。</p>
<p>在这 17 个平面里，前 65536 个字符，也就是第一个平面，也被称为<strong>基本平面</strong>（<em>Basic Multilingual Plane,基本多语言平面</em>, <strong>BMP</strong>），其他平面称为<strong>辅助平面</strong>（<em>Supplementary Planes</em>）。</p>
<p>你可能偷偷计算了一下，发现 2<sup>21</sup> 远大于上面说的 1,112,064 个码点。<br>其实在这 2<sup>21</sup> 个码点里，并不是每个码点都用来映射字符。<br>在基本平面内，从 <code>U+D800</code> 到 <code>U+DFFF</code> 之间的码点区段是永久保留不映射到 <code>Unicode</code> 字符的；<br>而辅助平面码点的编码就是利用这个区段的码点来进行的。</p>
<h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>这个仅了解一些就好，因为实际上很少会使用这个编码，甚至HTML5标准中明文规定，禁止支持 <code>UTF-32</code> 编码。</p>
<p><code>UTF-32</code> 的编解码规则简单，所有字符都用四个字节表示，并完全对应 <code>Unicode</code> 码点，查找效率很高；但是它的缺点是很浪费空间，如果是纯英文文本，<code>UTF-32</code> 编码的占用空间是 <code>ASCII</code> 编码的四倍，在以前那个空间并不充足的年代，这几乎是无法容忍的；即使是现在，这也是一个致命的缺点。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY2hhcmFjdGVyLWVuY29kaW5ncw==">https://html.spec.whatwg.org/#character-encodings<i class="fa fa-external-link-alt"></i></span><br>Note<br>The above prohibits supporting, for example, CESU-8, UTF-7, BOCU-1, SCSU, EBCDIC, and UTF-32. This specification does not make any attempt to support prohibited encodings in its algorithms; support and use of prohibited encodings would thus lead to unexpected behavior.</p>
</blockquote>
<h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p><code>UTF-16</code> 可以说是 <code>UCS-2</code> 的一个扩展，基本平面内的字符使用 2 个字节表示，辅助平面的字符使用 4 个字节表示。</p>
<table>
<thead>
<tr>
<th>Unicode 码点</th>
<th>UTF-16 编码</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td><code>U+0000</code> - <code>U+D7FF</code>, <code>U+E000</code> - <code>U+FFFF</code></td>
<td><code>xxxxxxxx</code> <code>xxxxxxxx</code></td>
<td>基本平面内，使用两个字节表示，<code>U+D800</code> - <code>U+DFFF</code> 是保留区段</td>
</tr>
<tr>
<td><code>U+010000</code> - <code>U+10FFFF</code></td>
<td><code>110110xx</code> <code>xxxxxxxx</code> <code>110111yy</code> <code>yyyyyyyy</code></td>
<td>辅助平面，使用四个字节表示，并有前缀标识</td>
</tr>
</tbody></table>
<h5 id="从U-D800到U-DFFF"><a href="#从U-D800到U-DFFF" class="headerlink" title="从U+D800到U+DFFF"></a>从U+D800到U+DFFF</h5><p><code>Unicode</code> 标准规定从 <code>U+D800</code> 到 <code>U+DFFF</code> 的码点不对应任何字符。<br>但是在使用 <code>UCS-2</code> 的时代，这些码点是有对应字符的。因此，只要不构成代理对，许多 <code>UTF-16</code> 编码解码还是会把这些不符合 <code>Unicode</code> 标准的字符映射正确的辨识并转换成合规的码元。<br>但是按照 <code>Unicode</code> 标准来说，这种码元序列本来应该算作是编码错误。</p>
<h5 id="代理对与UTF-16辅助平面编码方式"><a href="#代理对与UTF-16辅助平面编码方式" class="headerlink" title="代理对与UTF-16辅助平面编码方式"></a>代理对与UTF-16辅助平面编码方式</h5><p><code>Unicode</code> 辅助平面中码点，在 <code>UTF-16</code> 中被编码为<strong>一对</strong>16bit的码元（即32位，4字节），称作<em>代理对</em>（<em>Surrogate Pair</em>）。<br>具体方法是：</p>
<ol>
<li>码点减去 <code>0x10000</code>，得到的值的范围为 20 比特长的 <code>0...0xFFFFF</code>。</li>
<li>高位的 10 比特的值（范围为 <code>0...0x3FF</code>）被加上 <code>0xD800</code> 得到第一个码元，称作高位代理（<em>high surrogate</em>），新值的范围是 <code>0xD800...0xDBFF</code>。【由于高位代理比低位代理的值要小，为了避免混淆使用，<code>Unicode</code> 标准现在称高位代理为<strong>前导代理</strong>（<em>lead surrogate</em>）</li>
<li>低位的 10 比特的值（范围也是 <code>0...0x3FF</code>）被加上 <code>0xDC00</code> 得到第二个码元，称作低位代理（<em>low surrogate</em>），新值的范围是 <code>0xDC00...0xDFFF</code>。【由于低位代理比高位代理的值要大，为了避免混淆使用，<code>Unicode</code> 标准现在成低位代理为<strong>后尾代理</strong>（<em>trail surrogate</em>）</li>
</ol>
<p>上述算法可以这样理解：<br>辅助平面中的码点范围是 <code>U+010000</code> 到 <code>U+10FFFF</code>，共计 0xFFFFF 个，即 2<sup>20</sup>个，也就是需要 20 个二进制位来表示。<br>如果用两个 16 位长的整数组成的序列来表示，第一个整数（即前导代理）要容纳 20 位中的前 10 位，第二个整数（即后尾代理）容纳 20 位中的后 10 位。<br>因为 <code>UTF-16</code> 基本平面的字符就是由一个 16 位长的整数表示的，这里的两个 16 位整数序列就需要一个区分标识。<br>一是与基本平面码点的区分，二是前导代理与后尾代理的区分。</p>
<p><strong>与基本平面码点的区分</strong>，就来自于之前讲的 <code>Unicode</code> 保留区段 <code>U+D800...U+DFFF</code>，因为两个整数中只容纳了 20 位中的 10 位二进制数字，也就是最大只有 <code>0x3FF</code>，那么就可以通过给这两个整数增加一个固定数字，使其位于 <code>U+D800...U+DFFF</code> 这个区段内，就可以与基本平面的码点区分开来。</p>
<p><strong>前导代理与后尾代理的区分</strong>，则通过增加不同的数字，使二者落入 <code>U+D800...U+DFFF</code> 区段的不同部分来区分。<br>你会发现，<code>U+D800...U+DFFF</code> 的区间长度是 2047，<code>0x3FF</code> 的十进制是 1023，刚好是区段一半的大小；<br>那么以区段的初始值 <code>U+D800</code> 和中间值 <code>U+DC00</code> 分别作为前导代理和后尾代理增加的值，就可以刚好将两个值分别放入 <code>U+D800...U+DFFF</code> 区间的前半段 <code>U+D800...U+DBFF</code> 和后半段 <code>U+DC00...U+DFFF</code>。</p>
<p>所以，<code>UTF-16</code> 遇到两个字节，码点位于 <code>U+D800...U+DBFF</code> 之间时，就可以断定，后续的两个字节码点位于 <code>U+DC00...U+DFFF</code> 之间，并将这四个字节一起解读为一个字符。</p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p><code>UTF-16</code> 编码是一个很不错的编码方式，因为大部分常用字符都位于基本平面内，也就是使用2字节就可以表示大部分的常用字符。<br>可是也同样是因为使用 2 个字节存储，导致它不能兼容 <code>ASCII</code> 编码。</p>
<p>而 <code>UTF-8</code> 就是一种可以兼容 <code>ASCII</code> 编码的<strong>变长</strong>的 <code>Unicode</code> 的编码实现。</p>
<p><code>UTF-8</code> 是一种针对 <code>Unicode</code> 的可变长度字符编码，也是一种前缀码。<br>它可以用一至四个字节对 <code>Unicode</code> 字符集中的所有有效编码码点进行编码。<br>由于较小值的编码点一般使用频率较高，直接使用 <code>Unicode</code> 编码【此处指<code>UTF-32</code>编码】效率低下，大量浪费内存空间。<br><code>UTF-8</code> 就是为了解决向后兼容 <code>ASCII</code> 码而设计的， <code>Unicode</code> 中前 128 个字符，使用与 <code>ASCII</code> 码相同的二进制值的单个字节进行编码，这使得原来处理 <code>ASCII</code> 字符的软件无需或只需做少部分修改，即可继续使用。<br>也因此，它逐渐成为电子邮件、网页及其他存储或发送文字优先采用的编码方式。</p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><table>
<thead>
<tr>
<th>Unicode 码点</th>
<th>UTF-8 编码</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td><code>U+0000</code> - <code>U+007F</code></td>
<td><code>0xxxxxxx</code></td>
<td><code>ASCII</code> 字符范围，单字节，字节由 <code>0</code> 开始</td>
</tr>
<tr>
<td><code>U+0080</code> - <code>U+07FF</code></td>
<td><code>110xxxxx</code> <code>10yyyyyy</code></td>
<td>双字节字符，第一个字节由 <code>110</code> 开始，后续字节由 <code>10</code> 开始</td>
</tr>
<tr>
<td><code>U+0800</code> - <code>U+D7FF</code>, <code>U+E000</code> - <code>U+FFFF</code></td>
<td><code>1110xxxx</code> <code>10yyyyyy</code> <code>10zzzzzz</code></td>
<td>三字节字符，第一个字节由 <code>1110</code> 开始，后续字节由 <code>10</code> 开始</td>
</tr>
<tr>
<td><code>U+010000</code> - <code>U+10FFFF</code></td>
<td><code>11110xxx</code> <code>10yyyyyy</code> <code>10zzzzzz</code> <code>10wwwwww</code></td>
<td>四字节字符，第一个字节由 <code>11110</code> 开始，后续字节由 <code>10</code> 开始</td>
</tr>
</tbody></table>
<p>从上面的表格中，你应该能够直观的看出来，在 <code>UTF-8</code> 编码中，从一个字节开始的二进制位，就能判断出这个字节的大致位置。</p>
<ol>
<li>如果字节以 <code>0</code> 开始，那么它单独表示一个 <code>ASCII</code> 字符</li>
<li>如果字节以 <code>10</code> 开始，那么它是一个多字节字符的非首字节</li>
<li>如果字节以 <code>110</code> 开始，那么它是一个二字节字符的首字节，且后续会有一个以 <code>10</code> 开头的字节</li>
<li>如果字节以 <code>1110</code> 开始，那么它是一个三字节字符的首字节，且后续会有两个以 <code>10</code> 开头的字节</li>
<li>如果字节以 <code>11110</code> 开始，那么它是一个四字节字符的首字节，且后续会有三个以 <code>10</code> 开头的字节</li>
</ol>
<p>可以很明显的看到，除了前面 128 个字符，跟 <code>ASCII</code> 码保持相同之外，<code>UTF-8</code> 的多字节字符，首字节起始的连续的 1 的数量就是它所占用的字节数，后续字节之所以用 <code>10</code> 开头，也是为了与单字节做区分，避免混淆。</p>
<p>那么 <code>UTF-8</code> 具体是怎么编码的呢？</p>
<ol>
<li>查看字符在 <code>Unicode</code> 的码点所处区间，来确定字节数<ol>
<li><code>U+0000</code> 至 <code>U+007F</code> 一个字节</li>
<li><code>U+0080</code> 至 <code>U+07FF</code> 两个字节</li>
<li><code>U+0800</code> 至 <code>U+FFFF</code> 三个字节</li>
<li><code>U+010000</code> 至 <code>U+10FFFF</code> （即16个辅助平面）四个字符</li>
</ol>
</li>
<li>如果是一个字节，直接使用码点对应的8位二进制码</li>
<li>如果是多字节，那么将码点对应的二进制码，从右到左，一个个填充到上面表格对应字节中的待填充区域【就是表格里的 <code>x</code>,<code>y</code>,<code>z</code>,<code>w</code>的位置】，待右侧填充完毕，如果左侧还有未填充的位置，则统一填 0，就得到了 <code>UTF-8</code> 中对应的二进制码。</li>
</ol>
<p>比如：<code>好</code> 在 <code>Unicode</code> 中的码点是十六进制的 <code>0x597D</code>，落在区间 <code>U+0800</code> - <code>U+FFFF</code> 内，所以在 <code>UTF-8</code> 中表示是三字节：<code>1110xxxx</code> <code>10yyyyyy</code> <code>10zzzzzz</code>。<br><code>0x597D</code> 转成二进制表示是 <code>0b101100101111101</code>，然后从右向左填充，切出最右边的6位 <code>111101</code> 填入第三个字节右侧 6 个 <code>z</code> 的位置，再切出余下的右侧 6 位 <code>100101</code> 填入第二个字节右侧 6 个 <code>y</code> 的位置，余下 3 位 <code>101</code> 填入首字节的最右侧，最后还有一个 <code>x</code> 未填充，补上 0，就得到了 <code>好</code> 字在 <code>UTF-8</code> 中的二进制码 <code>11100101</code> <code>10100101</code> <code>10111101</code>。</p>
<p><img data-src="/images/posts/2020081101.png"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb21pbmd5YW5nL2FydGljbGUvZGV0YWlscy83OTM3NDIwOQ==">https://blog.csdn.net/yaomingyang/article/details/79374209<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMTIvdW5pY29kZS5odG1s">http://www.ruanyifeng.com/blog/2014/12/unicode.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDcvMTAvYXNjaWlfdW5pY29kZV9hbmRfdXRmLTguaHRtbA==">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wZjVmZDkzZWZjNDY=">https://www.jianshu.com/p/0f5fd93efc46<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAxNjk1OTY2MzYwMjQwMC8xMDE3MDc1MzIzNjMyODk2">https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZW5vbmcuY29tLzEwNjExNDU1Lw==">https://www.codenong.com/10611455/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aGFvamkud2FuZy9qYXZhc2NyaXB0LW5vdGUtMS1jaGFyYWN0ZXItZW5jb2Rpbmcv">https://zhaoji.wang/javascript-note-1-character-encoding/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2">https://zh.wikipedia.org/wiki/UTF-16<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTg=">https://zh.wikipedia.org/wiki/UTF-8<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MTIwMjQxMg==">https://zhuanlan.zhihu.com/p/51202412<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>零宽连字符号</title>
    <url>//2021/08/03/%E9%9B%B6%E5%AE%BD%E8%BF%9E%E5%AD%97%E7%AC%A6%E5%8F%B7.html</url>
    <content><![CDATA[<h2 id="零宽连字"><a href="#零宽连字" class="headerlink" title="零宽连字"></a>零宽连字</h2><p>在掘金上看到一篇讲 JavaScript 字符串截取的文章 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTcwNzAwMjYzNDM4">掘金:【JavaScript文本截取】该死的Emoji表情<i class="fa fa-external-link-alt"></i></span>，里面提到了一个组合字符，以前不知道这个知识，初次看到感觉也挺有意思的，顺便在自己做的<span class="exturl" data-url="aHR0cHM6Ly93YXlvd2UuY29tL3JlYWN0L3Rvb2wvdW5pY29kZS1lbnRpdHk=">字符串转 Unicode/HTML 实体<i class="fa fa-external-link-alt"></i></span>的小工具上做了下实验，并把转换后的 HTML 实体字符放入 HTML 内容中实际查看了下结果。</p>
<p>然后我发现在页面上显示的确实是组合字符，但是开发者工具中 <code>Element</code> 栏内，却显示的是两个分开的字符，中间以 <code>&amp;zwj;</code> 连接。而这个中间的连字符我原本应该输入的是 <code>&amp;#8205;</code> 才对。我猜测应该类似于 <code>&amp;lt;</code> <code>&amp;gt;</code> 这些具有名称的实体。所以就搜索了下 <code>&amp;zwj;</code>，然后就在维基百科内找到了 <code>零宽连字</code> 这一条目。</p>
<p>实际看下来，感觉挺有趣的，所以就把这个零宽连字记一下。</p>
<p>根据维基百科的描述，零宽连字就是把前后两个字符组合成一个具有连字效果的字符，当然前提是前后两个字符确实是可以组合的，不然的话并不会出现连字效果。</p>
<p>比如我看到的这篇掘金文章中提到的组合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 👩 + 🦱 = 👩‍🦱</span></span><br><span class="line"><span class="string">&#x27;👩\u200d🦱&#x27;</span> <span class="comment">// 👩‍🦱</span></span><br></pre></td></tr></table></figure>

<p>在 HTML 中也可以这么写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>👩<span class="symbol">&amp;zwj;</span>🦱<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 👩‍🦱 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>👩&zwj;🦱</p>

<p>再比如维基百科上的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 👨 + 👩 + 👦 = 👨‍👩‍👦</span></span><br><span class="line"><span class="string">&#x27;👨\u200d👩\u200d👦&#x27;</span> <span class="comment">// 👨‍👩‍👦</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &amp;zwj; 用码点实体就是 &amp;#8205; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>👨<span class="symbol">&amp;zwj;</span>👩<span class="symbol">&amp;#8205;</span>👦<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 👨‍👩‍👦 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>👨&zwj;👩&#8205;👦</p>

<p>但是如果是本身不具有连字效果的两个字符的话，并不会有什么强加的连字效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Y\u200dY&#x27;</span> <span class="comment">// YY</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Y<span class="symbol">&amp;zwj;</span>Y<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Y&zwj;Y</p>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTcwNzAwMjYzNDM4">掘金:【JavaScript文本截取】该死的Emoji表情<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUI2JUU1JUFFJUJEJUU4JUJGJTlFJUU1JUFEJTk3">Wiki: 零宽连字<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS之BFC</title>
    <url>//2017/07/17/css%E4%B9%8Bbfc.html</url>
    <content><![CDATA[<p>BFC(<em>Block Formatting Context 块级格式化上下文</em>)是一个独立的渲染区域，只有块级元素参与，它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。</p>
<p>直白地说就是：BFC内部的任何布局都不影响其外部区域。</p>
<a id="more"></a>

<p>这样对前端布局来讲会非常的友好，那么哪些元素能产生 BFC 呢？</p>
<p>只要给元素添加如下属性就可以触发 BFC</p>
<ul>
<li><p>float 属性不为 none</p>
</li>
<li><p>position 属性为 absolute 或 fixed</p>
</li>
<li><p>display 为 inline-block、table-cell、table-caption、flex、inline-flex</p>
</li>
<li><p>overflow 不为 visible</p>
</li>
</ul>
<h2 id="BFC-元素所具有的特性"><a href="#BFC-元素所具有的特性" class="headerlink" title="BFC 元素所具有的特性"></a>BFC 元素所具有的特性</h2><ul>
<li>在 BFC 中，盒子从顶端开始垂直地一个接一个地排列。</li>
<li>盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻盒子的margin会发生重叠。</li>
<li>在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左外边缘（border-left），对于从右到左的格式来说，则触碰到右边缘。</li>
<li>BFC 的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</li>
<li>计算 BFC 的高度时，自然也会检测浮动的盒子高度。</li>
</ul>
<h2 id="BFC-的主要用途"><a href="#BFC-的主要用途" class="headerlink" title="BFC 的主要用途"></a>BFC 的主要用途</h2><h3 id="清除元素内部浮动"><a href="#清除元素内部浮动" class="headerlink" title="清除元素内部浮动"></a>清除元素内部浮动</h3><p>只要把父元素设为 BFC 就可以清理子元素的浮动了，最常见的用法就是在父元素上设置 <code>overflow: hidden;</code> 样式，对于 IE6 加上 <code>zoom: 1;</code> 就可以了。</p>
<p>主要用到 BFC 特性之5：<br>计算 BFC 的高度时，自然也会检测浮动的盒子高度</p>
<h3 id="解决外边距合并问题"><a href="#解决外边距合并问题" class="headerlink" title="解决外边距合并问题"></a>解决外边距合并问题</h3><p>主要用到 BFC 特性之2：<br>盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻盒子的margin会发生重叠<br>属于同一个 BFC 的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个 BFC 的盒子，就不会发生margin重叠了。</p>
<h3 id="制作右侧自适应的盒子"><a href="#制作右侧自适应的盒子" class="headerlink" title="制作右侧自适应的盒子"></a>制作右侧自适应的盒子</h3><p>主要用到 BFC 特性之4：<br>BFC 的区域不会与浮动盒子产生交集，而是紧贴浮动边缘<br>普通流体元素 BFC 后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Safari中3D变换的问题</title>
    <url>//2021/07/25/safari%E4%B8%AD3d%E5%8F%98%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="z-index-失效"><a href="#z-index-失效" class="headerlink" title="z-index 失效"></a>z-index 失效</h2><p>在 Safari 浏览器中，使用 3D 变换时，会导致该元素的 z-index 层级设置失效，解决办法有两种：</p>
<ol>
<li>给变换元素的任意父元素添加 <code>overflow: hidden</code> 属性</li>
<li>通过 <code>transform: translateZ()</code> 来设置 Z 轴的距离</li>
</ol>
<h2 id="多个相邻的-3D-变换元素穿模"><a href="#多个相邻的-3D-变换元素穿模" class="headerlink" title="多个相邻的 3D 变换元素穿模"></a>多个相邻的 3D 变换元素穿模</h2><p>在通过 <code>overflow: hidden</code> 解决了 <code>z-index</code> 属性失效的问题后，又发现多个在一起的元素，会出现穿模现象。<br>在 A 与 B 重叠的区域，本该 A 覆盖 B 的情况，却出现了一部分是 A 覆盖 B, 另一部分却是 B 覆盖 A。</p>
<p>暂时未找到解决方式，通过属性 <code>backface-visibility: hidden</code> 能稍微缓解一些这种情况，但依然无法根除。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTYvMDgvc2FmYXJpLTNkLXRyYW5zZm9ybS16LWluZGV4Lw==">https://www.zhangxinxu.com/wordpress/2016/08/safari-3d-transform-z-index/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzE5NDY2NA==">https://zhuanlan.zhihu.com/p/33194664<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】Sass 与 SCSS 的异同</title>
    <url>//2018/01/04/%E3%80%90%E8%BD%AC%E3%80%91sass-%E4%B8%8E-scss-%E7%9A%84%E5%BC%82%E5%90%8C.html</url>
    <content><![CDATA[<p>本篇系转载文章</p>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNTY0NjIwNg==">https://segmentfault.com/a/1190000005646206<i class="fa fa-external-link-alt"></i></span><br>作者：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3UvbXJkcmVhbQ==">MrDream<i class="fa fa-external-link-alt"></i></span></p>
<p>以下是内容：</p>
<h2 id="Sass-与-SCSS-是什么关系？"><a href="#Sass-与-SCSS-是什么关系？" class="headerlink" title="Sass 与 SCSS 是什么关系？"></a>Sass 与 SCSS 是什么关系？</h2><p>2016年06月04日发布</p>
<p>我最近写了很多 Sass 代码，但是最近发现并不是每一个人都知道 Sass 具体是什么。下面是一个简短的说明：</p>
<p>当我们说起 Sass ，我们经常指的是两种事物：一种 css 预处理器和一种语言。我们经常这样说，“我们正在使用 Sass”，或者 “这是一个 Sass mixin”。同时，Sass （预处理器）有两种不同的语法：</p>
<a id="more"></a>
<ul>
<li>Sass,一种缩进语法</li>
<li>SCSS,一种 CSS-like 语法</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>最开始，Sass 是Haml的一部分，Haml 是一种预处理器，由 Ruby 开发者设计和开发。因为这样，Sass 使用类似 Ruby的语法，没有花括号，没有分号，具有严格的缩进，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Variable</span><br><span class="line">!primary-color&#x3D; hotpink</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mixin</span><br><span class="line">&#x3D;border-radius(!radius)</span><br><span class="line">    -webkit-border-radius&#x3D; !radius</span><br><span class="line">    -moz-border-radius&#x3D; !radius</span><br><span class="line">    border-radius&#x3D; !radius</span><br><span class="line"></span><br><span class="line">.my-element</span><br><span class="line">    color&#x3D; !primary-color</span><br><span class="line">    width&#x3D; 100%</span><br><span class="line">    overflow&#x3D; hidden</span><br><span class="line"></span><br><span class="line">.my-other-element</span><br><span class="line">    +border-radius(5px)</span><br></pre></td></tr></table></figure>

<p>你可以就看到，这和CSS代码有很大的区别！即使你是一个 Sass（预处理器） 用户，你也会发现这和你正在使用的有很大的差别。变量的标志用 <code>!</code>，而不是<code>$</code>,分配符是<code>=</code>而不是<code>:</code>。非常怪异。</p>
<p>但是在2010年五月之前，Sass 就是这个样子的。2010年5月，官方推出了一个全新的语法，被叫做 SCSS，意思是 Sassy CSS。这个语法带来了对 CSS 友好的语法，试图弥合 Sass 和 CSS 之间的鸿沟。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Variable</span></span><br><span class="line"><span class="variable">$primary-color</span>: hotpink;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>) &#123;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.my-element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.my-other-element</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> border-radius(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SCSS 和 Sass 相比更加贴近 CSS 语法。也就是说，Sass 维护者做了大量的工作，把缩进语法中的<code>!</code>和<code>=</code>换成了 SCSS 中的 <code>$</code> 和 <code>:</code>。</p>
<p>现在，在开始一个新项目时，你也许疑惑要用哪种语法。让我们来看看两种语法的优劣。</p>
<h3 id="Sass缩进语法的优劣"><a href="#Sass缩进语法的优劣" class="headerlink" title="Sass缩进语法的优劣"></a>Sass缩进语法的优劣</h3><p>虽然语法看起来怪异，但是缩进语法有很多有趣的点。首先，它 更短并且更易于书写。没有花括号，没有分号，你完全不需要这些东西。更好的是，你甚至不需要<code>@mixin</code> 或者 <code>@include</code>, 一个字符就足够了：<code>=</code> 和 <code>+</code>。</p>
<p>同时 Sass 通过严格的缩进来强制 <strong>clean coding standards</strong>。因为一个错误的缩进就会破坏整个.sass文件，这使得整个代码总是clean 和格式良好的。只有一种写 Sass 代码的方式：正确的方式。</p>
<p>但是请注意！缩进在 Sass 中是有意义的。当你缩进了一个元素，这意味这你将它变为了之前元素的子元素。比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.element-a</span><br><span class="line">    color: hotpink</span><br><span class="line"></span><br><span class="line">    .element-b</span><br><span class="line">        float: left</span><br></pre></td></tr></table></figure>

<p>以上会输出下面的 CSS 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element-a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: hotpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.element-a</span> <span class="selector-class">.element-b</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>.element-b</code> 向右一格意味着它变成了 <code>.element-a</code> 的子元素，改变了输出 CSS 代码的结果。所以一定要小心你的代码缩进。</p>
<p>另外，我觉得基于缩进的语法适合于 Ruby/Python 团队，而不适合 PHP/Java 团队。（这是值得商榷的，我也希望听到不同的声音）</p>
<h3 id="SCSS语法的优劣"><a href="#SCSS语法的优劣" class="headerlink" title="SCSS语法的优劣"></a>SCSS语法的优劣</h3><p>对于初学者，SCSS 是完全和 CSS 兼容的，这意味着几乎为零的学习曲线。SCSS语法即是：它只是加了一些功能的 CSS。当你和没经验的开发者一起工作时这很重要：他们可以很快开始编码而不需要首先去学习Sass。</p>
<p>此外，SCSS 还是 <strong>易于阅读</strong> 的，因为它是有语义的，而不是用符号表示。当你读到 <code>@mixin</code>，你就会知道这是一个 mixin 声明；当你看到 <code>@include</code> ，你就是在引用一个 mixin。他并没有用任何缩写，当你大声读出来时所有的都很明了。</p>
<p>还有，现在几乎所有 Sass 的工具，插件和 demo 都是基于 SCSS语法来开发的。随着时间过去，SCSS 会变成大家首选的选择。比如，你现在很难找到一个 Sass 缩进语法的高亮插件，通常都只有 SCSS 的可以用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如何选择取决于你，但是除非你有很好的理由一定要使用缩进的语法，我强烈推荐使用 SCSS 。不仅仅它很简单，同时他也很方便。</p>
<p>最后请注意 Sass 从来没有大写过，无论你指的是语法或者这个语言。同时， SCSS 一直是大写的。甚至有一个网站专门来提醒你这件事! <span class="exturl" data-url="aHR0cDovL3Nhc3Nub3RzYXNzLmNvbS8=">SassnotSASS.com<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>翻译自 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2l0ZXBvaW50LmNvbS93aGF0cy1kaWZmZXJlbmNlLXNhc3Mtc2Nzcy8=">What’s the Difference Between Sass and SCSS?<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>//2018/01/11/css%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content><![CDATA[<p>CSS-*Cascading Style Sheet(层叠样式表)*，给HTML元素添加各种样式的文件。CSS选择器就是用来匹配要添加样式的元素的。</p>
<a id="more"></a>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vY3NzcmVmL2Nzc19zZWxlY3RvcnMuYXNw">W3school<i class="fa fa-external-link-alt"></i></span></p>
<p>按照我个人的理解，将其分为：</p>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8">基础选择器</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8">属性选择器</a></li>
<li><a href="#%E4%BC%AA%E7%B1%BB%E3%80%81%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8">伪类、伪元素选择器</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8">组合选择器</a></li>
</ul>
<h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p>基础选择器就相当于选择器的基础组成部分一样。</p>
<ul>
<li><p>通配符选择器(*)<br>匹配所有的标签，但权重最低(比继承高)</p>
</li>
<li><p>标签(元素)选择器(tag/element)<br>匹配对应的标签。<br><em>tips</em>: 标签就是元素，元素就是标签，不同的叫法而已</p>
</li>
<li><p>类选择器(.class)<br>选择属性<code>class</code>中有对应名称的元素</p>
</li>
<li><p>ID选择器(#id)<br>选择属性<code>id</code>中有对应名称的元素</p>
</li>
</ul>
<p>其实属性选择器应该也可以归为基础选择器，但是因为属性选择器里有多种匹配模式，所以单独提出来了。</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>属性选择器一般都会与其他选择器组合使用。</p>
<ul>
<li><p>[attribute]<br>选择具有<code>attribute</code>属性的元素</p>
</li>
<li><p>[attribute=value]<br>选择具有属性<code>attribute</code>且值为<code>value</code>的元素</p>
</li>
<li><p>[attribute~=value]<br>选择属性<code>attribute</code>中含有单词<code>value</code>的元素</p>
</li>
<li><p>[attribute|=value]<br>选择属性<code>attribute</code>以单词<code>value</code>开头的元素</p>
</li>
<li><p>[attribute*=value]<br>选择属性<code>attribute</code>中包含字符串<code>value</code>的元素</p>
</li>
<li><p>[attribute^=value]<br>选择属性<code>attribute</code>以字符串<code>value</code>开头的元素</p>
</li>
<li><p>[attribute$=value]<br>选择属性<code>attribute</code>以字符串<code>value</code>结尾的元素</p>
</li>
</ul>
<h4 id="attribute-value-与-attribute-value-的区别"><a href="#attribute-value-与-attribute-value-的区别" class="headerlink" title="[attribute~=value]与[attribute*=value]的区别"></a>[attribute~=value]与[attribute*=value]的区别</h4><p><code>[attribute~=value]</code>匹配的是<em>单词</em>，表示的是某个属性attribute的值里有value这个词，而<code>[attribute*=value]</code>匹配的是<em>字符串</em>，表示attribute的值里包含value这串字符。</p>
<p>举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[class~=err]</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[class*=err]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;error&quot;</span>&gt;</span></span><br><span class="line">  错误信息</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;err or&quot;</span>&gt;</span></span><br><span class="line">  另一条</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中<code>[class~=err]</code>并不会选中<code>class=&quot;error&quot;</code>只会选中<code>class=&quot;err or&quot;</code>，而<code>[class*=err]</code>则两个都能选中。</p>
<p>也就是说<code>[attribute~=value]</code>是以<em>单词</em>为度量进行匹配，而<code>[attribute*=value]</code>则以<em>字符串</em>的形式进行匹配，不论是否是完整的一个单词。</p>
<blockquote>
<p>同样的<code>[attribute|=value]</code>与<code>[attribute^=value]</code>的区别也是如此。</p>
</blockquote>
<h3 id="伪类、伪元素选择器"><a href="#伪类、伪元素选择器" class="headerlink" title="伪类、伪元素选择器"></a>伪类、伪元素选择器</h3><p><code>伪类/伪元素</code>就是一种拥有类似<code>类/元素</code>的性质却又不是<code>类/元素</code>的东西。一般的，伪类选择器以<code>:</code>开头，伪元素选择器以<code>::</code>开头。</p>
<blockquote>
<p>伪类、伪元素选择器一般不会单独使用，而是与其他选择器组合在一起使用。</p>
</blockquote>
<ul>
<li><p><code>:before/:after/::before/::after</code></p>
<blockquote>
<p>tips: <code>:before/:after</code>与<code>::before/::after</code>实际上的用法完全相同，之所以一个是伪类一个是伪元素只是不同时期的归类不同而已。<br>早期将其归类为<em>伪类</em>，而后来则归为了<em>伪元素</em>。<br>不过现代浏览器也支持伪类写法，所以如果需要兼容旧版浏览器的话，可以直接以伪类形式书写。<br>另外该选择器有一个必须的样式属性<code>content</code>，否则该选择器不生效。</p>
</blockquote>
<ul>
<li><code>:before/::before</code>在某个元素的内容之前插入</li>
<li><code>:after/::after</code>在某个元素的内容之后插入</li>
</ul>
</li>
<li><p><code>:link/:visited/:active/:hover/:focus</code></p>
<ul>
<li><code>:link</code>用于选择未被访问过的链接</li>
<li><code>:visited</code>用于选择已被访问过的链接</li>
<li><code>:active</code>用于选择活动<strong>元素</strong>(即当前选中的元素，直观点表达就是按下鼠标不松开的状态)</li>
<li><code>:hover</code>用于选择鼠标悬浮于其上的<strong>元素</strong>(即鼠标指针指向的元素)</li>
<li><code>:focus</code>用于选择获得焦点的<strong>可获取焦点的元素</strong>(一般是表单元素和超链接)</li>
</ul>
</li>
<li><p><code>:first-letter/:first-line</code></p>
<ul>
<li><code>:first-letter</code>选择首字母，中文下选择首字</li>
<li><code>:first-line</code>选择首行</li>
</ul>
</li>
<li><p>子元素伪类(需要有父元素)</p>
<ul>
<li><code>:first-child</code>选择首个子元素</li>
<li><code>:last-child</code>选择最后一个子元素</li>
<li><code>:nth-child(n)</code>选择第n个子元素<blockquote>
<p>可以使用数学表达式来选择多个子元素。<br>如：<code>:nth-child(n + 2)</code>选择第2个以后的子元素，<code>nth-child(2n)</code>选择偶数子元素<br>还可以使用负数表示：`nth-child(-n + 2)选择最后两个</p>
</blockquote>
</li>
<li><code>nth-last-child(n)</code>同上，从最后一个开始计数</li>
<li><code>:only-child</code>选择唯一的子元素</li>
<li><code>:first-of-type</code>选择首个(某一类型的)子元素</li>
<li><code>:last-of-type</code>选择最后一个(某一类型的)子元素</li>
<li><code>:nth-of-type(n)</code>选择第n个(某一类型的)子元素</li>
<li><code>:nth-last-of-type(n)</code>同上，从最后一个开始计数</li>
<li><code>:only-of-type</code>选择唯一的(某一类型的)子元素</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>child</code>与<code>of-type</code>的区别：<br><code>child</code>是包含所有子元素进行计算的，<br>而<code>of-type</code>则只包含先通过与其组合的其他选择器匹配后得到的子元素，而非全部子元素。</p>
</blockquote>
<ul>
<li>其他<ul>
<li><code>:root</code>选择根元素，HTML里的根元素就是<code>html</code>标签</li>
<li><code>:lang(language)</code>选择带有以<code>language</code>开头的<code>lang</code>属性值的元素<blockquote>
<p>如：<code>p:lang(it)</code>表示选择带有以<code>it</code>开头的<code>lang</code>属性的p元素</p>
</blockquote>
</li>
<li><code>:empty</code>选择没有子元素(包括文本节点)的元素</li>
<li><code>:target</code>选择当前活动的元素(url中的锚点指向的ID元素)</li>
<li><code>:enabled</code>选择启用的元素</li>
<li><code>:disabled</code>选择禁用的元素</li>
<li><code>:checked</code>选择被选中的元素</li>
<li><code>:not(selector)</code>选择不是selector选中的元素</li>
<li><code>::selection</code>选择被用户选取的元素部分<blockquote>
<p>应用了<code>:first-letter</code>样式的元素，不会应用<code>::selection</code>的样式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>顾名思义，组合选择器就是由两个或多个基础选择器组合成的选择器。</p>
<blockquote>
<p>以下用a, b, … 等表示基础选择器</p>
</blockquote>
<ul>
<li>并集选择器(a, b)</li>
<li>交集选择器(ab)</li>
<li>兄弟选择器(a ~ b)</li>
<li>直接兄弟选择器(a + b)</li>
<li>父子选择器(a &gt; b)</li>
<li>后代选择器(a b)</li>
<li>其他由以上多种选择器进行组合的选择器(a &gt; b c, d + e f ~ g)</li>
</ul>
<blockquote>
<p>注意后代选择器之间是<strong>有空格</strong>的，而交集选择器之间是<strong>没有空格</strong>的<br><code>a ~ b</code>是选择与a元素同级的后面所有的b元素，<br>而<code>a + b</code>则是选择紧跟着a元素后面的b元素，如果a元素后面的元素不是b，则不匹配</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的语句结束符</title>
    <url>//2017/12/16/javascript%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9D%9F%E7%AC%A6.html</url>
    <content><![CDATA[<p>javascript是弱语言，很多方面都没有强语言要求严格。作为语句结束符的<code>;</code>，也是可以省略不写的。但是有些时候，省略之后是会出现问题的，而一个由于 <code>;</code> 引起的问题往往很难找到，所以为了预防这样的问题也好，规范代码的书写也罢，还是养成一个每句代码结束后加上结束符(<code>;</code>)的习惯好。</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a,b,c</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.forEach(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  n *= n;</span><br><span class="line">&#125;)</span><br><span class="line">[b, c] = a</span><br></pre></td></tr></table></figure>

<p>以上代码，乍看之下似乎没什么问题，除了最上面两行的声明与赋值之外，就是将数组a的每一项元素平方操作，然后通过数组解构赋值的方法给变量 <code>b</code> 和 <code>c</code> 分别赋值为数组 <code>a</code> 的前两个元素。</p>
<p>但是运行起来就会发现<br><img data-src="/images/posts/error875ae.png" alt="运行报错"></p>
<p>神马？！居然报错了？！</p>
<p>不要慌，来分析下报错信息：<code>Cannot set property &#39;undefined&#39; of undefined</code> 无法在undefined上设置属性’undefined’。这种错误熟悉不熟悉？</p>
<p>很明显，这种错误一般发生在给对象添加属性，而要添加属性的对象却是一个undefined值的时候。</p>
<p><strong><em>那么问题来了：我们什么时候进行了给对象添加属性的操作了呢？</em></strong></p>
<p>先回想一下，给对象添加属性的方法，最常用的就是点语法了<code>object.someProperty</code> ，另一种则是关联数组语法<code>object[&quot;someProperty&quot;]</code> ，当然，还有其他方法，比如<code>Object.defineProperty()</code> 。</p>
<p>不过这里并不是要讨论这些，在看到关联数组语法的时候，有没有眼前一亮？没错，问题就出在这里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a,b,c</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.forEach(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  n *= n;</span><br><span class="line">&#125;);</span><br><span class="line">[b, c] = a</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/posts/ok11918.png" alt="加上分号就没错了"></p>
<p>那么原因呢？</p>
<p>JavaScript中之所以可以不加语句结束符，是因为你不加，系统会自动帮你加上。但是系统并不能知道你的一条完整语句具体到哪里结束，因此系统只能根据语句是否完整、能否继续等条件来判断。</p>
<p>很显然，<code>a.forEach()</code> 这条遍历语句是完整的；但是在后面的数组解构依然可以跟它连起来成为一条对象属性的赋值语句，因此系统并没有在遍历语句结束时自动地加上语句结束符。</p>
<p>进行步骤的拆解的话，可以这么看，记住任何语句都是有返回值的，所以不妨将<code>a.forEach(...)</code> 赋值一个临时变量，这样就可以更加清晰起来了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp = a.forEach(...);</span><br><span class="line">temp</span><br><span class="line">[b, c] = a</span><br></pre></td></tr></table></figure>

<p>你可能会说，这种情况很少发生的啦。没错，确实很少发生，我也是在前几天做项目的时候才初次遇到这种因为一个分号引起的错误。因为项目中使用了eslint，要求在可以使用解构赋值的情况下，必须使用解构赋值，不然就会报错。然后最初是没有这项强制要求的，而且有些人并不会特意去修改这些不影响实际代码运行的问题。而我在修改了之后才发现了这样的问题。但是我想说的是，除了这种数组解构赋值的情况，真的就没有其他情况了吗？并不是这样的吧。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">+s1  <span class="comment">// 1 =&gt; error</span></span><br><span class="line">+s2  <span class="comment">// 2 =&gt; error</span></span><br><span class="line"><span class="comment">// &#x27;12&#x27; =&gt; right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际运行的是 +s1 + s2 =&gt; 1 + &#x27;2&#x27; =&gt; &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>而且作为一个开发者，养成一个写规范代码的习惯还是很有好处的，至少我是这样认为的。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 添加用户并授权 sudo</title>
    <url>//2018/08/31/centos-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83-sudo.html</url>
    <content><![CDATA[<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dHeGlhb2JhaS9hcnRpY2xlL2RldGFpbHMvNTM1MDQ5ODk=">CentOS 7中添加一个新用户并授权<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="CentOS-7添加用户并授权"><a href="#CentOS-7添加用户并授权" class="headerlink" title="CentOS 7添加用户并授权"></a>CentOS 7添加用户并授权</h1><h2 id="1-创建新用户"><a href="#1-创建新用户" class="headerlink" title="1. 创建新用户"></a>1. 创建新用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">[root@vultr ~]<span class="comment"># adduser suiga</span></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">[root@vultr ~]<span class="comment"># passwd suiga</span></span><br><span class="line">Changing password <span class="keyword">for</span> user suiga.</span><br><span class="line">New password:</span><br><span class="line"><span class="comment"># 初始化密码有复杂度判断，如果过于简单，会有提示</span></span><br><span class="line">BAD PASSWORD: The password is shorter than 7 characters</span><br><span class="line">New password:</span><br></pre></td></tr></table></figure>

<h2 id="2-授权"><a href="#2-授权" class="headerlink" title="2. 授权"></a>2. 授权</h2><p>新创建的用户并不能使用sudo命令，需要给他添加授权。</p>
<p>sudo命令的授权管理是在sudoers文件里的。可以看看sudoers：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># sudoers</span></span><br><span class="line">-bash: sudoers: <span class="built_in">command</span> not found</span><br><span class="line"><span class="comment"># whereis 查找位置</span></span><br><span class="line">[root@vultr ~]<span class="comment"># whereis sudoers</span></span><br><span class="line">sudoers: /etc/sudoers /etc/sudoers.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls -l 查看权限</span></span><br><span class="line">[root@vultr ~]<span class="comment"># ls -l /etc/sudoers</span></span><br><span class="line">-r--r----- 1 root root 3938 Apr 10 20:27 /etc/sudoers</span><br></pre></td></tr></table></figure>

<p>只有只读权限，如果想要修改，需要先添加<code>w</code>权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># chmod -v u+w /etc/sudoers</span></span><br><span class="line">mode of ‘/etc/sudoers’ changed from 0440 (r--r-----) to 0640 (rw-r-----)</span><br></pre></td></tr></table></figure>

<p>然后就可以添加内容了，在下面一行追加新增的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># vi /etc/sudoers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">suiga   ALL=(ALL)       ALL <span class="comment"># 这个是新增的用户</span></span><br></pre></td></tr></table></figure>

<p>保存退出(<code>:x</code>/<code>:wq</code>)，记得将之前加的写入权限收回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># chmod -v u-w /etc/sudoers</span></span><br><span class="line">mode of ‘/etc/sudoers’ changed from 0640 (rw-r-----) to 0440 (r--r-----)</span><br></pre></td></tr></table></figure>

<p>切换新用户，使用sudo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># su suiga</span></span><br><span class="line">[suiga@vultr root]$ sudo cat /etc/passwd</span><br><span class="line"></span><br><span class="line">We trust you have received the usual lecture from the <span class="built_in">local</span> System</span><br><span class="line">Administrator. It usually boils down to these three things:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#1) Respect the privacy of others.</span></span><br><span class="line">    <span class="comment">#2) Think before you type.</span></span><br><span class="line">    <span class="comment">#3) With great power comes great responsibility.</span></span><br><span class="line"></span><br><span class="line">[sudo] password <span class="keyword">for</span> suiga:</span><br></pre></td></tr></table></figure>

<p>第一次使用会有提示，且需要输入用户密码，如果想不需要输入密码，可以将之前设置的最后一个<code>ALL</code>改为<code>NOPASSWD: ALL</code>。</p>
<h1 id="删除用户密码、禁止登陆"><a href="#删除用户密码、禁止登陆" class="headerlink" title="删除用户密码、禁止登陆"></a>删除用户密码、禁止登陆</h1><h2 id="删除密码"><a href="#删除密码" class="headerlink" title="删除密码"></a>删除密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo passwd --delete &lt;username&gt;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sudo passwd -d &lt;username&gt;</span><br></pre></td></tr></table></figure>

<p>没有密码就无法登录，对于有些不应该有密码、不允许登录的账户就可以这样来禁止。</p>
<p>还有一种更安全的方式，设置用户为nologin。</p>
<h2 id="设置用户为-nologin"><a href="#设置用户为-nologin" class="headerlink" title="设置用户为 nologin"></a>设置用户为 nologin</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -s /sbin/nologin &lt;username&gt;</span><br></pre></td></tr></table></figure>

<p>可以结合两种方式来禁止用户的登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo passwd -d &lt;username&gt;</span><br><span class="line">$ sudo usermod -s /sbin/nologin &lt;username&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 添加环境变量的方法</title>
    <url>//2019/03/03/linux-%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>在 Linux 服务器上使用 NodeJS 时，明明通过 <code>npm install --global</code> 进行了包的全局安装，可是安装完了之后却发现在命令行里还是无法使用。<br>原因就是没有将其加入环境变量。</p>
<p>我的 node 包目录为 <code>~/node-v10.9.0-linux-x64/bin/</code>，<br>那么可以通过如下三种方式来把这个目录加入环境变量。</p>
<h2 id="1-直接在命令行通过-export-命令加入"><a href="#1-直接在命令行通过-export-命令加入" class="headerlink" title="1. 直接在命令行通过 export 命令加入"></a>1. 直接在命令行通过 export 命令加入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls ~/node-v10.9.0-linux-x64/bin/</span><br><span class="line">node  npm  npx  pm2  pm2-dev  pm2-docker  pm2-runtime  yarn  yarnpkg</span><br><span class="line">$ npx -v</span><br><span class="line">-bash: npx: <span class="built_in">command</span> not found</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/usr/<span class="built_in">local</span>/sbin:/usr/sbin:/home/suiga/.<span class="built_in">local</span>/bin:/home/suiga/bin</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/node-v10.9.0-linux-x64/bin/</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/usr/<span class="built_in">local</span>/sbin:/usr/sbin:/home/suiga/.<span class="built_in">local</span>/bin:/home/suiga/bin:/home/suiga/node-v10.9.0-linux-x64/bin/</span><br><span class="line">$ npx -v</span><br><span class="line">6.8.0</span><br></pre></td></tr></table></figure>

<p>这种方式添加起来确实快捷，添加后直接就能使用。但是注销重新登录后，你会发现之前加入的环境变量没有了。<br>也就是说这种方式属于临时性添加的。</p>
<p>想要永久的添加还是需要使用下面的方式。</p>
<h2 id="2-修改-etc-profile-文件"><a href="#2-修改-etc-profile-文件" class="headerlink" title="2. 修改 /etc/profile 文件"></a>2. 修改 /etc/profile 文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/profile</span><br><span class="line"><span class="comment"># 在文件中加入</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:~/node-v10.9.0-linux-x64/bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注销重新登录后生效</span></span><br></pre></td></tr></table></figure>

<h2 id="3-修改-bashrc-文件"><a href="#3-修改-bashrc-文件" class="headerlink" title="3. 修改 .bashrc 文件"></a>3. 修改 .bashrc 文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi ~/.bashrc <span class="comment"># 或者 sudo vi /root/.bashrc</span></span><br><span class="line"><span class="comment"># 在文件中加入</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:~/node-v10.9.0-linux-x64/bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样需要先注销才能生效</span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考链接：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYW1ib3luYS9hcmNoaXZlLzIwMDgvMDMvMDgvMTA5NjAyNC5odG1s">在Linux里设置环境变量的方法（export PATH） - 玉米疯收 - 博客园<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令行操作多个文件</title>
    <url>//2019/02/21/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> | xargs -I &#123;&#125; cp &#123;&#125; ./target/</span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> | xargs -I &#123;&#125; mv &#123;&#125; ./target/</span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> | xargs -I &#123;&#125; rm &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>这里主要是通过 <em>find</em> 和 <em>xargs</em> 命令配合使用。</p>
<p><em>find</em> 来根据范本样式查找需要操作的文件，<br>命令为 <code>find &lt;查找目录&gt; -name &lt;范本样式&gt;</code> 。</p>
<p><code>|</code> 是管道，负责将前面的输出作为后面的输入。</p>
<p><em>xargs</em> 命令负责将输入流转换成命令行参数，<br><code>xargs -I [替换字符串]</code> 使用 <code>-I</code> 选项指定一个替换字符串，<br>如果省略替换字符串，则默认使用 <code>&#123;&#125;</code> 。<br>这个字符串在后面使用时会被依次替换成输入流转换的参数。</p>
<hr>
<p>参考资料</p>
<p><span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC9maW5k">find命令<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC94YXJncw==">xargs命令<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在Mac的终端添加命令别名的方法</title>
    <url>//2020/07/13/%E5%9C%A8mac%E7%9A%84%E7%BB%88%E7%AB%AF%E6%B7%BB%E5%8A%A0%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>第一次使用 Mac 电脑，在配置一些自定义的命令时遇到了问题。</p>
<p>在网上搜索好些都是说直接在 <code>~/.bashrc</code> 或者 <code>~/.bash_profile</code> 文件中写入配置就行，可是这样并不能解决问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.bash_profile</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&quot;ls -alFG&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># command line</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>上面这种做法和直接在终端上输入 <code>alias ll=&quot;ls -alFG&quot;</code> 的结果一样，都是只能在当前进程起效果，结束进程，再启动一个终端进程，就没有 <code>ll</code> 这个别名了。</p>
<p>后来终于找到了一篇记录博客，提到使用的 <code>zsh</code>，我才恍然。</p>
<p>最开始打开 Mac 上的终端时，title 里是有显示 <code>zsh</code> 的，只是我以前没听过 <code>zsh</code>，不清楚这是什么意思。原来它就类似 <code>bash</code> 这样是一个命令行程序，也就是说 Mac 默认使用的命令行程序不是 <code>bash</code> 而是 <code>zsh</code>。也因此并不会在启动时运行 <code>~/.bash_profile</code> 文件，运行的是 <code>~/.zshrc</code>。</p>
<p>如此只需在 <code>~/.zshrc</code> 文件中引入 <code>~/.bash_profile</code> 文件运行一次就能解决了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.zshrc</span></span><br><span class="line"><span class="comment"># 当有 ~/.bash_profile 文件时，才加载这个文件</span></span><br><span class="line"><span class="built_in">test</span> -f ~/.bash_profile &amp;&amp; <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>之后在 <code>~/.bash_profile</code> 文件中添加的别名就可以安心使用了。</p>
<p>参考资料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE5ODA5OTQvYXJ0aWNsZS9kZXRhaWxzLzc3OTQwMzc5">CSDN-fool宋-Mac下配置alias，zsh终端命令别名<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序踩坑之 swiper 组件</title>
    <url>//2018/12/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E4%B9%8B-swiper-%E7%BB%84%E4%BB%B6.html</url>
    <content><![CDATA[<p>之前小程序测试出来一个bug。在管理车型页面删除一辆车型后，在点击第一辆车型返回到车型档案页时，最上面的车型卡片消失了。</p>
<p>找来找去没找到问题根源，只知道原因出现在 <code>swiper</code> 组件上。</p>
<p>在返回的时候，明明设置了 swiper 组件的 <code>current</code> 属性为 0，可是查看元素发现显示的是 <code>-1</code>。</p>
<a id="more"></a>
<p>到处找代码逻辑，修修改改，最后测试似乎没复现了，可是为什么好的？还是不知道。</p>
<p>本来就这样的话，估计也就放着不动了，可是在今天要上线的时候，居然又出现了这个情况！</p>
<p>好吧，只能继续找问题了。</p>
<p>经过一段艰辛的排查，最后发现，问题可能出现在 <code>swiper-item</code> 组件的一个属性上：<code>item-id</code></p>
<p>微信文档对它的描述是：</p>
<blockquote>
<p>swiper-item</p>
<p>仅可放置在 <code>&lt;swiper&gt;</code> 组件中，宽高自动设置为100%。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
<th>最低版本</th>
</tr>
</thead>
<tbody><tr>
<td>item-id</td>
<td>String</td>
<td>“”</td>
<td>该 swiper-item 的标识符</td>
<td>1.9.0</td>
</tr>
</tbody></table>
</blockquote>
<p>而我的项目里的 <code>swiper-item</code> 就添加了该属性，值为车型id。</p>
<p>而问题也正出现在这里。</p>
<p>当我在车型管理页面删除了车型之后，返回前一页时，虽然重新调用接口获取了新的车型列表，<br>新列表与旧列表不是同一个对象，可内部数据id，同一辆车还是一样的，这就导致了<code>swiper-item</code>的标识其实并没有改变，然后其中被标识的<code>swiper-item</code>找不到了。</p>
<p>大概就是这样导致的 <code>current=&quot;-1&quot;</code> 这样的问题。</p>
<p>之后删除了 <code>item-id</code> 属性后，问题解决了。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>在 NodeJS 终端输出有简单样式的文本内容</title>
    <url>//2020/07/25/%E5%9C%A8-nodejs-%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E6%9C%89%E7%AE%80%E5%8D%95%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9.html</url>
    <content><![CDATA[<blockquote>
<p>To: 想要在 <code>NodeJS</code> 终端输出醒目颜色文本的同学，并且你不希望引入如: <code>chalk</code>, <code>colors</code> 等第三方包。</p>
</blockquote>
<p>如果你是上面这样的情况，或者说虽然不是这样，但是也想了解一下的话，那就继续看下去吧~。</p>
<h3 id="如何输出醒目颜色的文本"><a href="#如何输出醒目颜色的文本" class="headerlink" title="如何输出醒目颜色的文本"></a>如何输出醒目颜色的文本</h3><p>首先你要安装了 <code>node</code>，（😁）毕竟这是针对 <code>NodeJS</code> 的终端输出记录嘛。<br>当然这个过程中我也查到了直接在 bash 终端输出颜色的方法，如果你用的<strong>不是</strong> <em>Windows</em> 的话，也可以直接看<a href="#Linux-Mac-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2">Linux/Mac 终端输出颜色</a>。</p>
<p>如果你已经安装了 <code>node</code>，那么可以试一下直接在 <code>REPL</code> 中输入以下脚本来查看效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\x1b[1;35mCongratulations!🎉 \x1b[32mYou do it!\x1b[0m&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>REPL</code>: <em>Read-Eval-Print-Loop</em>, <code>NodeJS</code>的可交互运行环境, 直接在命令行输入 <code>node</code> 敲击回车键即可进入, 要退出时, 可输入 <code>.exit</code> 敲击回车键。</p>
</blockquote>
<p>如果你看到输出了: <code><font color="#f0f">Congratulations!🎉 </font><font color="#0f0">You do it!</font></code><br><em>洋红色</em>的 <code>Congratulations</code> 和<em>绿色</em>的 <code>You do it</code>，那么就算初步成功了。</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>你可能会注意到，脚本输出的内容跟 <code>console.log</code> 的参数有点不一样，这不一样的地方，就是 <code>XTerm</code> 控制序列（<code>XTerm Control Sequences</code>）。</p>
<p>但是你可能并不关心这些，所以我把这部分内容放到了后面。你可以直接查看最关心的内容，也就是都有哪些样式可以设置，以及如何设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\x1b[0m: 默认样式，也可以将设置的其他样式重置为默认。</span><br><span class="line">\x1b[1m: 加粗、明亮</span><br><span class="line">\x1b[2m: 暗淡、半透明【亮度减半】</span><br><span class="line">\x1b[3m: 斜体</span><br><span class="line">\x1b[4m: 下划线</span><br><span class="line">\x1b[5m: 闪烁【xterm不能识别闪烁或者不可见模式】</span><br><span class="line">\x1b[7m: 颜色反转【前景色和背景色反过来】【前景色就是指文本颜色】</span><br><span class="line">\x1b[8m: 不可见【xterm不能识别闪烁或者不可见模式】</span><br><span class="line">\x1b[9m: 中划线【就是删除线了】</span><br><span class="line"></span><br><span class="line"># 你应该能看出来 \x1b[ 和 m 是固定的开始和结束</span><br><span class="line"># 所以下面我就只写中间的数字了，【偷个懒😋】</span><br><span class="line"></span><br><span class="line">21: 双下划线【ECMA-48 第三版，但是xterm的属性与 ECMA-48 不兼容，是显示正常亮度，同下面的 22】</span><br><span class="line">22: 正常亮度，用来取消加粗和暗淡，也就是取消 1 和 2</span><br><span class="line">23: 非斜体，用来取消 3</span><br><span class="line">24: 非下划线，用来取消 4</span><br><span class="line">25: 稳定，非闪烁，用来取消 5</span><br><span class="line">27: 正常的，非反的，用来取消 7</span><br><span class="line">28: 可见的，用来取消 8</span><br><span class="line">29: 非划线的，用来取消 9</span><br><span class="line"># 嗯，很明显，2x 是用来取消某些样式的</span><br><span class="line"># 而且除了 22 是取消 1 和 2，其他的取消也都是一一对应的</span><br><span class="line"></span><br><span class="line">30: 黑色前景 (Black)</span><br><span class="line">31: 红色前景 (Red)</span><br><span class="line">32: 绿色前景 (Green)</span><br><span class="line">33: 黄色前景 (Yellow)</span><br><span class="line">34: 蓝色前景 (Blue)</span><br><span class="line">35: 洋红色前景 (Magenta)</span><br><span class="line">36: 青色前景 (Cyan)</span><br><span class="line">37: 白色前景 (White)</span><br><span class="line">39: 默认前景 (default)</span><br><span class="line"># 3x 就是用来设置前景颜色，也就是文本颜色的</span><br><span class="line"></span><br><span class="line">40: 黑色背景 (Black)</span><br><span class="line">41: 红色背景 (Red)</span><br><span class="line">42: 绿色背景 (Green)</span><br><span class="line">43: 黄色背景 (Yellow)</span><br><span class="line">44: 蓝色背景 (Blue)</span><br><span class="line">45: 洋红色背景 (Magenta)</span><br><span class="line">46: 青色背景 (Cyan)</span><br><span class="line">47: 白色背景 (White)</span><br><span class="line">49: 默认背景 (default)</span><br><span class="line"># 4x 可以设置背景色，且颜色值与前景色一一对应</span><br></pre></td></tr></table></figure>

<blockquote>
<p>想要混合起来的话，只需要把数字用 <code>;</code> （分号）分隔开放入 <code>\x1b[</code> 和 <code>m</code> 之间即可。就像最开始示例中的 <code>\x1b[1;35m</code>，<br>当然你也可以完整的一个一个来，比如 <code>\x1b[1m\x1b[35m</code>，如果你不嫌麻烦的话。</p>
</blockquote>
<h3 id="更多的颜色"><a href="#更多的颜色" class="headerlink" title="更多的颜色"></a>更多的颜色</h3><p>想要更多的颜色展示？16位颜色支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">90~97: 对应着 30~37，也是设置一样的前景色，不同的是这个的颜色更加亮一些</span><br><span class="line">100~107: 对应 40~47，设置亮一些的背景色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的系统支持的话，其实 <code>90~97</code> 的颜色和 <code>30~37;1</code> 的颜色基本是一样的，这就是最开始说 <code>1</code> 有加粗，也有明亮的作用。<br>如果同时设置 <code>1</code> 和 <code>2</code> 会怎么样？加粗+明亮+半透明，或许不同的终端效果会不一样？也许你应该自己动手试一下。</p>
</blockquote>
<p>如果你的终端还支持 88 或 256 位颜色的话，你甚至可以设置 rgb 颜色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 38;2;r;g;b 使用rgb设置前景色</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\x1b[38;2;255;165;0mOrange Text\x1b[0m&#x27;</span>);</span><br><span class="line"><span class="comment">// 38;5;index 使用颜色索引设置前景色 索引值范围 0 ~ 255</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\x1b[38;5;215mOrange Text\x1b[0m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 背景色类似前景色，只需要把 38 改成 48 即可</span></span><br><span class="line"><span class="comment">// 48;2;r;g;b 使用rgb设置背景色</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\x1b[48;2;255;165;0mOrange Background\x1b[0m&#x27;</span>);</span><br><span class="line"><span class="comment">// 48;5;index 使用颜色索引设置背景色 索引值范围 0 ~ 255</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\x1b[48;5;215mOrange Background\x1b[0m&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Linux-Mac-终端命令行输出颜色"><a href="#Linux-Mac-终端命令行输出颜色" class="headerlink" title="Linux/Mac 终端命令行输出颜色"></a>Linux/Mac 终端命令行输出颜色</h3><p>其实在 Linux 和 Mac 的终端命令行工具中输出带颜色的文本，和上面讲述的在 <code>NodeJS</code> 中输出几乎是一样的做法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;\x1b[42;37mGreen Background &amp; White Text\x1b[0m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Mac (zsh) 的同学甚至连 -e 参数都可以不要</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;\x1b[42;37mGreen Background &amp; White Text\x1b[0m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用 printf</span></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;\x1b[1;37;41mAlert\x1b[0m\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实开头的转义字符可以使用别的</span></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;\033[1;37;42m The number 033 in octal equals 0x1b in hexadecimal. \033[0m\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你甚至可以使用 `\e` 来代替（但这在 NodeJS 中行不通）</span></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;\e[3;36m Backslash+e means invisible character ESC. \e[0m\n&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows 实在没办法，<br>如果你只是想要更改整个控制台的颜色，那么倒还是有一个方法的。<br>Windows 里有个 color 命令，可以来变更控制台的输出颜色。<br>你可以运行 <code>color /?</code> 来查看具体命令<br>这里也给你列出来了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ color /?</span><br><span class="line"></span><br><span class="line">设置默认的控制台前景和背景颜色</span><br><span class="line">COLOR [attr]</span><br><span class="line"></span><br><span class="line">  attr        指定控制台输出的颜色属性</span><br><span class="line"></span><br><span class="line">颜色属性由两个十六进制数字指定 __ 第一个对应于背景，第二个对应于前景。</span><br><span class="line">每个数字可以为以下任何值：</span><br><span class="line"></span><br><span class="line">    0 = 黑色        8 = 灰色</span><br><span class="line">    1 = 蓝色        9 = 淡蓝色</span><br><span class="line">    2 = 绿色        A = 淡绿色</span><br><span class="line">    3 = 浅绿色      B = 淡浅绿色</span><br><span class="line">    4 = 红色        C = 淡红色</span><br><span class="line">    5 = 紫色        D = 淡紫色</span><br><span class="line">    6 = 黄色        E = 淡黄色</span><br><span class="line">    7 = 白色        F = 亮白色</span><br><span class="line"></span><br><span class="line">如果没有给定任何参数，此命令会将颜色还原到 CMD.EXE 启动时的颜色。</span><br><span class="line">这个值来自当前控制台窗口、/T 命令行开关或 DefaultColor 注册表值。</span><br><span class="line"></span><br><span class="line">如果尝试使用相同的前景和背景颜色来执行 COLOR 命令，</span><br><span class="line">COLOR 命令会将 ERRORLEVEL 设置为 1.</span><br><span class="line"></span><br><span class="line">示例：<span class="string">&quot;COLOR fc&quot;</span> 在亮白色上产生淡红色</span><br></pre></td></tr></table></figure>

<h3 id="控制序列"><a href="#控制序列" class="headerlink" title="控制序列"></a>控制序列</h3><p>看过了上面的内容之后，让我们看看控制序列。</p>
<blockquote>
<p>当一个字符在通过字符映射表转换之前含有以下14个代码之一的时候表明它是一个控制字符.<br><code>00(NUL)</code>, <code>07(BEL)</code>, <code>08(BS)</code>, <code>09(HT)</code>, <code>0a(LF)</code>, <code>0b(VT)</code>,  <code>0c(FF)</code>, <code>0d(CR)</code>, <code>0e(SO)</code>, <code>0f(SI)</code>, <code>18(CAN)</code>, <code>1a(SUB)</code>,  <code>1b(ESC)</code>, <code>7f(DEL)</code>.<br>我们可以通过设置 <code>显示控制字符</code> 模式以允许 <code>07</code>, <code>09</code>, <code>0b</code>, <code>18</code>,<code>1a</code>, <code>7f</code> 像普通字符一样显示在屏幕上.<br>另一方面,在 <code>UTF-8</code> 模式下所有位于 <code>00-1f</code> 之间的代码都被认为是控制字符,而不管是否处于 <code>显示控制字符</code> 模式.</p>
<p>一个控制字符会立刻生效,然后被丢弃(即使是在转义序列中间), 之后转义序列才继续处理下一个字符. (在任何情况下, <code>ESC</code> 都表示一个新的转义序列的开始,可能导致 前一个序列的非正常终止, <code>CAN</code> 和 <code>SUB</code> 终止任何转义序列.) 可识别的控制字符是<code>BEL</code>, <code>BS</code>, <code>HT</code>, <code>LF</code>, <code>VT</code>, <code>FF</code>, <code>CR</code>, <code>SO</code>, <code>SI</code>, <code>CAN</code>, <code>SUB</code>, <code>ESC</code>, <code>DEL</code>, <code>CSI</code>.他们的功能如下.:</p>
</blockquote>
<pre><code>BEL(0x07,^G)铃声;
BS(0x08,^H)后退一格(在行首不起作用);
HT(0x09,^I)跳至下一个制表位.如果后面已没有制表位则跳至行尾;
LF(0x0A,^J),VT(0x0B,^K),FF(0x0C,^L)三者都表示换行;
CR(0x0D,^M)回车并换行;
SO(0x0E,^N)激活 G1 字符集, 如果设置了 LF/NL(新行模式)还要加上回车换行;
SI(0x0F,^O)激活 G0 字符集;
CAN(0x18,^X),SUB(0x1A,^Z)两者都表示中断转义序列;
ESC(0x1B,^[)开始一个新的转义序列;
DEL(0x7F)忽略;
CSI(0x9B)等同于 ESC [;</code></pre>
<p>而这里要讲的控制序列，其实就是 <code>ESC [</code>。</p>
<p><code>ESC</code> 在 ASCII 码中属于不可见字符，其十进制码点是 <code>27</code>，转换为十六进制就是 <code>0x1b</code>，当然你也可以用八进制来表示为 <code>033</code>。</p>
<p>这就是上面提到也可以用 <code>\033</code> 来代替 <code>\x1b</code> 的原因。</p>
<p>同时，你也可以在 <code>node</code> 的 <code>REPL</code> 中尝试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\033[1;35mCongratulations!🎉 \033[32mYou do it!\033[0m&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CSI Sequence (CSI 序列)<br>CSI(即 <code>ESC [</code>)序列的动作由其最后一个字符决定，而 <code>m</code> 则是 SGR(<em>Set Graphics Rendition</em>, 设置图形属性)。<br>所以我们完整的控制序列就是 <code>ESC [ &lt;parameters&gt; m</code></p>
</blockquote>
<h3 id="颜色索引值"><a href="#颜色索引值" class="headerlink" title="颜色索引值"></a>颜色索引值</h3><p>上面提到了通过颜色索引值来设置颜色，那么如何确定不同的索引值，具体对应的是什么颜色呢？</p>
<ol>
<li><p><code>0 ~ 7</code> 是默认使用的终端颜色，在 RGB 标准化之前就经常被设置使用，它就对应了前景色/背景色的 <code>0 ~ 7</code>，黑/红/绿/黄/蓝/洋红/青/白。</p>
</li>
<li><p><code>8 ~ 15</code> 则是对应 <code>0 ~ 7</code> 的明亮色，也可以说对应着 <code>90~97</code> 与 <code>100~107</code>。</p>
</li>
<li><p><code>16 ~ 231</code> 是 RGB 颜色，这 216 个颜色由 <code>R</code>, <code>G</code>, <code>B</code> 三个轴上各 6 个值来确定，也就是把原本的 <code>0 ~ 255</code> 的区间，缩小为 <code>0 ~ 5</code> 的区间，然后由公式 <code>number = 16 + 36 * r + 6 * g + b</code> 来计算出颜色索引值。</p>
</li>
<li><p><code>232 ~ 255</code>，是从暗到亮的 24 中灰度颜色，232是黑色，255是白色</p>
</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><p><span class="exturl" data-url="aHR0cDovL2p1c3RuZXdiZWUuZ2l0aHViLmlvL2Zyb250ZW5kLzIwMTQvMTIvMTcvbm9kZWpzLWNvbG9yZnVsLWNvbnNvbGUuaHRtbA==">nodejs-colorful-console<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcndhbGwuY29tL3AveXBoeXdnL3ByaW50aW5nLWNvbG9yZnVsLXRleHQtaW4tdGVybWluYWwtd2hlbi1ydW4tbm9kZS1qcy1zY3JpcHQ=">printing-colorful-text-in-terminal-when-run-node-js-script<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXkvYXJ0aWNsZS9kZXRhaWxzLzUwNTU2Njky">Linux命令行颜色<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9xYXN0YWNrLmNuL3N1cGVydXNlci8xNTg3NTkvcmVzZXQtY29sb3JzLW9uLXdpbmRvd3MtY29tbWFuZC1saW5lLWNtZA==">reset-colors-on-windows-command-line-cmd<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9xYXN0YWNrLmNuL3VuaXgvMTE2MjQzL3doYXQtZG9lcy1hLWJhc2gtc2VxdWVuY2UtMDMzOTk5ZC1tZWFuLWFuZC13aGVyZS1pcy1pdC1leHBsYWluZWQ=">what-does-a-bash-sequence-033999d-mean-and-where-is-it-explained<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQVNDSUk=">wiki:ASCII<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbA==">xterm:ctlseqs<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbCNoMi1DMS1fOC1CaXRfLUNvbnRyb2wtQ2hhcmFjdGVycw==">xterm:8-bit-Control-Characters<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbCNoNC1GdW5jdGlvbnMtdXNpbmctQ1NJLV8tb3JkZXJlZC1ieS10aGUtZmluYWwtY2hhcmFjdGVyLWxwYXJlbi1zLXJwYXJlbjpDU0ktUG0tbS4xQ0E3">xterm:CSI-Pm-m<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMDQ4LnBkZg==">ECMA-48<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjcxNTkzMjIvcmdiLXZhbHVlcy1vZi10aGUtY29sb3JzLWluLXRoZS1hbnNpLWV4dGVuZGVkLWNvbG9ycy1pbmRleC0xNy0yNTUjYW5zd2Vycy1oZWFkZXI=">stackoverflow:colors-index<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzQyNTc4NjkvYmxvZy8zNDg5NTUx">Linux 控制终端转义和控制序列（转自下面那条）<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmFud2Vpc2hlbmcvcC8xMTA3Njk4Ny5odG1s">Linux 控制终端转义和控制序列<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab创建定时任务</title>
    <url>//2019/12/11/crontab%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html</url>
    <content><![CDATA[<h2 id="etc-crontab"><a href="#etc-crontab" class="headerlink" title="/etc/crontab"></a><code>/etc/crontab</code></h2><p>在 Linux 服务器中创建定时任务，可以在 <code>/etc/crontab</code> 文件中设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/crontab</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br><span class="line"></span><br><span class="line">  00 00 1  *  * root <span class="built_in">echo</span> <span class="string">&quot;test crontab&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>首先来看最上面的几行内容：</p>
<p><code>SHELL</code> 设置了定时任务运行的终端<br><code>PATH</code> 设置了定时任务运行时的环境<br><code>MAILTO</code> 设置的是任务运行结束后发送邮件给谁<br><code>HOME</code> 则是设置当前的主页目录</p>
<p>需要注意的一个地方在于 <code>PATH</code>，定时任务的环境配置和手动运行某个命令时的环境配置并不一定是一样的。<br>有时候你会发现一个命令，自己手动运行时没有问题，可是放在定时任务里运行却报错误说“找不到某某命令”，原因很可能就是这个命令不再这里的 <code>PATH</code> 中。</p>
<h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><p>然后就是设置具体的定时任务：</p>
<p>就像文件注释中给出的提示一样，每一行就是一个定时任务；其中前五个参数是设置定时任务的时间，接着是运行命令的用户，最后则是运行任务的命令。</p>
<p>第一个参数表示分钟：你可以设置 0 - 59，意味着在一个小时的具体某分运行任务；<br>第二个参数表示小时：区间为 0 - 23，分别表示在具体某个时点运行任务，比如设置为 23，意思就是在晚上11点运行定时任务；<br>第三个参数表示月份的天数：取值范围是 1 - 31，也就是说只有在每个月某一日运行；<br>第四个参数是月份：范围区间 1 - 12，或者是月份英文的前三个字母缩写，表示只在某个月份执行任务；<br>第五个参数表示星期：范围是 0 - 6，<strong>注意这里的 0 是指的周日</strong>，同样可以用英文前三个字母的缩写表示，意思就是只在每周的固定哪一天执行。</p>
<p>像上面的示例: <code>00 00 1 * * root echo &quot;test crontab&quot;</code>，就是在每个月的1号，在终端输出一串字符 <code>test crontab</code></p>
<h3 id="高级一点的用法"><a href="#高级一点的用法" class="headerlink" title="高级一点的用法"></a>高级一点的用法</h3><p>除此以外，还有高级一点的用法，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分别在 1/4/7/10 月份的 1/11/21 号 输出一下日期</span></span><br><span class="line">0 0 1,11,21 1,4,7,10 * root <span class="built_in">echo</span> `date +%x`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 5 分钟执行一次</span></span><br><span class="line">*/5 * * * * root &lt;<span class="built_in">command</span> whatever you want&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个周末的 1 点到 6 点的 30 分执行</span></span><br><span class="line">30 1-6 * * 0,6 root &lt;just <span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<br>你可能会突发奇想的设置一个类似这样的定时参数 <code>0 23 24 12 0,6</code>。<br>你以为它应该在 12 月 24 日并且这一天还是周末的情况下执行任务；<br>但是遗憾的是这样不行，它可能会分别在 12 月 24 日和周末时执行<br>周和日月不能并存。</p>
</blockquote>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>除了直接编辑 <code>/etc/crontab</code> 文件之外，还可以通过 <code>crontab -e</code> 命令来编辑设定定时任务。</p>
<p>这里的设置和 <code>/etc/crontab</code> 的不同之处在于 <code>crontab -e</code> 命令设置的定时任务中，没有 <code>user</code> 参数。<br>因为 <code>crontab</code> 就是针对用户级别的，也就是说 <code>crontab -e</code> 命令设置的定时任务中的 <code>user</code> 就是运行 <code>crontab -e</code> 命令时的用户。<br>除此之外，其他与 <code>/etc/crontab</code> 文件一样。</p>
<h3 id="crontab的参数"><a href="#crontab的参数" class="headerlink" title="crontab的参数"></a>crontab的参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [-u username] [-l|-e|-r]</span><br><span class="line"><span class="comment"># 选项与参数：</span></span><br><span class="line"><span class="comment"># -u：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作排程；</span></span><br><span class="line"><span class="comment"># -e：编辑 crontab 的工作内容</span></span><br><span class="line"><span class="comment"># -l：查阅 crontab 的工作内容</span></span><br><span class="line"><span class="comment"># -r：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGQ1MDJkamovcC80MjkyNzgxLmh0bWw=">https://www.cnblogs.com/xd502djj/p/4292781.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3ZiaXJkLmRpYy5rc3UuZWR1LnR3L2xpbnV4X2Jhc2ljLzA0MzBjcm9uXzMucGhw">http://vbird.dic.ksu.edu.tw/linux_basic/0430cron_3.php<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9jcm9udGFi">https://baike.baidu.com/item/crontab<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2dqdWNoZW5nL2FyY2hpdmUvMjAxMi8wOC8xOS8yNjQ2NzYzLmh0bWw=">https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646763.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>忘记了 MySQL 8.0 密码, 如何重置</title>
    <url>//2019/11/28/%E5%BF%98%E8%AE%B0%E4%BA%86-mysql-8-0-%E5%AF%86%E7%A0%81-%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h2 id="MySQL-8-0-忘记密码如何重置"><a href="#MySQL-8-0-忘记密码如何重置" class="headerlink" title="MySQL 8.0 忘记密码如何重置"></a>MySQL 8.0 忘记密码如何重置</h2><p>起因是安装了 8.0 版本的 MySQL，结果后来忘记了密码，上网查了好多 5.x 版本的重置密码方法，在 8.0 版本都不行。<br>后来找到了一篇同样是 8.0 版本的文章才修改成功。</p>
<p>链接地址: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hbmFnZW1lbnRBbmRKYXZhL2FydGljbGUvZGV0YWlscy84MDA5ODUyNQ==">Centos7重置Mysql 8.0.1 root 密码<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>

<p>下面简单<ruby>记录<rp>(</rp><rt>chāo xiě</rt><rp>)</rp></ruby>一下方法。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>修改配置文件，来免密登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure>

<p>找到 <code>[mysqld]</code>，在下面添加 <code>skip-grant-tables</code>。</p>
<p><img data-src="https://s2.ax1x.com/2019/11/28/QiXcfP.png" alt="修改my.cnf配置" title="修改my.cnf配置文件"></p>
<p>然后重启 MySQL 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>免密登录 MySQL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># password: 直接回车</span></span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>首先可以查看一下用户的相关信息，这一步可以忽略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT host, user, authentication_string, plugin FROM mysql.user;</span><br></pre></td></tr></table></figure>

<p><code>authentication_string</code> 就是加密后的密码，在 MySQL 5.7.9 以后废弃了 <code>password</code> 字段和 <code>password()</code> 函数。</p>
<p><code>plugin</code> 则是密码的加密方式。</p>
<p>接下来清除当前root用户的密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; UPDATE user SET authentication_string=<span class="string">&#x27;&#x27;</span> WHERE user=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>此时root用户就处于密码为空的状态了。</p>
<p>退出 MySQL，<strong>删除之前在 <code>/etc/my.cnf</code> 文件中添加的 <code>skip-grant-tables</code>，并重启 MySql 服务。</strong></p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>登录 MySQL，因为之前已经清除了密码，所以在输入密码的时候直接回车即可登入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># password: 直接回车</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>ALTER</code> 修改密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>至此，密码修改成功，可以退出重新使用用户名密码登录了。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hbmFnZW1lbnRBbmRKYXZhL2FydGljbGUvZGV0YWlscy84MDA5ODUyNQ==">https://blog.csdn.net/ManagementAndJava/article/details/80098525<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 类型定义入门</title>
    <url>//2020/11/26/typescript-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文旨在帮助新接触 TypeScript 的开发人员，能够快速了解 TypeScript 中的类型定义语法。<br>想了解更多，可以查看 TypeScript 官方文档手册：<span class="exturl" data-url="aHR0cHM6Ly93d3cudHNsYW5nLmNuL2RvY3MvaGFuZGJvb2svYmFzaWMtdHlwZXMuaHRtbA==">https://www.tslang.cn/docs/handbook/basic-types.html<i class="fa fa-external-link-alt"></i></span></p>
<p>愿你有一段愉快的 TypeScript 开发体验。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><blockquote>
<p>注：这里所说的基础类型与复杂类型，是基于 JavaScript 的原始类型与复杂类型来区分的，并非 TypeScript 文档中所说的基础类型</p>
</blockquote>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>TypeScript 是 JavaScript 的一个超集，那么在 TypeScript 中的类型基本与 JavaScript 相同。<br>在 TypeScript 中主要有这几种基础类型：<code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>bigint</code>。<br>分别对应 JavaScript 中的 <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Symbol</code> 和 <code>BigInt</code>。<br><strong>注意大小写哦</strong></p>
<h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><p>除去基础类型之外，更复杂的是其他的对应于 JavaScript 的 <code>Object</code>, <code>Array</code> 与 <code>Function</code> 的类型。<br>比如: <code>object</code>, enum枚举, <code>Array&lt;T&gt;</code>, <code>ArrayLike&lt;T&gt;</code>, Tuple元组, <code>Function</code> 等等，类型有很多，先不用太过关注这里列举出来的东西。</p>
<blockquote>
<h4 id="enum-枚举是什么？"><a href="#enum-枚举是什么？" class="headerlink" title="enum 枚举是什么？"></a>enum 枚举是什么？</h4><p>类似其他一些强类型编程语言中的枚举，当你想要一种类型，它只有有限的一些固定值时，就可以使用枚举类型。<br>它就相当于一个常量对象，内部存储了指定的有限个常量值。<br>这个类型的变量的值，只能是这些有限常量中的一个，不可能是其他任何值。<br>比如在不考虑一些特别的情况时，在我们的常识下，人类的性别只有两种：男性 和 女性。<br>此时就可以将性别作为一个枚举值来声明。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: Gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Gender &#123;</span><br><span class="line">  female = <span class="number">0</span>,</span><br><span class="line">  male = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w: IPerson = &#123;</span><br><span class="line">  name: <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: Gender.male</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可能发现了，除了将声明的枚举类型作为类型定义来使用以外，这里还把它作为一个值来使用了。<br>在 TypeScript 中，enum 关键字，除了会产生一个枚举类型定义以外，还会被编译成一个 JavaScript 对象，它是可以在代码中作为一个值来使用的。</p>
</blockquote>
<blockquote>
<h4 id="Tuple元组是什么？"><a href="#Tuple元组是什么？" class="headerlink" title="Tuple元组是什么？"></a>Tuple元组是什么？</h4><p>TypeScript中除了普通的数组类型外，还存在一种特殊的数组类型，元组。<br>用简单形象一点的说明，元组就是固定长度的数组。在这个定长数组中，可以给它的每一项来声明一个类型。<br>比如有一个长度为2的数组，它的第一项是数字，第二项是字符串。那么就可以把它声明为一个元组。<br><code>let tuple: [number, string] = [1, &#39;text&#39;];</code></p>
</blockquote>
<h3 id="空值类型与-any-类型"><a href="#空值类型与-any-类型" class="headerlink" title="空值类型与 any 类型"></a>空值类型与 any 类型</h3><p>在 TypeScript 中有那么几个比较特殊的类型：<code>void</code>, <code>null</code> 和 <code>never</code>。</p>
<p>它们都是空值类型，但是也有一些区别。</p>
<ul>
<li><code>void</code>: 表示未定义，可以对应 JavaScript 中的 <code>undefined</code></li>
<li><code>null</code>: 从字面就可以理解，它就是对应着 JavaScript 中的空值 <code>null</code></li>
<li><code>never</code>: 它是用来声明一个变量绝对不会有值，或者一个函数绝对不会返回的。<br>当给一个变量声明 <code>never</code> 类型时，那么无论是什么值，即使是 <code>undefined</code> 和 <code>null</code> 也不能赋值给这个变量。<br>同样的，如果给一个函数的返回类型声明为 <code>never</code>，就说明这个函数没有可访问的终结点，同时也就不能使用这个函数的返回值。<br>如何理解函数没有可访问的终结点，也即没有返回值：要么这个函数固定会抛出异常；要么内部有一个死循环，一直不可能返回。</li>
</ul>
<p>除了上面几个空值类型外，TypeScript 还有一个特殊的类型: <code>any</code>。<br>这个类型其实就是不明确类型，说明该类型的值可能是任何类型，无法判断。这也是针对 JavaScript 的灵活性做出的应对。<br>在 JavaScript 中，即使一开始声明一个变量并赋值为数字，但是在其他地方，也可能会把这个变量改成字符串，布尔值，甚至是一个函数。<br>在这种情况下，自然就无法确定这个变量的类型到底是什么了，也就是 <code>any</code> 类型。</p>
<h2 id="如何使用这些类型定义？"><a href="#如何使用这些类型定义？" class="headerlink" title="如何使用这些类型定义？"></a>如何使用这些类型定义？</h2><h3 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h3><p>在变量名称后面跟上冒号 <code>:</code> 加类型来声明变量的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">&#x27;Hello TS&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;unique&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> bigNum: bigint = <span class="number">996n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nums: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> fn: <span class="function">() =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IMonster &#123;</span><br><span class="line">  race: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span> | <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> yukari: IMonster = &#123;</span><br><span class="line">  race: <span class="string">&#x27;Interstice&#x27;</span>,</span><br><span class="line">  age: <span class="number">17</span>,</span><br><span class="line">  gender: <span class="string">&#x27;female&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>看了上面的示例，你可能会发出 “好麻烦啊~” 的感叹，但是实际项目中并不需要每个地方都这么显式的给每个变量注明类型。</p>
<p>TypeScript 是聪明的，它可以根据上下文来自行推断一个变量的类型。</p>
<p>举例来说，当我们给一个变量初始声明并赋值一个数字时，那么 TypeScript 就可以直接推断认为它是一个 <code>number</code> 类型的数据，而不需要你再通过如上示例那样给变量标注 <code>:number</code> 来告诉 TypeScript 它是一个数字。</p>
<p>所以在实际使用时，你尽可以这么来写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello TS&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;unique&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> bigNum = <span class="number">996n</span>;</span><br></pre></td></tr></table></figure>

<p>TypeScript 能够准确的推断出来它们各自的类型。<br>当然，如果一开始没有赋值，那么 TypeScript 自然也就无从推断，此时还是需要显式的注明类型的。<br>另一种情况是，在声明处赋予的值的类型并不明确，那么 TypeScript 也无法推断出具体的数据类型。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在某些情况下，虽然 TypeScript 无法确定一个值的类型，但是我们能够确定它的类型时，<br>就可以通过类型断言的方式来告诉 TypeScript 编译器：“我很清楚自己在干什么，相信我，它在这里就是这个类型”。</p>
<p><strong>类型断言的方式:</strong></p>
<ul>
<li>一种是在要断言的变量或表达式的后面加上 <code>as</code> 关键字并跟上要断言的类型 ( <code>value as Type</code> )。</li>
<li>另一种则是在要断言的变量或表达式的前面加上尖括号包裹的断言类型 ( <code>&lt;Type&gt;value</code> )。</li>
<li>第三种是非空断言，留到下面空值保护中再讲。</li>
</ul>
<p>我们推荐使用 <code>as</code> 关键字，写法上更易理解。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 as 关键字断言</span></span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> request(&#123;...&#125;) <span class="keyword">as</span> <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span> = <span class="string">&#x27;Hello TS&#x27;</span>;</span><br><span class="line"><span class="comment">// 使用尖括号 &lt;string&gt; 断言</span></span><br><span class="line"><span class="keyword">let</span> [, name] = (&lt;<span class="built_in">string</span>&gt;str).split(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在自定义一些复杂的类型时，接口是经常被使用到的内容，是 TypeScript 类型定义中极为重要的组成部分。</p>
<p>在 TypeScript 中要定义一个对象类型，如果你使用类型 <code>object</code>，那么你只能得到一个非原始类型的数据类型定义。</p>
<p>要想更详细的定义一个对象内有哪些属性，哪些方法，这些属性和方法有分别有着怎样的类型，这时候你就需要了解 <code>interface</code> 了。</p>
<p>你可能注意到，在上面的一些示例中，已经出现过它了。</p>
<p>比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: Gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段接口声明中，<code>interface</code> 是接口声明的关键字，<code>IPerson</code> 则是声明的接口的名字，后面的代码块中则是声明了这个接口内有哪些属性以及它们的类型。<br><code>IPerson</code> 接口有三个属性，<code>string</code> 类型的 <code>name</code> 属性、<code>number</code> 类型的 <code>age</code> 属性，<code>Gender</code> 枚举类型的 <code>gender</code> 属性。<br>当我们以接口 <code>IPerson</code> 为类型声明一个对象时，它就必须包含上述三个属性，且值要符合其各自的类型。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>并非所有的属性，在接口中都是必需的。有些属性可能一开始并不存在，或者只在某些特定条件下才会有。<br>这时候，就可以把它作为可选属性来声明。<br>只需要在正常的接口声明中，找到要设置为可选的属性，在属性名与冒号之间添加一个问号即可。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>有些属性可能只在初始化时设置一个值，在后面就不可修改了，这时就可以通过 <code>readonly</code> 关键字来设置其为只读属性。<br>只读属性只可访问，不可修改。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPoint &#123;</span><br><span class="line">  <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: IPoint = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 错误，只读属性不可修改</span></span><br><span class="line">p.x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 中有一个 ReadonlyArray&lt;T&gt; 的类型，类似 Array&lt;T&gt;</span></span><br><span class="line"><span class="comment">// 只是将数组中的可变方法去掉了，以此来确保数组被创建后，不可更改</span></span><br><span class="line"><span class="keyword">const</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 错误</span></span><br><span class="line">arr.push(<span class="number">3</span>); <span class="comment">// 错误</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 错误</span></span><br><span class="line">arr.length = <span class="number">5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。<br>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。<br>它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。<br>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<p>让我们看一个例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>TypeScript支持两种索引签名：字符串和数字。<br>可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。<br>这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。<br>也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">  [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">  [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>];</span><br><span class="line"><span class="comment">// 你不能设置myArray[2]，因为索引签名是只读的。</span></span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">&quot;Mallory&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="接口的继承与实现"><a href="#接口的继承与实现" class="headerlink" title="接口的继承与实现"></a>接口的继承与实现</h3><p>在 TypeScript 中，我们可以通过 <code>extends</code> 继承一个接口来创建它的子类型；<br>也可以强制一个类按照某个接口定义的描述来实现它，使用 <code>implements</code> 来实现一个接口。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IClock &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IAlarmClock <span class="keyword">extends</span> IClock &#123;</span><br><span class="line">  knock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">IClock</span> </span>&#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="function"><span class="title">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。<br>当一个类实现了一个接口时，只对其实例部分进行类型检查，而不会检查静态部分。</p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="联合类型与交叉类型"><a href="#联合类型与交叉类型" class="headerlink" title="联合类型与交叉类型"></a>联合类型与交叉类型</h3><p>就像上面介绍 <code>any</code> 类型时所说，有时一个变量可能不止一种类型，比如一个网络请求的返回数据，当服务能查到数据时，会返回一个数值类型的状态码，可是如果服务查询出错了，那就只能返回 null 了。<br>这种情况下，要怎么声明它既可能是一个数字，又可能是一个空值呢？</p>
<p>TypeScript 有提供一种联合类型: <code>A | B</code> 。<br>联合类型表示一个值可以是几种类型之一，用竖线( <code>|</code> )分隔每个类型。所以 <code>number | null</code> 表示一个值可以是 <code>number</code> 或 <code>null</code> 。</p>
<p>因此要声明刚刚所说的状态码的类型，就可以这样来写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可能是数值类型，也可能为 null</span></span><br><span class="line"><span class="keyword">let</span> status: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个值是联合类型，它只能访问此联合类型的所有类型里共有的成员。<br>就像这个状态码，因为 <code>null</code> 没有任何属性或方法，所以直接调用 <code>number</code> 的方法是会报错的，必须先区分出两个类型。<br>这一点可以到下面的 类型保护与区分类型 一节了解。</p>
<p>另一种情况恰好相反，某个变量是多种类型的集合，它可能同时包含有类型A和类型B。<br>这时你需要的是交叉类型: <code>A &amp; B</code>。</p>
<p>交叉类型写法类似联合类型，只是分隔符号是 <code>&amp;</code>。<br>但与联合类型相反，交叉类型是同时包含多个类型，因此它可以访问包含的任何类型的任何成员。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 既有通用区域信息，又包含热门区域信息</span></span><br><span class="line"><span class="keyword">let</span> area: ICommonArea &amp; IHotArea;</span><br></pre></td></tr></table></figure>

<h3 id="字面量类型与类型别名"><a href="#字面量类型与类型别名" class="headerlink" title="字面量类型与类型别名"></a>字面量类型与类型别名</h3><p>在 TypeScript 中除了使用特定的类型关键字以外，还可以使用字面量作为类型，以此表示常量类型。就像上面介绍枚举类型时所做的那样。<br>而这种字面量类型在实际使用场景中，通常都是多个字面量的联合类型。</p>
<p>比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字面量联合类型，达到枚举类型的效果</span></span><br><span class="line"><span class="keyword">let</span> gender: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span> = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> privilege: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">16</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果联合类型的数量比较多，又可能在多个地方使用的话，每次都写一长串的联合类型，是不是很烦恼？即使可以复制粘贴，也希望有一个更好的方式？<br>TypeScript 有提供一个声明类型别名的关键字 <code>type</code>，可以使用它来声明一个类型别名，使用这个别名来代替它的实际类型。</p>
<p>当然，类型别名并不只是用来给联合类型使用的，你也可以给一些特定的类型组合一个语义化别名，或者给一个自定义的函数类型加上语义化别名。<br>此外也可以使用类型别名(<code>type</code>)来实现一个类似于接口 (<code>interface</code>)的类型。</p>
<p>比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IPrivilege = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">16</span>;</span><br><span class="line"><span class="keyword">let</span> privilege: IPrivilege = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IGetName = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPerson = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: Gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型别名注意点"><a href="#类型别名注意点" class="headerlink" title="类型别名注意点"></a>类型别名注意点</h4><ol>
<li><p>起别名不会新建一个类型 - 它创建了一个新 <em>名字</em> 来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
</li>
<li><p>类型别名不能被 <code>extends</code> 和 <code>implements</code> （自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型）。<br>因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。<br>你可能会发现，即使去 <code>extends</code> 一个 <code>type</code>，一些开发工具也并不会对此报错，但是依然不建议这么使用。</p>
</li>
<li><p>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p>
</li>
</ol>
<h3 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h3><p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解它是否是某个特定类型时怎么办？</p>
<p>JavaScript 里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IDog &#123;</span><br><span class="line">  eat(food: <span class="built_in">string</span>);</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IBird &#123;</span><br><span class="line">  eat(food: <span class="built_in">string</span>);</span><br><span class="line">  fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnimal</span>(<span class="params"></span>): <span class="title">IDog</span> | <span class="title">IBird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ani = getAnimal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型“IBird”上不存在属性“run”</span></span><br><span class="line"><span class="keyword">if</span> (ani.run) &#123;</span><br><span class="line">  ani.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型“IDog”上不存在属性“fly”</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ani.fly) &#123;</span><br><span class="line">  ani.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了保证上面的代码不报错，我们只好使用类型断言</span></span><br><span class="line"><span class="keyword">if</span> ((&lt;IDog&gt;ani).run) &#123;</span><br><span class="line">  (&lt;IDog&gt;ani).run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((&lt;IBird&gt;ani).fly) &#123;</span><br><span class="line">  (&lt;IBird&gt;ani).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以注意到我们不得不多次使用类型断言。<br>假如我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>ani</code> 的类型的话就好了。<br>TypeScript里的 <strong>类型保护</strong> 机制让它成为了现实。<br>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。<br>要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDog</span>(<span class="params">animal: IDog | IBird</span>): <span class="title">animal</span> <span class="title">is</span> <span class="title">IDog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;IDog&gt;animal).run !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里， <code>animal is IDog</code> 就是类型谓词。<br>谓词为 <code>paramName is Type</code> 这种形式， <code>paramName</code> 必须是来自于当前函数签名里的一个参数名。<br>现在每当使用一些变量调用 <code>isDog</code> 时，TypeScript 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDog(ani)) &#123;</span><br><span class="line">  <span class="comment">// TypeScript 已经知道 ani 就是 IDog 类型了</span></span><br><span class="line">  ani.run();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 这里也能推断出 ani 不是 IDog 类型，</span></span><br><span class="line">  <span class="comment">// 由于 ani 的类型是 IDog | IBird，所以现在它就是 IBird 类型</span></span><br><span class="line">  ani.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a><code>typeof</code> 类型保护</h4><p>如果要定义一个函数来判断类型是否是原始类型，想象一下，我们要怎么去写？</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params">style: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;, width: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNumber(width)) &#123;</span><br><span class="line">    style.width = <span class="string">`<span class="subst">$&#123;width&#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isString(width)) &#123;</span><br><span class="line">    style.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;width&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还要再一个个定义其他的原始类型：<code>boolean</code>, <code>symbol</code>, <code>bigint</code>， 天啊这太痛苦了不是吗？<br>幸运的是，现在我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。</p>
<p>也就是说我们可以直接在代码里检查类型了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params">style: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;, width: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> width === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    style.width = <span class="string">`<span class="subst">$&#123;width&#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> width === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    style.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;width&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些 <strong>typeof类型保护</strong> 只有两种形式能被识别： <code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>。</p>
<p><code>&quot;typename&quot;</code> 必须是  <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;boolean&quot;</code>, <code>&quot;symbol&quot;</code>, <code>&quot;bigint&quot;</code> 或者 <code>&quot;undefined&quot;</code>。</p>
<p>但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。即 <code>&quot;object&quot;</code> 与 <code>&quot;function&quot;</code> 并不会被识别。</p>
<h4 id="instanceof-类型保护"><a href="#instanceof-类型保护" class="headerlink" title="instanceof 类型保护"></a><code>instanceof</code> 类型保护</h4><p>如果你已经阅读了 <strong>typeof类型保护</strong> 并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>
<p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">  getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123; &#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">    <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">    <span class="keyword">new</span> StringPadder(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">  padder; <span class="comment">// 类型细化为&#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">  padder; <span class="comment">// 类型细化为&#x27;StringPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instanceof</code> 的右侧要求是一个构造函数，TypeScript 将按以下顺序细化为：</p>
<ol>
<li>此构造函数的 <code>prototype</code> 属性的类型，如果它的类型不为 <code>any</code> 的话</li>
<li>构造签名所返回的类型的联合</li>
</ol>
<h4 id="可为空的类型与空值的类型保护"><a href="#可为空的类型与空值的类型保护" class="headerlink" title="可为空的类型与空值的类型保护"></a>可为空的类型与空值的类型保护</h4><p>上面我们讲过，在 TypeScript 中有三种空值类型: <code>null</code>, <code>void</code>(或者<code>undefined</code>) 和 <code>never</code>。<br>抛开 <code>never</code> 这个永不返回值或永远不存在的类型，<code>null</code> 和 <code>void</code> 也是我们在实际项目中经常要判断去除的数据。</p>
<p>在 TypeScript 中，一个可为空的类型都是通过联合类型实现的，如 <code>number | null</code>, <code>string | void</code>,  <code>number | null | undefined</code>。</p>
<p>而要使用类型保护来去除空值的话，其与在 JavaScript 里写的代码是一致的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sn == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用短路运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sn || <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某些情况编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。</p>
<p>语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>) + <span class="string">&#x27;.  the &#x27;</span> + epithet; <span class="comment">// error, &#x27;name&#x27; is possibly null</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">&#x27;.  the &#x27;</span> + epithet; <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。<br>因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。<br>如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>
<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>映射类型就是从旧类型中创建新类型的一种方式。<br>比如在接口部分中我们有提到可选属性与只读属性，但是那种是对接口中的某个或某几个属性做出的说明。<br>如果现在需要一个接口，要求它的所有属性都是可选属性，或者所有属性都是只读属性的话，总不能再写一个新的接口，并且把每个属性都加上可选或只读吧？</p>
<p>TypeScript 提供了一些这方面的预置类型：<code>Partial&lt;T&gt;</code>, <code>Readonly&lt;T&gt;</code>, <code>Pick&lt;T, K extends keyof T&gt;</code>, <code>Record&lt;K extends string, T&gt;</code>。</p>
<p>它们的实现如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，你会看到一些新的内容：<code>keyof</code> 和 索引式的 <code>for ... in</code>。<br>你可以把 <code>keyof</code> 类比到 JavaScript 中的 <code>Object.keys</code> ，它是获取接口定义的属性名列表的。<br>然后再通过 <code>in</code> 操作符挨个将属性名赋给 <code>P</code>，而后把这个 <code>P</code> 作为新接口的属性。<br>这四个类型中， <code>Partial&lt;T&gt;</code>, <code>Readonly&lt;T&gt;</code> 和 <code>Pick&lt;T, K extends keyof T&gt;</code> 都是同态的。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>你是否发现了上面几个映射类型在写法上有什么特别的？<br>它们在类型名称后面都有一个尖括号，内部有一个或多个名称。比如 <code>Partial&lt;T&gt;</code> 中的 <code>&lt;T&gt;</code>。<br>乍一看似乎和前面讲到的类型断言有点相似，只是一个在前，一个在后。</p>
<p>但它并不是类型断言，而是被叫作 <strong>泛型</strong> 。</p>
<p>不要从名字上理解，认为泛型与 <code>any</code> 类似。<br>泛型不同于 <code>any</code>，你可以认为它是一个未定义的类型别名，是一个函数的形参。<br>在实际使用时，必须给这个泛型一个明确的类型，可以是单例类型，也可以是交叉、联合类型。</p>
<p>而后 TypeScript 会根据实际使用时的类型，动态的得出最终结果的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br></pre></td></tr></table></figure>

<h4 id="为什么要用泛型？"><a href="#为什么要用泛型？" class="headerlink" title="为什么要用泛型？"></a>为什么要用泛型？</h4><p>从上面的说明中，你应该能了解到，泛型的结果与输入有关，这就相当于一个函数，输入不同，输出也会改变。<br>有时候我们就是需要根据不同的输入，得到不同的输出类型。这就是泛型的价值。<br>假设我们有下面这样一个函数，它什么也不做，只是把传入的第一个参数返回。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArg</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，我们要怎么定义它的参数arg的类型，以及函数的返回类型？<br>参数 <code>arg</code> 可以是任何类型，同样的，返回的 <code>arg</code> 自然也可以是任何类型。<br>可是如果我把它们定义为 <code>any</code> 类型，那样并不能表现出来返回类型与参数类型之间的关系，不论传入什么参数，函数的返回都是 <code>any</code> 类型。</p>
<p>可事实上，我们知道，如果传入 <code>string</code> ，它只会返回 <code>string</code>；如果传入 <code>number</code> ，它也只会返回 <code>number</code>。</p>
<p>为此，我可以使用泛型来定义，先给函数声明一个泛型 <code>A</code>【<code>A</code>仅仅只是一个随便的命名，类似于函数的形参，并非必须要命名为 <code>A</code>】，然后定义参数 <code>arg</code> 类型为 <code>A</code>。那么函数的返回类型自然也是 <code>A</code>。</p>
<p>此时我们就能发现，函数的参数类型与返回类型有了一个关联，当我传入一个 <code>string</code> 时，TypeScript 就能知道函数的返回类型也是 <code>string</code>；传入 <code>number</code> 时，也能知道返回 <code>number</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArg</span>&lt;<span class="title">A</span>&gt;(<span class="params">arg: A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>泛型很灵活，只有在使用时才能知道具体的类型是什么，这似乎有点回到 JavaScript 中的样子。<br>如果有些地方，我需要使用到泛型，然而我还希望这个泛型是某个类型的子类型时怎么办？<br>可以通过 <code>extends</code> 继承来约束泛型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 extends 约束泛型必须有一个 length 属性且类型为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArg</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型约束的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">IPerson</span> = <span class="title">IPerson</span>&gt;(<span class="params">obj: T, key: keyof T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中出现了泛型的默认值，值得注意的是，默认值与继承约束不一样，即使没有任何约束的泛型，也可以有默认值。而有默认值的泛型也并不会以默认值作为泛型的约束。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像这样，只是给泛型 T 一个默认类型 IPerson</span></span><br><span class="line"><span class="comment">// 但并没有对泛型进行任何约束，即可以在实际使用时重置泛型 T 为任何其他的类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span> = <span class="title">IPerson</span>&gt;(<span class="params">obj: T, key: keyof T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可辨识联合类型"><a href="#可辨识联合类型" class="headerlink" title="可辨识联合类型"></a>可辨识联合类型</h3><p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。<br>可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。<br>它具有3个要素：</p>
<ol>
<li>具有普通的单例类型属性 — <em>可辨识的特征</em>。</li>
<li>一个类型别名包含了那些类型的联合 — <em>联合</em>。</li>
<li>此属性上的 <em>类型保护</em>。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先我们声明将要联合的接口。</span></span><br><span class="line"><span class="comment">// 每个接口都有 kind 属性但有不同的字符串字面量类型。</span></span><br><span class="line"><span class="comment">// kind属性称做 可辨识的特征 或 标签。</span></span><br><span class="line"><span class="comment">// 其它的属性则特定于各个接口。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">  kind: <span class="string">&quot;rectangle&quot;</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">  kind: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，目前各个接口间是没有联系的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我们把它们联合到一起：</span></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们使用可辨识联合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;rectangle&quot;</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例中，我们来总结一下：</p>
<p>所谓 <strong>可辨识联合</strong> 就是多个具有相同单例属性名称但有不同字面量的类型，联合成一个类型【<em>联合</em>】，然后根据这个单例属性【即 <em>可辨识特征</em> 】的不同字面量来推断出它的具体类型【<em>类型保护</em>】。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是本文档的全部内容了，但是也只是简单介绍了一些我们项目中常用的以及实际工作中比较实用的内容；TypeScript 官方文档还有更多东西没有介绍，比如命名空间、模块、声明合并、混入等。<br>如果你对此感兴趣，想进一步了解的话，建议移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cudHNsYW5nLmNuL2RvY3MvaG9tZS5odG1s">TypeScript官方文档<i class="fa fa-external-link-alt"></i></span> 查看更多。<br>那么假如本篇文档有帮助到你的话，我很高兴能写下它。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【我得承认一点，写到后面，我直接复制了官方文档的内容】</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHNsYW5nLmNuL2RvY3MvaG9tZS5odG1s">TypeScript官方文档<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在 tsconfig.json 配置中找不到任何输入</title>
    <url>//2019/03/12/%E5%9C%A8-tsconfig-json-%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BB%BB%E4%BD%95%E8%BE%93%E5%85%A5.html</url>
    <content><![CDATA[<p><code>tsconfig.json</code> 文件内容如下，这种情况下很可能就会出现错误</p>
<blockquote>
<p>在配置文件 /path/to/program/tsconfig.json 中找不到任何输入</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2016&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;*&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;src/types/*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span>: [<span class="string">&quot;typings&quot;</span>, <span class="string">&quot;node_modules/@types&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要添加一个 <em>include</em> 数组指定包含的目录即可，或者也可以添加一个 <em>files</em> 数组指定包含的文件列表。</p>
<p>比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// Or/And files</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src/app.ts&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不能设置为一个空数组，<code>&quot;include&quot;: []</code> 这样还是会找不到任何输入的，同样的，如果设置的路径不对，依然有这个错误。</p>
<p>另有一种情况：项目内没有 typescript 文件，此时即使有 <code>include</code> 属性也依然会有错误提示。这时候要么删除 <code>tsconfig.json</code> 文件，毕竟在项目没有 typescript 文件时，有 <code>tsconfig.json</code> 文件本身就有些奇怪；但如果因为各种各样的原因，不能/不想删除它的话，也可以在项目中随便写一个 ts 文件，包含在 <code>include</code> 或 <code>files</code> 属性中。</p>
<p>附带一提，<code>tslint.json</code> 文件可以用 <code>tslint.js</code> 替代，使用 <code>module.exports</code> 导出。<br>这样可以根据环境配置来设置不同的 lint 规则。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
</search>
