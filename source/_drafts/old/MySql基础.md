---
title: MySql基础
keywords: mysql, 数据库
tags:
date: 2017-07-10, 18:38:02
---

数据库(*Database*)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。

数据库：存储数据的仓库

数据库分类
网络数据库
网络数据库是指把数据库技术引入到计算机网络系统中，借助于网络技术将存储于数据库中的大量信息及时发布出去；而计算机网络借助于成熟的数据库技术对网络中的各种数据进行有效管理，并实现用户与网络中的数据库进行实时动态数据交互。

层级数据库
层次结构模型实质上是一种有根结点的定向有序树(在数学中”树”被定义为一个无回的连通图)。

关系数据库
关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。

数据库的另外一种区分方式：基于存储介质
存储介质分为两种：磁盘和内存

关系型数据库：存储在磁盘中
非关系型数据库：存储在内存中(如 mongoDB)
关系型数据库
基本概念
关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。

关系数据结构：指的数据以什么方式来存储，是一种二维表的形式存储

本质：二维表

姓名  年龄  身高  体重
张三  25  168 60
李四  21  179 75
关系操作集合：如何来关联和管理对应的存储数据，SQL指令

获取张三的年纪：已知条件为姓名

Select 年龄 from 二维表 where 姓名 = 张三;

关系完整性约束：数据内部有对应的关联关系，以及数据与数据之间也有对应的关联关系

1. 表内约束：对应的具体列只能放对应的数据（不能乱放）
2. 表间约束：自然界各实体都是有着对应的关联关系（外键）
典型关系型数据库
Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL、SQLite

小型关系型数据库：Microsoft Access，SQLite
中型关系型数据库：SQL Server，Mysql
大型关系型数据库：Oracle，DB2

Mysql当前跟Oracle是一个公司的：隶属于Oracle
软件设计结构：C/S和B/S
C/S：Client客户端/Server服务端，用户需要安装客户端产品才能访问服务器，而且只能访问一种软件（当前自己）
B/S：Browser浏览器/Server服务端，用户只需要安装浏览器，就可以访问所有的服务器（B/S架构服务）
MySQL的访问流程
Mysql是一款C/S架构的软件，需要通过客户端来访问服务端（MySQL同时也提供了其他模式的访问：通过一些插件扩展来充当客户端）

启用MySQL客户端：mysql.exe，该软件本身可以通过CMD控制台运行，需要加入环境变量中

MySQL客户端访问服务端需要进行寻找匹配：连接认证

连接：IP和端口确认，如果是本地都可以省略

-h主机地址 ----> -hlocalhost（可以是IP）
-P端口 ----> -P3306
认证：通过用户名和密码进入服务器
-u用户名 ----> -uroot，不可以省略（匿名用户除外）
-p密码 ----> -proot
如 mysql -hlocalhost -P3306 -uroot -proot

注意：通常连接认证的时候密码不建议明文，可以在输入-p之后回车，系统会提示让输入密码，
Enter password:

此时再输入密码就是密文的，建议使用这种方式

如果没有设置密码，可以先进入

再使用 set password for root@localhost = password('123456'); 设置密码

root 是当前用户名，localhost是连接的主机地址，password(‘’)里面就是设置的密码

如果上面的方式无法设置密码，可以使用下面的方式，先以 root 身份进入数据库

-- 选择 mysql 数据库
use mysql;
-- 更新用户密码
update user set password = password('123456') where user = 'root' and host = 'localhost';
-- 刷新权限
flush privileges;
退出命令：\q、 exit

PHP连接MySQL数据库
PHP本身不具备操作MySQL数据库的能力，需要借助PHP操作MySQL的扩展来实现。

1、 PHP加载MySQL扩展：php.ini文件中
extension=php_mysql.dll
2、 PHP中所有的扩展都是在ext文件夹中，需要制定扩展所在路径：extension_dir
extension_dir = 'E:/server/php5/ext'
3、 php.ini已经被Apache加载，所以需要重启才会生效。
数据库基本操作
数据库是数据存储的最外层（最大单元）

创建数据库
基本语法：create database 数据库名字 [库选项];

库选项：数据库的相关属性

字符集：charset 字符集，代表着当前数据库下的所有表存储的数据默认指定的字符集
（如果当前不指定，那么采用DBMS默认的）

校对集：collate 校对集
create database 数据库名字 charset 字符集名称;

显示数据库
每当用户通过SQL指令创建一个数据库，那么系统就会产生一个对应的存储数据的文件夹（data目录下）

每个数据库文件夹下都有一个opt文件，保存的是对应的数据库选项。

显示全部
基本语法：show databases;
显示所有数据库

默认的有以下几个库

information_schema： 保存数据库所有的结构信息（表，库）
mysql： 核心数据库（权限关系）
performance_schema： 效率库
test： 测试，空库
显示部分
基本语法：show databases like '匹配模式';

_：匹配当前位置单个字符
%：匹配指定位置多个字符
获取以my开头的全部数据库： 'my%';

获取m开头，后面第一个字母不确定，最后为database的数据库；'m_database';

获取以database结尾的数据库：'%database';

显示数据库创建语句
基本语法：show create database 数据库名字;

看到的指令并非原始指令，而是已经被系统加工过的

选择数据库
为什么要选择数据库？

因为数据是存储在数据表中，表存在数据库下。
如果要操作数据，那么必须进入到对应的数据库才行。
基本语法：use 数据库名字;

修改数据库
修改数据库字符集(库选项)：字符集和校对集

基本语法：alter database 数据库名字 charset = 字符集;

一旦修改成功，那么对应的opt文件中就会体现

是否可以修改数据库名字?

    mysql5.5之前是可以修改的，rename命令；
    但是5.5之后就不可以。
删除数据库
基本语法：drop database 数据库名字;

删除虽简单，但是切记要做好安全操作：确保里面数据没有问题。（重要）

删除数据库之后：对应的存储数据的文件夹也会被删除（opt文件也被删除）

数据表操作
创建数据表
普通创建表
基本语法：create table 表名(字段名 字段类型 [字段属性], 字段名 字段类型 [字段属性],…) [表选项]

注意：表必须放到对应的数据库下

有两种方式可以将表挂入到指定的数据库下

    1、 在数据表名字前面加上数据库名字，用“.”连接即可：数据库.数据表
    2、 在创建数据表之前先进入到某个具体的数据库即可：use 数据库名字;
表选项：与数据库选项类似

engine：存储引擎，mysql提供的具体存储数据的方式，默认有一个innodb（5.5以前默认是myisam）
charset：字符集，只对当前自己表有效（级别比数据库高）
collate：校对集
复制已有表结构
从已经存在的表复制一份（只复制结构：如果表中有数据不复制）
基本语法：create table 新表名 like 表名; //只要使用数据库.表名，就可以在任何数据库下访问其他数据库的表名

显示数据表
每当一张数据表创建，那么就会在对应的数据库下创建一些文件（与存储引擎有关）

.frm 文件代表结构文件
注意：这个结构文件来自于innodb存储引擎，innodb存储引擎所有的文件都存储在外部的ibdata文件中

显示所有表
基本语法：show tables;

匹配显示表
基本语法：show tables like '匹配模式';

显示表结构
本质含义：显示表中所包含的字段信息（名字，类型，属性等）

describe 表名
desc 表名
show columns from 表名
Field Type  Null  Key Default Extra
name  varchar(10) YES   NULL
Field   --> 字段名字
Type    --> 字段类型
Null    --> 值是否允许为空
Key     --> 索引
Default --> 默认值
Extra   --> 额外的属性
显示表创建语句
基本语法：show create table 表名;

查看数据表创建时的语句：此语句看到的结果已经不是用户之前自己输入的。

补充：语句结束符
Mysql中有多种语句结束符

;与\g所表示的效果是一样的，都是字段在上排横着排列，下面跟对应的数据
\G字段在左侧竖着排列，数据在右侧横着
设置表属性
表属性指的就是表选项：engine，charset和collate

基本语法：alter table 表名 表选项 [=] 值;

修改表结构
修改表名：rename table 旧表名 to 新表名

修改表选项：alter table 表名 表选项 [=] 新值

注意：如果数据库已经确定了，里面有很多数据了，不要轻易修改表选项（字符集影响不大）

新增字段：alter table 表名 add [column] 新字段名 列类型 [列属性] [位置first/after 字段名]

默认加到表的最后面

字段位置：字段想要存放的位置

First：最前面，第一个字段
After 字段名：放在某个具体的字段之后（默认放到最后）
修改字段名：alter table 表名 change 旧字段名 新字段名 字段类型 [列属性] [新位置]

修改字段类型（属性）：alter table 表名 modify 字段名 新类型 [新属性] [新位置]

删除字段：alter table 表名 drop 字段名

删除表结构
基础语法：drop table 表名[, 表名2...];

可以同时删除多个数据表

数据基础操作
插入操作
本质含义：将数据以SQL的形式存储到指定的数据表（字段）里面

基本语法：向表中指定字段插入数据
insert into 表名 [(字段列表)] values(对应字段列表)

注意：

1、 后面（values中）对应的值列表只需要与前面的字段列表相对应即可（不一定与表结构完全一致）
2、 字段列表并不一定非要写上所有的表中字段
3、 如果字段列表不写，则values中的字段列表数据必须与数据表中的字段列表一致
查询操作
查询表中全部数据：select * from 表名; //*表示匹配所有的字段

查询表中部分字段：select 字段列表 from 表名; //字段列表使用逗号“,”隔开

简单条件查询数据：select 字段列表/* from 表名 where 字段名 = 值; //mysql中没有==符号

删除操作
基本语法：delete from 表名 [where 条件];

如果没有 where 条件 意味着系统会自动删除该表所有数据（慎用）

更新操作
更新：将数据进行修改（通常是修改部分字段数据）

基本语法：
update 表名 set 字段名 = 新值 [where 条件];

如果没有where条件，那么所有的表中对应的那个字段都会被修改成统一值。

表关系
一对一
一对一：一张表中的一条记录与另外一张表中最多有一条明确的关系。通常，此设计方案保证两张表中使用同样的主键即可

假设有一张学生表

学生ID（PRI） 姓名  年龄  性别  籍贯  婚否  住址
– – – – – – –
表的使用过程中，常用的信息会经常去查询，而不常用的信息可能偶尔才用到

解决方案：将数据表拆分，常见的放一张表，不常见的放一张表

常用表

学生ID（PRI） 姓名  年龄  性别
– – – –
不常用表

学生ID（PRI） 籍贯  婚否  住址
– – – –
一对多
一对多，通常也叫作多对一的关系。通常一对多的关系设计的方案，在“多”关系的表中去维护一个字段，这个字段就是“一”关系的主键。

母亲表

母亲ID  姓名  年龄  身高
M1  – – –
M2  – – –
孩子表

孩子ID  姓名  年龄  身高  母亲ID
K1  – – – M1
K2  – – – M1
多对多
多对多：一张表中的一条记录在另外一张表中可以匹配到多条记录，反过来也一样。

多对多的关系如果按照多对一的关系维护：就会出现一个字段中有多个其他表的主键，在访问的时候就会带来不便。

既然通过两张表自己增加字段解决不了问题，那么就通过第三张表来解决。

师生关系

1、    一个老师教过多个班级的学生；
2、    一个学生听过多个老师讲的课；
首先得有两个实体：老师表和学生表

老师表

Tid name  age gender
T1  张三  30  男
T2  韩梅梅 20  女
学生表

Sid name  age gender
S1  王五  16  男
S2  赵六  15  男
S3  小雅  16  女
S4  小婷  17  女
从中间设计一张表：维护两张表对应的联系，每一种联系都包含

中间表

id  Tid Sid
1 T1  S1
2 T1  S2
3 T1  S3
4 T2  S1
5 T2  S4
多对多解决方案：增加一个中间表，让中间表与对应的其他表形成两个多对一的关系，多对一的解决方案是在“多”表中增加“一”表对应的主键字段。

主键
主键，就是主要的键，primary key，在一张表中，有且只有一个字段，里面的值具有唯一性。

创建主键
1、 随表创建
系统提供了两种增加主键的方式

方案1：直接在需要当做主键的字段之后，增加primary key属性来确定主键
方案2：在所有字段之后增加 primary key 选项：primary key(字段信息)
1
2
3
4
5
6
7
8
create table my_pri1(
  username varchar(10) primary key
)charset utf8;
create table my_pri2(
  username varchar(10),
  primary key(username)
)charset utf8;
表后增加
基本语法：alter table 表名 add primary key(字段);

实现原理其实就是随表创建的方案2，在创建语句的所有字段之后增加 primary key(字段) 选项。

1
2
3
4
5
6
create table my_pri3(
  username varchar(10)
)charset utf8;
-- 增加主键
alter table my_pri3 add primary key(username);
查看主键
通过查看表结构

desc my_pri2;
可以看到结构

+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| username | varchar(10) | NO   | PRI |         |       |
+----------+-------------+------+-----+---------+-------+

Key -> PRI 主键

Null -> NO 这个怎么成了NO?
因为主键是不能为空的，所以系统会自动给主键添加一个 not null 的属性
删除主键
基本语法：alter table 表名 drop primary key;

如：

alter table my_pri3 drop primary key;
查看表结构会发现

+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| username | varchar(10) | NO   |     |         |       |
+----------+-------------+------+-----+---------+-------+

代表主键的 PRI 确实被删除了
但是主键添加的 Null 属性 NO 并没有随主键的删除而变成 YES
所以结论就是：删除主键只能删除主键设置，而不能影响 Null 属性
即使是因为添加主键才设置上的
查看表的创建语句得到

CREATE TABLE `my_pri3` (
    `username` varchar(10) NOT NULL DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=utf8 

可以发现 Null 属性是因为字段信息后面添加 NOT NULL 
复合主键
一般的一个主键就足够了，但有时一个主键是不够用的。

比如：有一张学生选修课表

一个学生可以选修多门选修课程，一门选修课程也可以由多个学生来选，但是一个学生在一门选修课中只有一个成绩

这样的话，无论是以学生id还是课程id来作为主键都不合适，因此就需要有多个主键来确定。

primary key(字段1, 字段2)
如此就可以设置多个字段共为主键，即这些字段一起构成了主键。

主键约束
主键一旦增加，那么对应的字段就会有一些数据的要求

当前字段对应的数据不能为空
当前字段对应的数据不能有任何重复
复合主键可以某个字段重复，但不能复合主键的所有字段同时重复
主键分类
主键分类采用的是主键所对应的字段的业务意义分类

业务主键：主键所在的字段，具有业务意义（学生ID，课程ID）

逻辑主键：自然增长的整型（应用广泛）

自动增长
自动增长：auto_increment，当给定某个字段该属性之后，该列的数据在没有提供确定数据的时候，系统会根据之前已经存在的数据进行自动增加后，填充数据。

但是如果主动设置了一个更大的值，自动增长就会从最大的值开始继续增长，并且即使删除了最大的值，自动增长的记录还是会存在，而不会降回去。

自动增长通常用于逻辑主键。

自动增长的原理：
在系统中有维护一组数据，用来保存当前使用了自动增长属性的字段，记住当前对应的数据值，再给定一个指定的步长
当用户进行数据插入的时候，如果没有给定值，系统在原始值上再加上步长变成新的数据
自动增长的触发：给定属性的字段没有提供值
自动增长只适用于数值
使用自动增长
基本语法：在字段之后增加一个属性 auto_increment

想要触发自动增长，在插入数据的时候就不能给自动增长字段给定具体的值，而要写空(null)。

高级数据操作
新增数据
多数据插入
insert into 插入数据是可以一次插入多条数据的，只需要在第一条插入的数据后面继续写就行了，每条数据用英文半角逗号(,)隔开。

基本语法：insert into 表名 [(字段列表)] values(值列表), (值列表)…;

如：

1
insert into my_gbk values('张三'),('李四'),('王五');
主键冲突
主键冲突：在有的表中，使用的是业务主键（字段有业务含义），但是往往在进行数据插入的时候，又不确定数据表中是否已经存在对应的主键。

这样就有可能会造成插入数据时因为主键已经有了相同名称的数据而产生冲突。

解决办法：

主键冲突更新

类似插入数据语法，如果插入的过程中主键冲突，那么采用更新方法。

insert into 表名 [(字段列表)] values(值列表) on duplicate key update 字段 = 新值;
主键冲突替换

当主键冲突之后，干掉原来的数据，重新插入进去。

replace into [(字段列表)] values(值列表);
替换语法在性能上低于更新语法

蠕虫复制
蠕虫复制：一分为二，成倍增加。从已有的数据中获取数据，并且将获取到的数据插入到数据表中。

基本语法：insert into 表名 [(字段列表)] select */字段列表 from 表;

注意：
1、    蠕虫复制通常是重复数据，没有太大业务意义；
    不过可以在短期内快速增加表的数据量，从而测试表的压力；
    还可以通过大量数据来测试表的效率（索引）。
2、    蠕虫复制虽好，但是要注意主键冲突。
更新数据
在更新数据的时候，特别要注意：通常一定是跟随条件更新

update 表名 set 字段名 = 新值 where 判断条件;
如果没有条件，是全表更新数据。但是可以使用 limit 来限制更新的数量；

update 表名 set 字段名 = 新值 [where 判断条件] limit 限制数量;
比如将 my_simple 中的4个 a 变为 e

update my_simple set name = 'e' where name = 'a' limit 4;
删除数据
基本语法：delete from 表名 [where 条件]

删除数据的时候尽量不要全部删除，应该使用where进行 判定；
删除数据的时候可以使用limit来限制要删除的具体数量
delete 删除数据的时候无法重置 auto_increment，也就是说，使用 delete 删除了数据之后，重新添加的数据中自动增长的值是按照删除之前最后一次的值来的，而不是重置后重新开始。

如果希望重置 auto_increment

mysql 有一个能够重置表选项中的自增长的语法：

truncate 表名;
相当于先删除表再重新创建(drop -> create)

查询数据
完整的查询指令：

select select选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制

select选项：
系统该如何对待查询得到的结果

all：默认的，表示保存所有的记录
distinct：去重，去除重复的记录，只保留一条（重复指的是：所有的字段都相同）
字段列表：
有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段命名成不同名的，也就是赋予别名 alias

基本语法：字段名 [as] 别名

from 数据源
from 是为前面的查询提供数据的，数据源只要是一个符合二维表结构的数据即可。

单表数据

from 表名;

多表数据

从多张表获取数据，基本语法：from 表1,表2…

结果：两张表的记录数相乘，字段数拼接

本质：从第一张表取出一条记录，去拼凑第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的说法：笛卡尔积。但是这个结果除了给数据库造成压力，没有其他意义，所以应该尽量避免出现笛卡尔积。

动态数据
from后面跟的数据不一定是一个实体表，还可能是一个从表中查询出来得到的二维结果表（子查询），这就是动态数据。

基本语法：from (select 字段列表 from 表) as 表别名;

给子查询得到的结果表添加别名是必须的
() 中的语句会被作为整体得到数据，但是 from 需要一个数据表名，
因此必须给子查询得到的数据赋一个临时的别名来使用。
where 子句
where子句：用来从数据表获取数据的时候，进行条件筛选。

数据获取原理：针对表去对应的磁盘处获取所有的记录（一条条），where 的作用就是在拿到一条结果就开始进行判断，判断是否符合条件：如果符合就保存下来，如果不符合直接舍弃（不放到内存中）

where 是通过运算符进行结果比较来判断数据的。

group by 子句
group by 表示分组的含义：根据指定的字段，将数据进行分组，而分组的目的主要是为了统计

分组统计
基本语法： group by 字段名;

group by 是为了分组后进行数据统计的，如果只是想看数据显示，那么 group by 没什么含义。group by 将数据按照指定的字段分组之后，只会保留每组的第一条记录。

利用一些统计函数（聚合函数）来分组统计数据

count()：统计每组中的数量，如果统计目标是字段，那么不统计为空(NULL)字段，如果为*那么代表统计记录
avg()：求平均值
sum()：求和
max()：求最大值
min()：求最小值
group_concat()：为了将分组中指定的字段进行合并（字符串拼接）
多分组
将数据按照某个字段进行分组之后，对已经分组的数据进行再次分组

基本语法：

1
2
group by '字段1','字段2';
-- 先按照字段1进行排序，之后将结果再按照字段2进行排序，以此类推。
分组排序
Mysql中，分组默认有排序的功能：按照分组字段进行排序，默认是升序(asc)

基本语法：group by 字段 [asc|desc]，字段 [asc|desc]

回溯统计
当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称之为回溯统计。

每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL。

基本语法：group by 字段 [asc|desc] with rollup;

having子句
having 的本质和 where 一样，是用来进行数据条件筛选。

having 是在 group by 子句之后，可以针对分组数据进行统计筛选，但是 where 不行。

where 不能使用聚合函数：聚合函数是用在 group by 分组的时候，where 已经运行完毕。

having 在 group by 分组之后，可以使用聚合函数或者字段别名（where 是从表中取出数据，别名是在数据进入到内存之后才有的）。

强调：having 是在 group by 之后，group by 是在 where 之后：where 的时候表示将数据从磁盘拿到内存，where 之后的所有操作都是内存操作。

order by 子句
order by 排序：根据校对规则对数据进行排序

基本语法：order by 字段 [asc|desc]; //默认asc升序

order by 也可以像 group by 一样进行多字段排序：先按照第一个字段进行排序，然后再按照第二个字段进行排序。

order by 字段1 规则,字段2 规则;

limit 子句
limit 限制子句：主要是用来限制记录数量

获取记录数限制

纯粹的限制获取的数量：从第一条到指定的数量

基本语法： limt 数量;

limit通常在查询的时候如果限定为一条记录的时候，使用的比较多：有时候获取多条记录并不能解决业务问题，但是会增加服务器的压力。

分页
利用limit来限制获取指定区间的数据。

基本语法：

1
2
3
4
limit offset,length;
-- offset: 偏移量, 从哪开始
-- length: 就是具体的获取多少条记录
mysql中记录的数量从0开始

limit 0,2; 表示获取前两条记录

注意：limit 后面的 length 表示最多获取对应数量，但是如果数量不够，系统不会强求

查询中的运算符
算术运算符
+、-、*、/、%

基本算术运算：通常不在条件中使用，而是用于结果运算（select 字段中）

在 mysql 中除法的运算结果是用浮点数表示的，如果除数为0，系统会给出NULL，
NULL 进行任何算术运算结果都为0

比较运算符
>、>=、<、<=、=、<>

通常是用来在条件中进行限定结果

=：在mysql中，没有对应的 == 比较符号，就是使用 = 来进行相等判断

<=>：也是相等比较

特殊应用：就是在字段结果中进行比较运算

在 mysql 中，数据会先自动转换成同类型，再比较

在 mysql 中，没有 bool 值，1 代表 true， 0 代表 false

在条件判断的时候，还有对应的比较运算符：计算区间

Between 条件1 and 条件2;

Between中条件1必须小于条件2，反过来不可以

逻辑运算符
and、or、not

and：逻辑与

or：逻辑或

not：逻辑非

in运算符
in：在什么里面，用来替代 = ，当结果不是一个值，而是一个结果集的时候

基本语法： in (结果1,结果2,结果3…)，只要当前条件在结果集中出现过，那么就成立

is运算符
is 是专门用来判断字段是否为 NULL 的运算符

基本语法：is null / is not null

like运算符
like 运算符：是用来进行模糊匹配（匹配字符串）

基本语法：like '匹配模式';

匹配模式中，有两种占位符：

_：匹配对应位置的单个字符
%：匹配对应位置的多个字符
连接查询
连接查询：将多张表连到一起进行查询（会导致记录数行和字段数列发生改变）

连接查询的意义
在关系型数据库设计过程中，实体（表）与实体之间是存在很多联系的。在关系型数据库表的设计过程中，遵循着关系来设计：一对一，一对多和多对多。
通常在实际操作的过程中，需要利用这层关系来保证数据的完整性。

连接查询分类
连接查询一共有以下几类：

交叉连接
内连接
外连接：左外连接（左连接）和右外连接（右连接）
自然连接
内连接
内连接：inner join，

从一张表中取出所有的记录去另外一张表中利用匹配条件进行匹配，成功了保留，失败了放弃。

原理
从第一张表中取出一条记录，然后去另外一张表中进行匹配
利用匹配条件进行匹配：
匹配到：保留，继续向下匹配
匹配失败：向下继续，如果全表匹配失败，结束
语法
基本语法：表1 [inner] join 表2 on 匹配条件;

如果内连接没有条件（允许），那么其实就是交叉连接（应该避免）

select * from my_student inner join my_class;
-- 应该尽量避免这种情况
使用匹配条件进行匹配

select * from my_student inner join my_class on class_id = id;
因为表的设计通常容易产生同名字段，尤其是ID，所以为了避免重名出现错误，通常使用表名.字段名，来确保唯一性

select * from my_student inner join my_class on my_student.class_id = my_class.id;
通常，如果条件中使用到对应的表名，而表名通常比较长，所以可以通过表别名来简化

select * from my_student as s inner join my_class c on s.class_id = c.id;
内连接匹配的时候，必须保证匹配到才会保存

内连接因为不强制必须使用匹配条件（on）因此可以在数据匹配完成之后，使用where条件来限制，效果与on一样（建议使用on，虽然效果一样，但是 where 是先将所有数据匹配之后再根据条件来限制，也就是说之前做了很多无用功）

select * from my_class c inner join my_student as s where s.class_id = c.id;
应用
内连接通常是在对数据有精确要求的地方使用：必须保证两种表中都能进行数据匹配。

外连接
外链接：outer join，按照某一张表作为主表（表中所有记录在最后都会保留），根据条件去连接另外一张表，从而得到目标数据。

外连接分为两种：左外连接（left join），右外连接（right join）

左连接：左表是主表
右连接：右表是主表
原理
确定连接主表：左连接就是 left join 左边的表为主表； right join 就是右边为主表
拿主表的每一条记录，去匹配另外一张表（从表）的每一条记录
如果满足匹配条件就保留；不满足就不保留
如果主表记录在从表中一条都没有匹配成功，那么也要保留该记录，只是从表对应的字段值都为NULL
语法
基本语法：

左连接：主表 left join 从表 on 连接条件;

1
2
select * from my_student as s left join my_class c on s.class_id = c.id;
-- 左连接，以 my_student 表做为主表
右连接：从表 right join 主表 on 连接条件;

1
2
select * from my_student as s right join my_class c on s.class_id = c.id;
-- 右连接，以 my_class 表做为主表
on 是必须的

左连接对应的主表数据在左边；右连接对应的主表数据在右边；

特点

外连接中主表数据记录一定会保存：连接之后不会出现记录数少于主表（内连接可能）
左连接和右连接其实可以互相转换，但是数据对应的位置（表顺序）会改变，（左表的数据在左边）
应用
非常常用的一种获取对应主表以及其他关联数据的方式

非常常用的一种获取的数据方式：作为数据获取对应主表以及其他关联数据
